// 
// Decompiled by Procyon v0.6.0
// 

package me.nzxtercode.bettercraft.client.misc.background;

public class ShaderList2
{
    public static String Putzefurcht;
    public static String Nastrovje;
    public static String PreLifeRecode;
    public static String Auroras;
    public static String Rainbow;
    public static String OtherRainbow;
    public static String RainbowDash;
    public static String Corona;
    public static String Lichttunnel;
    public static String Mars;
    public static String Insel;
    public static String Berge;
    public static String Wasserwirbel;
    public static String Whitekugel;
    public static String Planet;
    public static String Radar;
    public static String Wuerfellego;
    public static String Spin;
    public static String Glasstown;
    public static String Blue;
    public static String Wolken;
    public static String Floor;
    public static String Crack;
    public static String Line;
    public static String Street;
    public static String Sonne;
    public static String Darkblue;
    public static String Test8;
    public static String Greentown;
    public static String Whitewuerfel;
    public static String GalaxyGurtel;
    public static String Zauberwuerfel;
    public static String Blackandwhite;
    public static String Pyramide;
    public static String Roetem;
    public static String Sheep;
    public static String Rakete;
    public static String Leuchtring;
    public static String Ecasty;
    
    static {
        ShaderList2.Putzefurcht = "#ifdef GL_ES\r\nprecision mediump float;\r\n#endif\r\n\r\n#define NUM_OCTAVES 16\r\n\r\nuniform float time;\r\nuniform vec2 resolution;\r\n\r\nmat3 rotX(float a) {\r\n\tfloat c = cos(a);\r\n\tfloat s = sin(a);\r\n\treturn mat3(\r\n\t\t1, 0, 0,\r\n\t\t0, c, -s,\r\n\t\t0, s, c\r\n\t);\r\n}\r\nmat3 rotY(float a) {\r\n\tfloat c = cos(a);\r\n\tfloat s = sin(a);\r\n\treturn mat3(\r\n\t\tc, 0, -s,\r\n\t\t0, 1, 0,\r\n\t\ts, 0, c\r\n\t);\r\n}\r\n\r\nfloat random(vec2 point) {\r\n\treturn fract(100.0 * sin(point.x + fract(100.0 * sin(point.y)))); // http://www.matteo-basei.it/noise\r\n}\r\n\r\nfloat noise(vec2 pos) {\r\n\tvec2 i = floor(pos);\r\n\tvec2 f = fract(pos);\r\n\tfloat a = random(i + vec2(0.0, 0.0));\r\n\tfloat b = random(i + vec2(1.0, 0.0));\r\n\tfloat c = random(i + vec2(0.0, 1.0));\r\n\tfloat d = random(i + vec2(1.0, 1.0));\r\n\tvec2 u = f * f * (3.0 - 2.0 * f);\r\n\treturn mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\r\n}\r\n\r\nfloat fbm(vec2 pos) {\r\n\tfloat v = 0.0;\r\n\tfloat a = 0.5;\r\n\tvec2 shift = vec2(100.0);\r\n\tmat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.5));\r\n\tfor (int i=0; i<NUM_OCTAVES; i++) {\r\n\t\tv += a * noise(pos);\r\n\t\tpos = rot * pos * 2.0 + shift;\r\n\t\ta *= 0.5;\r\n\t}\r\n\treturn v;\r\n}\r\n\r\nvoid main(void) {\r\n\tvec2 p = (gl_FragCoord.xy * 2.0 - resolution.xy) / min(resolution.x, resolution.y);\r\n\r\n\tfloat t = 0.0, d;\r\n\t\r\n\tfloat time2 = time / 2.0;\r\n\t\r\n\tvec2 q = vec2(0.0);\r\n\tq.x = fbm(p + 0.00 * time2);\r\n\tq.y = fbm(p + vec2(1.0));\r\n\tvec2 r = vec2(0.0);\r\n\tr.x = fbm(p + 1.0 * q + vec2(1.7, 9.2) + 0.15 * time2);\r\n\tr.y = fbm(p + 1.0 * q + vec2(8.3, 2.8) + 0.126 * time2);\r\n\tfloat f = fbm(p + r);\r\n\tvec3 color = mix(\r\n\t\tvec3(0.101961, 0.619608, 1.666667),\r\n\t\tvec3(0.666667, 0.666667, 1.498039),\r\n\t\tclamp((f * f) * 4.0, 0.0, 1.0)\r\n\t);\r\n\r\n\tcolor = mix(\r\n\t\tcolor,\r\n\t\tvec3(0, 0, 0.164706),\r\n\t\tclamp(length(q), 0.0, 1.0)\r\n\t);\r\n\r\n\r\n\tcolor = mix(\r\n\t\tcolor,\r\n\t\tvec3(0.66666, 0.11111, 0),\r\n\t\tclamp(length(r.x), 0.0, 1.0)\r\n\t);\r\n\r\n\tcolor = (f *f * f + 0.6 * f * f + 0.5 * f) * color;\r\n\t\r\n\tgl_FragColor = vec4(color, 1.0);\r\n}";
        ShaderList2.Nastrovje = "precision highp float;\n\nuniform vec2 resolution;\nuniform float time;\nuniform vec2 mouse;\n\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy, vec2(12.9898,78.233)))* 43758.5453123);\n}\n\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    float a = random(i);\n    float b = random(i + vec2(1., 0.));\n    float c = random(i + vec2(0., 1.));\n    float d = random(i + vec2(1., 1.));\n\n    vec2 u = f * f * (3. - 2. * f);\n\n    return mix(a, b, u.x) + (c - a)* u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\n    #define octaves 5\n\nfloat fbm (in vec2 p) {\n    float value = 0.;\n    float freq = 1.;\n    float amp = .5;\n\n    for (int i = 0; i < octaves; i++) {\n        value += amp * (noise((p - vec2(1.)) * freq));\n        freq *= 2.3;\n        amp *= .4;\n    }\n\n    return value;\n}\n\nfloat pattern(in vec2 p) {\n    vec2 offset = vec2(-.1);\n\n    vec2 aPos = vec2(sin(time * .1), sin(time * .1)) * 6. + time*0.1;\n    vec2 aScale = vec2(3.);\n    float a = fbm(p * aScale + aPos);\n\n    vec2 bPos = vec2(sin(time * .1), sin(time * .1)) * 1. + time*0.05;\n    vec2 bScale = vec2(.5);\n    float b = fbm((p + a) * bScale + bPos);\n\n    vec2 cPos = vec2(-.6, -.5) + vec2(sin(-time * .01), sin(time * .1)) * 2. - time*0.02;\n    vec2 cScale = vec2(2.);\n    float c = fbm((p + b) * cScale + cPos);\n\n    return c;\n}\n\nvoid main() {\n    vec2 p = 3. * gl_FragCoord.xy / resolution.xy;\n    p.x *= resolution.x / resolution.y;\n\n    float value = pow(pattern(p), 1.);\n\n    gl_FragColor = vec4(vec3(value/12., value/1., value/1.10), 1.);\n}";
        ShaderList2.PreLifeRecode = "/*\n * Original shader from: https://www.shadertoy.com/view/WdV3DW\n */\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n// glslsandbox uniforms\nuniform float time;\nuniform vec2 resolution;\n\n// shadertoy emulation\n#define iTime time\n#define iResolution resolution\n\n// --------[ Original ShaderToy begins here ]---------- //\n//Base values modified with depth later\nfloat intensity = 1.0;\nfloat radius = 0.1;\n\n//Distance functions from \n//https://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat triangleDist(vec2 p){ \n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x+k*p.y>0.0 ) p=vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0, 0.0 );\n    return -length(p)*sign(p.y);\n}\n\nfloat boxDist(vec2 p){\n    vec2 d = abs(p)-1.0;\n    return length(max(d,vec2(0))) + min(max(d.x,d.y),0.0);\n}\n\nfloat circleDist( vec2 p){\n  return length(p) - 1.0;\n}\n\n//https://www.shadertoy.com/view/3s3GDn\nfloat getGlow(float dist, float radius, float intensity){\n    return pow(radius/dist, intensity);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n\tvec2 uv = fragCoord/iResolution.xy;\n    float widthHeightRatio = iResolution.x/iResolution.y;\n    vec2 centre;\n    vec2 pos;\n\t\n    float t = iTime * 0.05;\n    \n    float dist;\n    float glow;\n    vec3 col = vec3(0);\n    \n    //The spacing between shapes\n    const float scale = 500.0;\n    //Number of shapes\n    const float layers = 20.0;\n    \n    float depth;\n    vec2 bend;\n    \n    const vec3 purple = vec3(0.611, 0.129, 0.909);\n    const vec3 green = vec3(0.133, 0.62, 0.698);\n    \n    float angle;\n    float rotationAngle;\n    mat2 rotation;\n    \n    //For movement of the anchor point in time\n    float d = 2.5*(sin(t) + sin(3.0*t));\n\n    //Create an out of frame anchor point where all shapes converge to    \n    //vec2 anchor = vec2(0.5 + cos(d), 0.5 + sin(d));\n    vec2 anchor = vec2(0.5);\n\t\n    //Create light purple glow at the anchor loaction\n    pos = anchor - uv;\n    pos.y /= widthHeightRatio;\n    dist = length(pos);\n    glow = getGlow(dist, 0.35, 1.9);\n    //col += glow * vec3(0.7,0.6,1.0);\n    \n\tfor(float i = 0.0; i < layers; i++){\n        \n        //Time varying depth information depending on layer\n        depth = fract(i/layers + t);\n\n        //Move the focus of the camera in a circle\n        //centre = vec2(0.5 + 0.2 * sin(t), 0.5 + 0.2 * cos(t));\n        centre = vec2(0.5);\n        //Position shapes between the anchor and the camera focus based on depth\n        bend = mix(anchor, centre, depth);\n     \t\n        pos = bend - uv;\n    \tpos.y /= widthHeightRatio;\n\n        //Rotate shapes\n       \trotationAngle = 3.14 * sin(depth + fract(t) * 6.28) + i;\n        rotation = mat2(cos(rotationAngle), -sin(rotationAngle), \n                        sin(rotationAngle),  cos(rotationAngle));\n        \n        pos *= rotation;\n        \n        //Position shapes according to depth\n    \tpos *= mix(scale, 0.0, depth);\n    \t\n        float m = mod(i, 3.0);\n        if(m == 0.0){\n        \tdist = abs(boxDist(pos));\n        }else if(m == 1.0){\n        \tdist = abs(triangleDist(pos));\n        }else{\n        \tdist = abs(circleDist(pos));\n        }\n       \n        //Get glow from base radius and intensity modified by depth\n    \tglow = getGlow(dist, radius+(1.0-depth)*2.0, intensity + depth);\n        \n        //Find angle along shape and map from [-PI; PI] to [0; 1]\n        angle = (atan(pos.y, pos.x)+3.14)/6.28;\n        //Shift angle depending on layer and map to [1...0...1]\n\t\tangle = abs((2.0*fract(angle + i/layers)) - 1.0);\n        \n        //White core\n    \tcol += 10.0*vec3(smoothstep(0.03, 0.02, dist));\n        \n        //Glow according to angle value\n     \tcol += glow * mix(green, purple, angle);\n\t}\n    \n    //Tone mapping\n    col = 1.0 - exp(-col);\n    \n    //Output to screen\n    fragColor = vec4(col,1.0);\n}\n// --------[ Original ShaderToy ends here ]---------- //\n\nvoid main(void)\n{\n    mainImage(gl_FragColor, gl_FragCoord.xy);\n}";
        ShaderList2.Auroras = "//Auroras by nimitz 2017 (twitter: @stormoid)\n\n/*\n\t\n\tThere are two main hurdles I encountered rendering this effect. \n\tFirst, the nature of the texture that needs to be generated to get a believable effect\n\tneeds to be very specific, with large scale band-like structures, small scale non-smooth variations\n\tto create the trail-like effect, a method for animating said texture smoothly and finally doing all\n\tof this cheaply enough to be able to evaluate it several times per fragment/pixel.\n\n\tThe second obstacle is the need to render a large volume while keeping the computational cost low.\n\tSince the effect requires the trails to extend way up in the atmosphere to look good, this means\n\tthat the evaluated volume cannot be as constrained as with cloud effects. My solution was to make\n\tthe sample stride increase polynomially, which works very well as long as the trails are lower opcaity than\n\tthe rest of the effect. Which is always the case for auroras.\n\n\tAfter that, there were some issues with getting the correct emission curves and removing banding at lowered\n\tsample densities, this was fixed by a combination of sample number influenced dithering and slight sample blending.\n\n\tN.B. the base setup is from an old shader and ideally the effect would take an arbitrary ray origin and\n\tdirection. But this was not required for this demo and would be trivial to fix.\n*/\n\n#ifdef GL_ES\nprecision highp float;\n#endif\n\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n#define iGlobalTime time\n#define iTime time\n#define iMouse (mouse * resolution)\n#define iResolution resolution.xy\n\nmat2 mm2(in float a){float c = cos(a), s = sin(a);return mat2(c,s,-s,c);}\nmat2 m2 = mat2(0.95534, 0.29552, -0.29552, 0.95534);\nfloat tri(in float x){return clamp(abs(fract(x)-.5),0.01,0.49);}\nvec2 tri2(in vec2 p){return vec2(tri(p.x)+tri(p.y),tri(p.y+tri(p.x)));}\n\nfloat triNoise2d(in vec2 p, float spd)\n{\n    float z=1.8;\n    float z2=2.5;\n\tfloat rz = 0.;\n    p *= mm2(p.x*0.06);\n    vec2 bp = p;\n\tfor (float i=0.; i<5.; i++ )\n\t{\n        vec2 dg = tri2(bp*1.85)*.7;\n        dg *= mm2(time*spd);\n        p -= dg/z2;\n\n        bp *= 1.3;\n        z2 *= .45;\n        z *= .42;\n\t\tp *= 1.21 + (rz-1.0)*.02;\n        \n        rz += tri(p.x+tri(p.y))*z;\n        p*= -m2;\n\t}\n    return clamp(1./pow(rz*29., 1.3),0.,.55);\n}\n\nfloat hash21(in vec2 n){ return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453); }\nvec4 aurora(vec3 ro, vec3 rd)\n{\n    vec4 col = vec4(0);\n    vec4 avgCol = vec4(0);\n    \n    for(float i=0.;i<50.;i++)\n    {\n        float of = 0.006*hash21(gl_FragCoord.xy)*smoothstep(0.,15., i);\n        float pt = ((.8+pow(i,1.4)*.002)-ro.y)/(rd.y*2.+0.4);\n        pt -= of;\n    \tvec3 bpos = ro + pt*rd;\n        vec2 p = bpos.zx;\n        float rzt = triNoise2d(p, 0.06);\n        vec4 col2 = vec4(0,0,0, rzt);\n        col2.rgb = (sin(1.-vec3(2.15,-.5, 1.2)+i*0.043)*0.5+0.5)*rzt;\n        avgCol =  mix(avgCol, col2, .5);\n        col += avgCol*exp2(-i*0.065 - 2.5)*smoothstep(0.,5., i);\n        \n    }\n    \n    col *= (clamp(rd.y*15.+.4,0.,1.));\n    \n    \n    //return clamp(pow(col,vec4(1.3))*1.5,0.,1.);\n    //return clamp(pow(col,vec4(1.7))*2.,0.,1.);\n    //return clamp(pow(col,vec4(1.5))*2.5,0.,1.);\n    //return clamp(pow(col,vec4(1.8))*1.5,0.,1.);\n    \n    //return smoothstep(0.,1.1,pow(col,vec4(1.))*1.5);\n    return col*1.8;\n    //return pow(col,vec4(1.))*2.\n}\n\n\n//-------------------Background and Stars--------------------\n\n//From Dave_Hoskins (https://www.shadertoy.com/view/4djSRW)\nvec3 hash33(vec3 p)\n{\n    p = fract(p * vec3(443.8975,397.2973, 491.1871));\n    p += dot(p.zxy, p.yxz+19.27);\n    return fract(vec3(p.x * p.y, p.z*p.x, p.y*p.z));\n}\n\nvec3 stars(in vec3 p)\n{\n    vec3 c = vec3(0.);\n    float res = iResolution.x*1.;\n    \n\tfor (float i=0.;i<4.;i++)\n    {\n        vec3 q = fract(p*(.15*res))-0.1;\n        vec3 id = floor(p*(.15*res));\n        vec2 rn = hash33(id).xy;\n        float c2 = 1.-smoothstep(0.,.6,length(q));\n        c2 *= step(rn.x,.0005+i*i*0.001);\n        c += c2*(mix(vec3(1.0,0.49,0.1),vec3(0.75,0.9,1.),rn.y)*0.1+0.9);\n        p *= 1.3;\n    }\n    return c*c*.8;\n}\n\nvec3 bg(in vec3 rd)\n{\n    float sd = dot(normalize(vec3(-0.5, -0.5, 0.9)), rd)*0.5+0.5;\n    sd = pow(sd, 5.);\n    vec3 col = mix(vec3(0.05,0.1,0.2), vec3(0.1,0.05,0.2), sd);\n    return col*.53;\n}\n//-----------------------------------------------------------\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = q - 0.1;\n\tp.x*=iResolution.x/iResolution.y;\n    \n    vec3 ro = vec3(0,0,-6.7);\n    vec3 rd = normalize(vec3(p,1.3));\n    \n    vec3 col = vec3(0.);\n    vec3 brd = rd;\n    float fade = smoothstep(0.,0.01,abs(brd.y))*0.1+0.9;\n    \n    col = bg(rd)*fade;\n    \n    if (rd.y > 0.){\n        vec4 aur = smoothstep(0.,1.5,aurora(ro,rd))*fade;\n        col += stars(rd);\n        col = col*(1.-aur.a) + aur.rgb;\n    }\n    else //Reflections\n    {\n        rd.y = abs(rd.y);\n        col = bg(rd)*fade*0.6;\n        vec4 aur = smoothstep(0.0,2.5,aurora(ro,rd));\n        col += stars(rd)*0.1;\n        col = col*(1.-aur.a) + aur.rgb;\n        vec3 pos = ro + ((0.5-ro.y)/rd.y)*rd;\n        float nz2 = triNoise2d(pos.xz*vec2(.5,.7), 0.);\n        col += mix(vec3(0.2,0.25,0.5)*0.08,vec3(0.3,0.3,0.5)*0.7, nz2*0.4);\n    }\n    \n\tfragColor = vec4(col, 1.);\n}\nvoid main( void ) {\n\tvec4 colo = vec4(0.0);\n\tmainImage(colo, gl_FragCoord.xy);\n\tgl_FragColor = colo;\n}";
        ShaderList2.Rainbow = "// Colorful Voronoi \n// By: Brandon Fogerty\n// bfogert,y at gmail dot com\n// xdpixel.com\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n\nvec2 hash(vec2 p)\n{\n    mat2 m = mat2(  13.85, 47.77,\n                    99.81, 88.48\n                );\n\n    return fract(sin(m*p) * 46738.29);\n}\n\nfloat voronoi(vec2 p)\n{\n    vec2 g = floor(p);\n    vec2 f = fract(p);\n\n    float distanceToClosestFeaturePoint = 1.0;\n    for(int y = -1; y <= 1; y++)\n    {\n        for(int x = -1; x <= 1; x++)\n        {\n            vec2 latticePoint = vec2(x, y);\n            float currentDistance = distance(latticePoint + hash(g+latticePoint), f);\n            distanceToClosestFeaturePoint = min(distanceToClosestFeaturePoint, currentDistance);\n        }\n    }\n\n    return distanceToClosestFeaturePoint;\n}\n\nvoid main( void )\n{\n    vec2 uv = ( gl_FragCoord.xy / resolution.xy ) * 1.0 - 1.0;\n    uv.x *= resolution.x / resolution.y;\n\n    float offset = voronoi(uv*10.0 + vec2(time));\n    float t = 1.5/abs(((uv.x + sin(uv.y + time)) + offset) * 60.0);\n\n    float r = voronoi( uv * 1.0 ) * 10.0;\n    vec3 finalColor = vec3(10.0 * uv.y, 2.0, 1.0 * r) * t;\n    \n    gl_FragColor = vec4(finalColor, 1.0 );\n}";
        ShaderList2.OtherRainbow = "// Colorful Voronoi \n// By: Brandon Fogerty\n// bfogert,y at gmail dot com\n// xdpixel.com\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n\nvec2 hash(vec2 p)\n{\n    mat2 m = mat2(  13.85, 47.77,\n                    99.41, 88.48\n                );\n\n    return fract(sin(m*p) * 46738.29);\n}\n\nfloat voronoi(vec2 p)\n{\n    vec2 g = floor(p);\n    vec2 f = fract(p);\n\n    float distanceToClosestFeaturePoint = 1.0;\n    for(int y = -1; y <= 1; y++)\n    {\n        for(int x = -1; x <= 1; x++)\n        {\n            vec2 latticePoint = vec2(x, y);\n            float currentDistance = distance(latticePoint + hash(g+latticePoint), f);\n            distanceToClosestFeaturePoint = min(distanceToClosestFeaturePoint, currentDistance);\n        }\n    }\n\n    return distanceToClosestFeaturePoint;\n}\n\nvoid main( void )\n{\n    vec2 uv = ( gl_FragCoord.xy / resolution.xy ) * 2.0 - 1.0;\n    uv.x *= resolution.x / resolution.y;\n\n    float offset = voronoi(uv*10.0 + vec2(time));\n    float t = 1.0/abs(((uv.x + sin(uv.y + time)) + offset) * 30.0);\n\n    float r = voronoi( uv * 1.0 ) * 10.0;\n    vec3 finalColor = vec3(10.0 * uv.y, 2.0, 1.0 * r) * t;\n    \n    gl_FragColor = vec4(finalColor, 1.0 );\n}";
        ShaderList2.RainbowDash = "/*\n * Original shader from: https://www.shadertoy.com/view/Wt2BzK\n */\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n// glslsandbox uniforms\nuniform float time;\nuniform vec2 resolution;\n\n// shadertoy emulation\n#define iTime time\n#define iResolution resolution\nconst vec4 iMouse = vec4(0.);\n\n// --------[ Original ShaderToy begins here ]---------- //\n//Autor desconocido---unknown author\n\nconst vec3 COLOR_LINE = vec3(0x77, 0xB0, 0xE0) / 255.0;\nconst vec3 COLOR_MANELINE = vec3(0x1E, 0x98, 0xD3) / 255.0;\nconst vec3 COLOR_BODY = vec3(0x9E, 0xDB, 0xF9) / 255.0;\nconst vec3 COLOR_MANE1 = vec3(0xEE, 0x41, 0x44) / 255.0;\nconst vec3 COLOR_MANE2 = vec3(0xF3, 0x70, 0x33) / 255.0;\nconst vec3 COLOR_MANE3 = vec3(0xFD, 0xF6, 0xAF) / 255.0;\nconst vec3 COLOR_MANE4 = vec3(0x62, 0xBC, 0x4D) / 255.0;\nconst vec3 COLOR_MANE5 = vec3(0x67, 0x2F, 0x89) / 255.0;\nconst vec3 COLOR_EYEBROW = vec3(0x00, 0x00, 0x00) / 255.0;\nconst vec3 COLOR_IRIS1 = vec3(0xC6, 0x00, 0x6F) / 255.0;\nconst vec3 COLOR_IRIS2 = vec3(0x46, 0x00, 0x25) / 255.0;\nconst vec3 COLOR_BLACK = vec3(0x00, 0x00, 0x00) / 255.0;\nconst vec3 COLOR_WHITE = vec3(0xFF, 0xFF, 0xFF) / 255.0;\n\nconst float eps=0.0001;\n\nbool line(vec2 p, vec2 a, vec2 b)\n{\n\treturn (p.x - a.x) * (a.y - b.y) > (p.y - a.y) * (a.x - b.x);\n}\n\nbool circle(vec2 p, vec2 a, float r)\n{\n\treturn (p.x - a.x) * (p.x - a.x) + (p.y - a.y) * (p.y - a .y) > r * r;\n    \n}\n\nbool ellipse(vec2 p, vec2 a, vec2 r)\n{\n\t//return (p.x - a.x) * (p.x - a.x) / r.x / r.x + (p.y - a.y) * (p.y - a .y) / r.y / r.y > 1.0;\n    \n    p = (p-a)/r ;\n\treturn dot(p,p) > 1.0;\n    //return smoothstep ( 1.0-eps, 1.0+eps, dot(p,p) )> 1.0;\n\t\n    \n\n}\n\n\nvec2 m;\n\nbool ear(inout vec3 c, vec2 p)\n{\t\n\tfloat off;\n\tif(mod((iTime/3.14), 5.)<4.5)\n\t\toff = 0.;\n\telse\n\t\toff = sin(iTime*15.);\n\t\n\tbool A = circle(p-off*8., vec2(638, 664), 362.);\n\tbool B = circle(p-off*8., vec2(1075, 641), 323.);\n\tbool C = circle(p-off*8., vec2(646, 708), 378.);\n\tif(!A && !B && !C)\n\t{\n\t\tbool D = circle(p-off*8., vec2(637, 662), 345.);\n\t\tbool E = circle(p-off*8., vec2(1109, 588), 363.);\n\t\tbool F = circle(p-off*8., vec2(651, 692), 269.);\n\t\tbool G = circle(p-off*8., vec2(395, 732), 516.);\n\t\tif(D || E || (!F && G))\n\t\t\tc = COLOR_LINE;\n\t\telse\n\t\t\tc = COLOR_BODY;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nbool mane(inout vec3 c, vec2 p)\n{\tfloat off = (sin(iTime*10.)+.5)*10.;\n\tbool A = circle(p+off, vec2(434, 460), 514.);\n\tbool B = circle(p+off*.95, vec2(250 , 110), 903.);\n\tbool C = circle(p+off*.90, vec2(384, 228), 668.);\n\tbool D = circle(p+off*.85, vec2(475, 505), 425.);\n\tbool E = circle(p+off*.80, vec2(513, 281), 536.);\n\tbool F = circle(p+off*.30, vec2(777, 435), 360.);\n\tbool G = circle(p+off*.20, vec2(915, 174), 554.);\n\tbool H = circle(p+off*.699, vec2(659, 444), 536.);\n\tbool I = circle(p+off*.60, vec2(-201, 601), 337.);\n\tbool J = line(p+off*.55, vec2(-253, 218), vec2(176, 590));\n\tbool K = circle(p+off*.20, vec2(-164, 1212), 882.);\n\tbool L = circle(p+off*.45, vec2(650, 764), 80.); // lol weird\n\tif(!A && !B && (C || (!D && E) || (!F && G) || (!H || (I && !J)) && !K) || !L)\n\t{\n\t\tbool M = circle(p+off, vec2(422, 434), 518.);\n\t\tbool N = circle(p+off*.9, vec2(372, 261), 647.);\n\t\tbool O = circle(p+off*.8, vec2(491, 499), 425.);\n\t\tbool P = circle(p+off*.7, vec2(395, 377), 402.);\n\t\tbool Q = circle(p+off*.6, vec2(790, 454), 352.);\n\t\tbool R = circle(p+off*.5, vec2(891, 216), 527.);\n\t\tbool S = circle(p+off*.4, vec2(680, 453), 536.);\n\t\tbool T = circle(p+off*.3, vec2(-217, 1332), 992.);\n\t\tbool U = circle(p+off*.2, vec2(-150, 586), 305.);\n\t\tbool V = line(p+off*.1, vec2(280, 404), vec2(119, 566));\n\t\tif((!M && N) || ((!O && P || !Q && !M) && R) || (!S && !M && !T) || (U && !T && V))\n\t\t{\n\t\t\tif(circle(p, vec2(491, 84)-off*.5, 764.))\n\t\t\t\tc = COLOR_MANE1;\n\t\t\telse\n\t\t\t\tif(circle(p, vec2(686, 204)-off*.2, 576.))\n\t\t\t\t\tc = COLOR_MANE2;\n\t\t\t\telse\n\t\t\t\t\tc = COLOR_MANE3;\n\t\t}\n\t\telse\n\t\t\tc = COLOR_MANELINE;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nbool mane2(inout vec3 c, vec2 p)\n{\n\tbool A = circle(p, vec2(607, 464), 306.);\n\tbool B = circle(p, vec2(777, 485), 339.);\n\tbool C = circle(p, vec2(1181, -127), 463.);\n\tbool D = circle(p, vec2(-433, 198), 1442.);\n\tbool E = line(p, vec2(554, -80), vec2(1055, -80));\n\tif((A && !B || !C) && !D && E)\n\t{\n\t\tbool F = circle(p, vec2(613, 461), 319.);\n\t\tbool G = circle(p, vec2(769, 486), 323.);\n\t\tbool H = circle(p, vec2(1195, -123), 454.);\n\t\tbool I = circle(p, vec2(288, 485), 691.);\n\t\tbool J = circle(p, vec2(122, 278), 864.);\n\t\tif((F && !G || !H) && !I && !J)\n\t\t\tc = COLOR_MANE4;\n\t\telse\n\t\t{\n\t\t\tbool K = circle(p, vec2(388, 235), 607.);\n\t\t\tbool L = circle(p, vec2(416, 87), 570.);\n\t\t\tif(K && !L)\n\t\t\t\tc = COLOR_MANE5;\n\t\t\telse\n\t\t\t\tc = COLOR_MANELINE;\n\t\t}\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nbool face(inout vec3 c, vec2 p)\n{\n\tbool A = circle(p, vec2(588, 396), 357.);\n\tbool B = line(p, vec2(325, 74), vec2(887, 122));\n\tbool C = ellipse(p, vec2(489, 237), vec2(287, 166));\n\tbool D = circle(p, vec2(209, 437), 163.);\n\tif(!A && B || !C && D)\n\t{\n\t\tbool E = ellipse(p, vec2(536, 253), vec2(315, 170));\n\t\tbool F = circle(p, vec2(500, 921), 828.);\n\t\tbool G = circle(p, vec2(220, 367), 110.);\n\t\tbool H = line(p, vec2(201, 454), vec2(658, 108));\n\t\tbool I = line(p, vec2(237, 115), vec2(363, 238));\n\t\tbool J = ellipse(p, vec2(283, 204), vec2(68, 57));\n\t\tbool K = ellipse(p*(sin(iTime/1.75)/85.+1.), vec2(253, 192), vec2(102, 70));\n\t\tbool L = circle(p, vec2(285, 228), 19.);\n\t\tbool M = circle(p, vec2(281, 236), 19.);\n\t\tif((!E && !F && G || H) && (I || !J || K) && (L || !M))\n\t\t\tc = COLOR_BODY;\n\t\telse\n\t\t\tc = COLOR_LINE;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nbool eye1(inout vec3 c, vec2 p, vec2 off)\n{\t\n\t\t\n\t// skewed ellipse please ignore\n#define SQR(q) ((q) * (q))\n\tbool A = SQR((p.x - 590.0) / 150.0 - (p.y - 378.0) / 900.0) + SQR((p.y - 378.0) / 180.0) < 1.0;\n\tif(A)\n\t{\n\t\tbool B = SQR((p.x - 593.0) / 149.0 - (p.y - 382.0) / 900.0) + SQR((p.y - 361.0) / 180.0) < 1.0;\n\t\tif(B)\n\t\t{\n\t\t\tvec2 d = vec2(0.0, 0.0) - vec2(580, 360);\n\t\t\tif(length(d) > 60.0)\n\t\t\t   d = d / length(d) * 60.0;\n\t\t\tbool C = ellipse(p-off*50., vec2(580, 360) + d, vec2(112, 162));\n\t\t\tif(C)\n\t\t\t\tc = COLOR_WHITE;\n\t\t\telse\n\t\t\t{\n\t\t\t\tbool D = ellipse(p-off*55., vec2(551, 305) + d, vec2(19, 26));\n\t\t\t\tbool E = ellipse(p-off*55., vec2(601, 410) + d, vec2(35, 57));\n\t\t\t\tif(D && E)\n\t\t\t\t{\n\t\t\t\t\tbool F = ellipse(p-off*50., vec2(580, 360) + d * 1.3, vec2(71, 126));\n\t\t\t\t\tif(F)\n\t\t\t\t\t\tc = mix(COLOR_IRIS1, COLOR_IRIS2, SQR((p.y - 360.0 - d.y) / 252.0 + 0.5));\n\t\t\t\t\telse\n\t\t\t\t\t\tc = COLOR_BLACK;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tc = COLOR_WHITE;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tc = COLOR_EYEBROW;\n\t\treturn true;\n\t}\n\t// rotating ellipses hacks, nothing to see here\n\tbool G = ellipse(p, vec2(757, 430), vec2(40, 5));\n\tbool H = ellipse(vec2(p.x + p.y * 0.3, p.x * -0.3 + p.y), vec2(890, 260), vec2(40, 6));\n\tbool I = ellipse(vec2(p.x + p.y * 0.5, p.x * -0.5 + p.y), vec2(990, 175), vec2(40, 7));\n\tif(!G || !H || !I)\n\t{\n\t\tc = COLOR_BLACK;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nbool eye2(inout vec3 c, vec2 p, vec2 off)\n{\n\tbool A = line(p, vec2(207, 460), vec2(323, 265));\n\tbool B = circle(p, vec2(213, 434), 158.);\n\tbool C = circle(p, vec2(739, 417), 500.);\n\tbool D = ellipse(p, vec2(289, 444), vec2(50, 144));\n\tif(!A && !B && !C || !D)\n\t{\n\t\tbool E = ellipse(p, vec2(285, 390), vec2(47, 184));\n\t\tif(!E)\n\t\t{\n\t\t\tvec2 d = vec2(0.0, 0.0) - vec2(290, 360);\n\t\t\tif(length(d) > 60.0)\n\t\t\t   d = d / length(d) * 60.0;\n\t\t\td *= vec2(0.33, 1.0);\n\t\t\tbool F = ellipse(p-off*50., vec2(290, 360) + d, vec2(50, 162));\n\t\t\tif(F)\n\t\t\t\tc = COLOR_WHITE;\n\t\t\telse\n\t\t\t{\n\t\t\t\tbool D = ellipse(p-off*55., vec2(304, 446) + d, vec2(17, 41));\n\t\t\t\tbool E = ellipse(p-off*55., vec2(278, 354) + d, vec2(11, 24));\n\t\t\t\tif(D && E)\n\t\t\t\t{\n\t\t\t\t\tbool F = ellipse(p-off*50., vec2(290, 360) + d * 1.3, vec2(42, 126));\n\t\t\t\t\tif(F)\n\t\t\t\t\t\tc = mix(COLOR_IRIS1, COLOR_IRIS2, SQR((p.y - 360.0 - d.y) / 252.0 + 0.5));\n\t\t\t\t\telse\n\t\t\t\t\t\tc = COLOR_BLACK;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tc = COLOR_WHITE;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tc = COLOR_EYEBROW;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nbool neck(inout vec3 c, vec2 p)\n{\n\tbool A = circle(p, vec2(1247, -28), 638.);\n\tbool B = circle(p, vec2(353, 258), 638.);\n\tbool C = line(p, vec2(554, -80), vec2(1055, -80));\n\tif(!A && !B && C)\n\t{\n\t\tbool D = circle(p, vec2(1235, -21), 606.);\n\t\tif(D)\n\t\t\tc = COLOR_LINE;\n\t\telse\n\t\t\tc = COLOR_BODY;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nvec2 transform(vec2 x)\n{\n\treturn (x - iResolution.xy / 2.0) / iResolution.y * 1000.0 + 500.0;\n}\n\nfloat sinslope(float t)\n{\n\treturn sin(t) - sin(t - 0.01);\t\n}\n\nvoid  mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat off = sin(iTime/1.75);\n\tif(off < 0.)\n\t\toff=0.;\n\telse if(off > .8)\n\t\toff=.8;\n\t\n\tm = transform(iMouse.xy * iResolution.xy);\n\tvec2 p = transform(fragCoord.xy);\n\tp.x += sin(iTime) * 200.0;\n\tp.y += abs(sin(iTime*7.0))*10.0 * (abs(sinslope(iTime)) * 200.0);\n\tvec3 c = vec3(1, 1, 1);\n\tear(c, p) || mane(c, p) || mane2(c, p) || eye1(c, p, vec2(off*1.6,off*.5)) || eye2(c, p, vec2(off*.4,off*.5))  || face(c, p) || neck(c, p);\n\tfragColor = vec4(c, 1);\n}\n\n\n// --------[ Original ShaderToy ends here ]---------- //\n\nvoid main(void)\n{\n    mainImage(gl_FragColor, gl_FragCoord.xy);\n}";
        ShaderList2.Corona = "/*\n * Original shader from: https://www.shadertoy.com/view/tsfyz4\n */\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n// glslsandbox uniforms\nuniform float time;\nuniform vec2 resolution;\n\n// shadertoy emulation\n#define iTime time\n#define iResolution resolution\n\n// --------[ Original ShaderToy begins here ]---------- //\n\nfloat PI = 3.1415;\nfloat PHI = 1.61803398874989;\nconst int steps = 16;\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n// this function from https://www.shadertoy.com/view/wtSSWh\nfloat n(vec2 u){\n    vec4 d=vec4(.106,5.574,7.728,3.994),q=u.xyxy,p=floor(q);\n    ++p.zw;\n    q-=p;\n    p=fract(p*d.xyxy);\n    d=p+d.wzwz;\n\td=p.xxzz*d.ywyw+p.ywyw*d.xxzz;\n    p=fract((p.xxzz+d)*(p.ywyw+d));\n    p=cos(p*=iTime+d)*q.xxzz+sin(p)*q.ywyw;\n    q*=q*(3.-2.*q);\n    p=mix(p,p.zwzw,q.x);\n    return mix(p.x,p.y,q.y);\n}\n\n// these three functions are from http://mercury.sexy/\n\n// The \"Round\" variant uses a quarter-circle to join the two objects smoothly:\nfloat fOpUnionRound(float a, float b, float r) {\n    vec2 u = max(vec2(r - a,r - b), vec2(0));\n    return max(r, min (a, b)) - length(u);\n}\n\nfloat fOpIntersectionRound(float a, float b, float r) {\n    vec2 u = max(vec2(r + a,r + b), vec2(0));\n    return min(-r, max (a, b)) + length(u);\n}\n\nfloat fOpDifferenceRound (float a, float b, float r) {\n    return fOpIntersectionRound(a, -b, r);\n}\n\n\nfloat virusHead (float p){\n    \n    return cos(p);//+ noise(abs(p));\n}\n\nfloat modBlob(inout vec3  p){\n        float sz = 0.;\n    if (p.x < max(p.y, p.z)){ \n        p = p.yzx;\n        //sz+=.007;\n    }\n    if (p.x < max(p.y, p.z)){ \n       // sz-=0.05;\n        p = p.yzx;}\n\n    return sz;\n    \n}\n\nfloat bFunct(vec3 p, vec3 savedP){ // this function places nubs around sphere\n   return  max(max(max(\n        dot(p, normalize(vec3(1., 1, 1))),\n        dot(p.xz, normalize(vec2(PHI+1., 1.)))),\n        dot(p.yx, normalize(vec2(1., PHI )))),\n        dot(p.xz, normalize(vec2(1., PHI ))));\n    \n}\n\nfloat bloby(vec3 p) {\n    p = abs(p);\n    vec3 savedP = p;\n    float sz = 1.3;\n    sz += modBlob(p);\n    float b = bFunct(p,savedP);\n    float l = length(p);\n    \n    float nub =(1.01 - b / l)*(PI / .04) - n(savedP.xy*20.);\n        \n    float sploops = l - sz - 0.09 * cos(min(nub, (PI)));\n    \n    return fOpDifferenceRound (sploops,l-1.38, 0.15); // just ge tthe nubs\n}\n\n\nfloat virus(vec3 p) {\n    vec3 savedP = p;\n    p = abs(p);\nfloat sz = 1.2;\n sz += modBlob(p);\n    float b = bFunct(p,savedP);\n        \n    float l = length(p);\n    return l - sz - 0.3 * (3. / 2.)* cos(min(sqrt(1.01 - b / l)*(PI / 0.15), PI )) +( n(savedP.xy*20.) *0.01)+  n(savedP.zy*17.) *0.03;\n}\n//from http://mercury.sexy/\nvoid pR(inout vec2 p, float a) {\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nvec2 scene(vec3 ray ){\n    float time = iTime;\n    float floor = (ray.y + 1.2) - \n        cos(ray.x * 10.)* 0.2 - sin(ray.y* 10.);\n    float radius = 0.5;\n    \n    \n   // ray = mod(ray, modSpace) - 0.5*modSpace;\n    \n    ray = ray - vec3(0.,0.,2.0);\n    vec3 ray2 = ray;\n    vec3 ray3 = ray;\n        \n    pR(ray2.yz,time/3. + n((vec2(time/3. ) / 2.)) * 0.2);\n    pR(ray3.yz,time/3.);\n    \n    vec3 ray4 = mix(ray2,ray3,(sin(time)/5.) + 1.);\n    \n    pR(ray4.xz, n(vec2(time/4.) ) );\n    \n    pR(ray4.xy, 0.2*n(vec2(time) ) ); \n    float blob = bloby(ray4);\n    float virus = virus(ray4);\n\t\n    float ret = smin(blob,virus,.8  + (0.08* sin(time))) ;\n    \n    return vec2( ret,length(ray4)-0.5) ;//smin(smin(blob, sphere,0.6), sphere2,0.6) ;\n}\n\n\nvec3 estimateNormal(vec3 p) {\n    float smallNumber = 0.002;\n    vec3 n = vec3(\n    scene(vec3(p.x + smallNumber, p.yz)).x -\n    scene(vec3(p.x - smallNumber, p.yz)).x,\n    scene(vec3(p.x, p.y + smallNumber, p.z)).x -\n    scene(vec3(p.x, p.y - smallNumber, p.z)).x,\n    scene(vec3(p.xy, p.z + smallNumber)).x -\n    scene(vec3(p.xy, p.z - smallNumber)).x );\n\n\treturn normalize(n);\n}\n\nfloat lighting(vec3 origin, vec3 dir, vec3 normal) {\n    vec3 lightPos = vec3(12,12,1);//vec3(cos(time) +12., sin(time), 12.);\n    vec3 light = normalize(lightPos - origin);\n\n    float diffuse = max(0., dot(light, normal));\n    vec3 reflectedRay = 1.0 * dot(light, normal) * normal - light;\n\n    float specular = max(0., (pow(dot(reflectedRay, light),5.))) * sin(iTime* 3.)* 0.3;\n\n    float ambient = 0.03;\n\n    return ambient + diffuse + specular;\n\n}\n\n\nvec4 trace(vec3 rayOrigin, vec3 dir){\n    vec3 ray = rayOrigin;\n    float dist = 0.;\n        \n    float totalDist = 0.;\n    float maxDist = 3.;\n    vec2 holder;\n    float redCol;\n    \n    for (int i = 0; i < steps ; i++){\n        holder = scene(ray);\n        dist = holder.x;\n        redCol = holder.y;\n        \n        if(dist < 00.04){\n            vec4 distCol = vec4(1. - vec4(totalDist/maxDist));\n            vec4 lightingCol = vec4(lighting(rayOrigin,dir,estimateNormal(ray)));\n            vec4 col = lightingCol + vec4(pow(redCol,4.),0,0,0);//+ vec4(length(vec3(pow(length(ray),1.)))*0.3,0,0,0);//mix(lightingCol , vec4(distCol),distCol.x);\n           \n            return col;\n        } \n        totalDist += dist;\n        ray += dist * dir;\n        if (totalDist > maxDist){\n            break;\n            \n        }\n    } \n \n\n    return vec4(n(rayOrigin.xy*2.0) * (1.6-length(rayOrigin.xy)));\n}\nvec3 lookAt(vec2 uv, vec3 camOrigin, vec3 camTarget){\n\tvec3 zAxis = normalize(camTarget - camOrigin);\n\tvec3 up = vec3(0,1,0);\n\tvec3 xAxis = normalize(cross(up, zAxis));\n\tvec3 yAxis = normalize(cross(zAxis, xAxis));\n\n\tfloat fov = 2.;\n\n\tvec3 dir = (normalize(uv.x * xAxis + uv.y * yAxis + zAxis * fov));\n\n\treturn dir;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime;\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tuv = (uv *2.)-1.;\n\n    uv.x *= iResolution.x/iResolution.y;\n    vec3 rayOrigin = vec3(uv.x + n(vec2(time))*0.05,uv.y + n(vec2(time/3.))*0.03, 0.); // TODO make it so that the bg moves more than the foreground so it looks like the fbm is far away\n    vec3 camOrigin = vec3(0, 0., -1.);\n\n    vec3 camTarget = camOrigin+ vec3(sin(time/10.),cos(time/10.), 2);\n\n    vec3 direction = lookAt(uv, camOrigin, camTarget);\n\n\n    fragColor = (trace(rayOrigin, direction));\n}\n// --------[ Original ShaderToy ends here ]---------- //\n\nvoid main(void)\n{\n    mainImage(gl_FragColor, gl_FragCoord.xy);\n}";
        ShaderList2.Lichttunnel = "/*\n * Original shader from: https://www.shadertoy.com/view/tlsGz2\n */\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n// glslsandbox uniforms\nuniform float time;\nuniform vec2 resolution;\n\n// shadertoy emulation\n#define iTime time\n#define iResolution resolution\n\n// --------[ Original ShaderToy begins here ]---------- //\nfloat tr = 50.0;\n#define P(t,tt) vec3(cos(ti+t) * tr, sin(ti) * 0.1, sin(ti+tt) * tr);\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    float ti = iTime * 2.;\n    vec3 ro = P(0.,0.);\n    vec3 ta = P(sin(ti), cos(ti));\n    vec3 fo = normalize(ta-ro);\n    vec3 ri = normalize(cross(vec3(cos(ti*0.5),sin(ti*0.5),0.), fo));\n    vec3 up = normalize(cross(fo,ri));\n    vec3 ray = mat3(ri,up,fo) * normalize(vec3(p, 1.5));\n    \n    float t = 0.0;\n    vec3 col = vec3(0.);\n    float a = 1.0;\n    for(int i=0;i<300;i++) {\n        vec3 pos = ro + ray * t;\n    \tfloat d = -length(vec2(length(pos.xz) - tr, pos.y)) + 5.0;\n        if (d < 0.001) {\n    \t\tvec2 uv = vec2(atan(pos.z, pos.x), atan(pos.y, length(pos.xz) - tr)) / (acos(-1.)*2.) + 0.5;\n            float c = smoothstep(0.05, 0.00, abs(fract(uv.y * 5.0) - 0.5));\n            c = mix(c, 1.0, smoothstep(0.1, 0.00, abs(fract(uv.x * 10.0) - 0.5)));\n            col += mix(vec3(c), mix(vec3(7., 4., 2.), vec3(2., 4., 7.), sin(ti) * 0.5 + 0.5), 1.0-exp(-t * 0.005)) * a;\n            a *= 0.25;\n            t = 0.002;\n            ro = pos;\n            ray = reflect(ray, normalize((normalize(vec3(pos.x, 0., pos.z)) * tr) - pos));\n        }\n        t += d;\n    }\n    fragColor = vec4(col,1.0);\n}\n// --------[ Original ShaderToy ends here ]---------- //\n\nvoid main(void)\n{\n    mainImage(gl_FragColor, gl_FragCoord.xy);\n}";
        ShaderList2.Mars = "/*\n * Original shader from: https://www.shadertoy.com/view/WsXGR7\n */\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n// glslsandbox uniforms\nuniform float time;\nuniform vec2 resolution;\nuniform vec2 mouse;\n\n// shadertoy emulation\n#define iTime time\n#define iResolution resolution\nvec4 iMouse = vec4(0.);\n\n// --------[ Original ShaderToy begins here ]---------- //\n/*\nhttp://www.iquilezles.org/www/articles/terrainmarching/terrainmarching.htm\nhttp://www.iquilezles.org/www/articles/morenoise/morenoise.htm\n*/\n\nconst vec3 PURPLE = vec3(1.0, 0.9, 1.0);//vec3(141.0, 0.0, 196.0)/255.0;\nconst vec3 PINK = vec3(0.5, 0.4, 0.4);//vec3(255.0,192.0,203.0)/255.0;\nconst vec3 WHITE = vec3(1.0);\nconst vec3 BLACK = vec3(0.0);\nconst vec3 SKY = vec3(0.0);\nconst vec3 MOON = vec3(1.0, 0.6, 0.0);\nconst vec3 BLUE = vec3(0.1,0.2,0.3);\nconst vec3 GREEN = vec3(0.1,0.2,0.3);\nconst vec3 EARTH = vec3(0.1);\nconst float PI = 3.1415926;\nconst float EPSILON = 0.0001;\nconst float SCALE = 0.01;\nconst float HEIGHT = 12.0;\nconst float MAX_DISTANCE = 400.0;\nconst int MAX_STEP = 40;\nconst int ITERATION = 8;\nconst float LUCUNARITY = 1.2;\n#define AA 1\n\nvec3 moonDir = normalize(vec3(7.0, 1.0, -5.0));\n\nfloat hash1(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * 0.013);\n    p3 += dot(p3, p3.yzx + 19.31);\n    return -1.0 + 2.0 * fract((p3.x + p3.y) * p3.z);\n}\n\nfloat noise(in vec2 x) {\n    vec2 p = floor(x);\n    vec2 w = fract(x);\n    \n    vec2 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    \n    float a = hash1(p+vec2(0,0));\n    float b = hash1(p+vec2(1,0));\n    float c = hash1(p+vec2(0,1));\n    float d = hash1(p+vec2(1,1));\n\n    float k0 = a;\n    float k1 = b - a;\n    float k2 = c - a;\n    float k4 = a - b - c + d;\n\n    return k0 + k1*u.x + k2*u.y + k4*u.x*u.y;\n}\n\nvec3 noised( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 w = fract(x);\n    \n    vec2 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    vec2 du = 30.0*w*w*(w*(w-2.0)+1.0);\n    \n    float a = hash1(p+vec2(0,0));\n    float b = hash1(p+vec2(1,0));\n    float c = hash1(p+vec2(0,1));\n    float d = hash1(p+vec2(1,1));\n\n    float k0 = a;\n    float k1 = b - a;\n    float k2 = c - a;\n    float k4 = a - b - c + d;\n\n    return vec3( -1.0 + 2.0 * (k0 + k1*u.x + k2*u.y + k4*u.x*u.y), \n                      2.0* du * vec2( k1 + k4*u.y,\n                                      k2 + k4*u.x ) );\n}\n\nconst mat2 m2 = mat2(1.2,  0.8, -0.8,  1.2);\nfloat fbm4(vec2 p) {\n    float amp = 1.0;\n    float h = 0.0;\n    for (int i = 0; i < ITERATION; i++) {\n        float n = noise(p);\n        h += amp * n;\n        amp *= 0.5;\n        p = m2 * p ;\n    }\n\treturn  h;\n}\n\n\nconst mat2 m = mat2(1.2, -0.6, 0.6, 1.2);\nvec4 fbmd4(vec2 v) {\n    \n    float amp = 1.0;\n    float f = 1.0 ;\n    float h = 0.0;\n    vec2 d = vec2(0.0);\n    for (int i = 0; i < ITERATION; i++) {\n        vec3 n = 1.0 - abs(noised(v * SCALE * f)); //noised(v * SCALE * f)\n        h += amp * n.x;\n        d += amp * n.yz * f;\n        amp *= 0.5;\n        f *= LUCUNARITY;\n        v = m * v;\n    }\n    h *= HEIGHT  ;\n\td *= HEIGHT * SCALE;\n\treturn vec4( h, normalize( vec3(-d.x,1.0,-d.y) ) );\n}\n\nvec4 terrainMap(vec3 v) {\n    vec4 terrain = fbmd4(v.xz - vec2(100.0, 0.0));\n    terrain.x += .02*noise(v.xz*0.8);\n    return terrain;\n}\n\n    \nvec4 sceneMap(vec3 v) {\n    return terrainMap(v);\n}\n\nvec3 getNormal(vec3 p )\n{\n    vec2 OFFSET = vec2(EPSILON, 0.0);\n    return normalize( vec3( sceneMap(p-OFFSET.xyy).x-sceneMap(p+OFFSET.xyy).x,\n                            1.0*EPSILON,\n                            sceneMap(p-OFFSET.yyx).x-sceneMap(p+OFFSET.yyx).x ) );\n}\nvec3 moon(vec3 ro, vec3 rd) {\n    float n1 = 0.3*noise(rd.xy * 20.0 - iTime);\n    float n2 = 0.3*noise(rd.xy * 10.0 - iTime);\n    float sdot = dot(rd, moonDir)*10.0;\n    float m1 = smoothstep(9.4, 9.75, sdot);\n    float col1 = pow(m1, 128.0);\n    float m2 = smoothstep(9.0+n1, 9.75, sdot);\n    float col2 = pow(m2, 64.0);\n    float m3 = smoothstep(8.2+n2, 9.7, sdot);\n    float col3 = pow(m3, 32.0);\n    float hole1 = (col2 -col1);\n    float hole2 = (col3 -col1);\n    vec3 rst = hole1*MOON*8.0 + hole2*BLUE*2.0;\n    return rst;\n}\n\n\nvec3 stars(vec2 p) {\n    float t = iTime * 0.1;\n    float n1 = hash1(p*0.1) ;\n    n1 *= pow(n1*n1, 680.0) ;\n    n1 *= sin(t*5.0 + p.x + sin(t*2.0 + p.y));\n    n1 = clamp(n1, 0.0, 1.0);\n    return n1 * vec3(1.0);\n}\n\nvec3 sky(vec3 ro, vec3 rd) {\n    vec3 col = vec3(0.0);\n    vec3 v = ro + rd*MAX_DISTANCE;\n    float n1 = noise(v.xy * 0.001);\n    float n2 = noise(v.yx * 0.001);\n    vec3 skyCol = GREEN * 0.01;\n    col += mix(skyCol, GREEN, exp(-16.0*v.y/MAX_DISTANCE));\n    col += stars(v.xy);\n    col += moon(ro, rd);\n    return col;\n}\n\nvec4 castRay(vec3 ro, vec3 rd) {\n    vec4 re = vec4(-1.0);\n    float t = 0.0;\n    for( int i=0; i<MAX_STEP; i++ ){\n        vec3 p = ro + rd * t;\n        vec4 n = sceneMap(p);\n        float h = p.y - n.x;\n    \tre = vec4(t, n.yzw);\n        t += h*n.z; \n        if ((abs(h) < EPSILON) || t > MAX_DISTANCE) {\n            break;\n        } \n    }\n    \n    if (t > MAX_DISTANCE) {\n        re = vec4(-1.0);\n    }\n    return re;\n}\n\nvec3 getShading(vec3 ro, vec3 rd, vec3 p, vec3 normal, vec3 color) {\n    vec3 col = vec3(0.0);\n    vec3 lightDir = moonDir;\n    float moonAmount = max(dot(rd, lightDir), 0.0);\n    vec3 lightCol = mix( GREEN, MOON, pow(moonAmount, 2.0));\n    \n    vec3 viewDir = normalize(ro - p); \n    vec3 refDir = reflect(-lightDir, normal);\n    \n    vec3 ambCol = lightCol * 0.1;\n    float diff = max(dot(lightDir, normal), 0.0);\n    vec3 diffCol = lightCol * diff;\n    \n    float spec = pow(max(dot(refDir, viewDir), 0.0), 8.0);\n    vec3 speCol = lightCol * spec * 0.7;\n    \n    \n    \n    col = (speCol + diffCol) * color ;\n    return col;\n}\n\nvec3 getMaterial(vec3 ro, vec3 rd, vec3 p, vec3 normal) {\n    //vec3 col = texture(iChannel1, p.xz * 0.0051, - 100.0).xyz * 0.5;\n    vec3 col = vec3(0.3, 0.1, 0.1);\n    vec3 lightDir = moonDir;\n    //a bit of sprinkling\n    if (hash1(p.xz) > 0.995) {\n    \tcol += clamp(sin(iTime + p.x*p.z), 0.5, 1.0) * vec3(1.2);\n  \t}\n    \n    return col;\n}\n\nvec3 terrainColor(vec3 ro, vec3 rd, vec3 p, vec3 nor) {\n    vec3 col = vec3(0.0);\n    col = getMaterial(ro, rd, p, nor);\n    col = getShading(ro, rd, p, nor, col) ;\n    \n    return col;\n}\n\nvec3 fog(vec3 ro, vec3 rd, vec3 p, vec3 pixCol, float dis)\n{\n    vec3 lightDir = moonDir;\n    //base color and moonlight\n    vec3 fogCol = vec3(0.0);\n    float b  = 0.000005;\n    float fogAmount = 1.0 - exp( -dis*dis*b );\n    \n    float moonAmount = max(dot(rd, lightDir), 0.0);\n    vec3 mixFog = mix(GREEN, MOON*0.5, pow(moonAmount, 16.0));\n\tfogCol = mix( pixCol, mixFog, fogAmount );\n   \n    //adding density\n    float c = 0.001;\n    float b1 = 0.15;\n    float t = iTime ;\n    float v = 1.0;\n    vec3  denCol  = GREEN; \n    float density =  c * exp(-ro.y*b1) * (1.0 - exp(-dis*rd.y*b1 ))/(rd.y);\n    \n    float turb = fbm4(vec2(p.x*0.02+t*v, p.z*0.02+t*v));\n    density += 0.05*turb;\n    fogCol += mix( pixCol, denCol, density);\n    return fogCol;\n}\n\nmat3 getCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvec3 render( in vec2 fragCoord)\n{\n    vec2 uv = -1.0 + 2.0 * fragCoord.xy/iResolution.xy ;\n    //uv -= 0.5; // translate to the center of the screen\n    uv.x *= iResolution.x / iResolution.y; // restore aspect ratio\n    vec2 mouse = iMouse.xy/iResolution.xy;\n    mouse -= 0.5;\n    //define camera\n    vec3 ro = vec3 (cos(mouse.x * 6.28) * 10.0, 0.0, sin(mouse.x * 6.28) * 10.0);\n    vec3 ta = vec3 (0.0, 1.0, -2.0);\n    mat3 cam = getCamera(ro, ta, 0.0);\n\n    vec3 rd = normalize(cam * vec3(uv, 1.0));\n    \n    //draw scene\n   \tvec3 color = vec3(0.0);\n    vec4 hnor = castRay(ro, rd);\n    vec3 p = ro + rd * hnor.x;\n    \n    if (hnor.x > EPSILON) {\n        //vec3 nor = hnor.yzw + 0.01*hash1(p.xz * 5.0);\n        vec3 nor= getNormal(p) ;\n        color += terrainColor(ro, rd, p, nor);  \n        color = fog(ro, rd, p, color, hnor.x);\n    } else {\n        color += sky(ro, rd);\n    }\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 pixCol = vec3(0.0);\n    vec2 offset = vec2(0.0);\n    \n#if AA>1\n    for (float y = 0.0; y < float(AA); ++y)\n    {\n        for (float x = 0.0; x < float(AA); ++x)\n        {\n            offset = -0.5 + vec2(x, y) / float(AA);\n\n        \tpixCol += render(fragCoord+offset);\n        }\n    }\n    pixCol /= float(AA*AA);\n#else\n    pixCol += render(fragCoord);\n#endif\n        \n    pixCol = pow( pixCol, vec3(1.0/2.2) );\n    \n    // Output to screen\n    fragColor = vec4(pixCol, 1.0);\n\t\n}\n// --------[ Original ShaderToy ends here ]---------- //\n\nvoid main(void)\n{\n    iMouse = vec4(mouse * resolution, 0., 0.);\n    mainImage(gl_FragColor, gl_FragCoord.xy);\n}";
        ShaderList2.Insel = "/*\n * Original shader from: https://www.shadertoy.com/view/WsGGWd\n */\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n// glslsandbox uniforms\nuniform float time;\nuniform vec2 resolution;\n\n// shadertoy emulation\n#define iTime time\n#define iResolution resolution\n\n// --------[ Original ShaderToy begins here ]---------- //\n/////////////////////////////////////////////////////////////\n/////      ........ Johnny Castaway ..........     ////////// \n/////      .... My favorite screensaver ......     ////////// \n/////////////////////////////////////////////////////////////\n// Brasil/Amazonas/Manaus            \n// Anyone Remember?  \n// Created by Rodrigo Cal (twitter: @rmmcal) - 2019/10\n// - https://www.shadertoy.com/view/WsGGWd\n/////////////////////////////////////////////////////////////\n// -----------------------------------------------------------\n// The past is alive for time travelers....\n//\n//      - Reflection of the day... @rmmcal 2019/10\n//\n// Inspiration:\n//  => https://en.wikipedia.org/wiki/Johnny_Castaway\n//  => Johnny Castaway Screensaver\n//// -----------------------------------------------------------\n/////////////////////////////////////////////////////////////\n\nvec2 uv ;\n\n/////////////////////////////////////////////////////////////\n//  => https://www.shadertoy.com/view/tsKGDc @onak\nvec2 hash22(vec2 p) {\n    p = p*mat2(127.1,311.7,269.5,183.3);\n\tp = -1.0 + 2.0 * fract(sin(p)*43758.5453123);\n\treturn sin(p*6.283);\n}\nfloat perlin_noise(vec2 p) {\n\tvec2 pi = floor(p);\n    vec2 pf = p - pi;\n    \n    // interpolation\n    vec2 w = pf * pf * (3.0 - 2.0 * pf);\n    \n    float f00 = dot(hash22(pi + vec2(0.0, 0.0)), pf - vec2(0.0, 0.0));\n    float f01 = dot(hash22(pi + vec2(0.0, 1.0)), pf - vec2(0.0, 1.0));\n    float f10 = dot(hash22(pi + vec2(1.0, 0.0)), pf - vec2(1.0, 0.0));\n    float f11 = dot(hash22(pi + vec2(1.0, 1.0)), pf - vec2(1.0, 1.0));\n    \n    // mixing top & bottom edges\n    float xm1 = mix(f00, f10, w.x);\n    float xm2 = mix(f01, f11, w.x);\n    \n    // mixing to point\n    float ym = mix(xm1, xm2, w.y); \n    \n    return ym;\n}\nfloat perlin_noise1(vec2 p) {\n    vec2 count ;\n    for (float i = 0.; i < 9.; i++){\n        count += hash22 ( floor(p*10.)/10. +vec2(mod(i,3.)-1., i/3.-1.) );\n    }\n    count /= 9.;\n    return count.x;\n}\nfloat noise_fBM(float size, int octaves, float persistence, float scale, vec2 coord) {\n    float c = 0.0;\n    float p = 1.0;\n    float n = 0.0;\n    for (int i = 1; i < 10; i++) {\n        if (i > octaves) break;\n        c += perlin_noise(coord * size) * p;\n        n    += p;\n        size *= scale;\n        p    *= persistence;\n    }\n    c /= n;\n    return c;\n}\n/////////////////////////////////////////////////////////////\n/////////////////////////////////////////////////////////////\n\nfloat clouds(vec2 p) {\n    float c = 2.5 * noise_fBM(2.0, 6, 0.5, 2.0, p*vec2(1.,2.1/(pow(p.y,2.))) + vec2(iTime * ( 0.01), 0.0));\n \treturn c;\n}\n\nfloat water(vec2 p) {\n    float c = 4.5 * noise_fBM(2.0, 6, 0.5, 2.0, p*vec2(1.,4.) )*.4+ +1.-p.y*3.2;\n \treturn c;\n}\n\nfloat bit(float b){\n    return floor(b*2.+.4)/2.;\n}\n\nvec3 bit(vec3 b){\n    return floor(b*2.+.4)/2.;\n}\n\nfloat stepin(float a, float b, float x){\n    return a < x && x < b ? 1. : 0.;\n}\n\nvoid wood(inout vec3 canvas, vec2 p)\n{\n    float cf = (abs(mod(p.y+cos(p.x*10.),.03)*20.-1.));\n    cf = (cf*=cf)*(cf*=cf);\n    cf = bit(1.-cf*.5);\n    p -=  vec2(-0.12,+0.04);\n    canvas = mix(canvas, bit(vec3(p.x*2.))+(vec3(.4,.1,0.))*cf, (stepin(0.5,2., -atan(-p.x,p.y))) * step( 0.002, (.01-p.y)*.15+.08-abs(length((p-vec2(0.,0.))*vec2(4.,1.0))-.5)  ));\n}\n\nmat2 rotate(float a)\n{\n\treturn mat2(cos(a), sin(a), -sin(a), cos(a));\n}\n\nvoid foliage(inout vec3 canvas, vec2 p)\n{\n\tp*= 2.0;\n    p -=  vec2(-0.0,-0.18);\n    vec3 c1 = vec3(.0,.9,0.0);\n    vec3 c2 = vec3(.23,.56,0.23);\n    vec3 c = p.x>0.0?c1:c2;\n    float cf = abs(mod(p.y,.1)*20.-1.);\n    p.x *= 1.+pow(cf,8.);\n    float f = .2-length(p*vec2(8.*(0.5-p.y),1.));\n    canvas = mix(canvas, c,  step( 0.002, f));\n    canvas = mix(canvas, vec3(1.),  step( 0.002, min(f, .004-abs(p.x))));\n}\n\nvoid coconutTree(inout vec3 canvas, vec2 p)\n{\n    for (int i = 0; i < 5; i++)\n\t\tfoliage(canvas, rotate(float(5-i)*.56-1.75)*(p-vec2(.0,0.25))+vec2(0.,abs(p.y*.1)));\n    wood(canvas, p-vec2(.0,-.07));\n}\n\nvoid johnny(inout vec3 canvas, vec2 p)\n{\n    p *= vec2(.5,1.);\n    p *= vec2(1.5);\n    \n\tp *= vec2(2.- clamp(iTime*.2-.1,0.,1.));\n    p += vec2(0.7,-.4)* vec2(1.- clamp(iTime*.2-.1,0.,1.));\n\n    float t = abs(fract(iTime*.1)*2.-1.);\n    float t2 = abs(fract(iTime*.7)*2.-1.);\n\tfloat y = cos(t*5.);\n    p -=  vec2(t*.2-.1,-0.05);\n    p *= 2.;\n    float f;\n    \n    //head\n    vec3 skin = vec3(1.0,0.7,0.5);\n    float f0 = .06-length(p*vec2(2.,1.1)-vec2(0.,.05));\n    canvas = mix(canvas, skin,  step( 0.002, f0));\n\n    // beard\n    float f1 = .05-length(p*vec2(8.*(0.2-p.y),1.));\n    canvas = mix(canvas, vec3(0.),  step( 0.002, f1));\n\n    //hair\n    f = .05-length(p*vec2(8.*(0.3-p.y),1.)+vec2(0.,-.04));\n    f =  .01-abs(f);\n    f =  -max(-f,f1);\n    canvas = mix(canvas, vec3(0.0),  step( 0.002, f));\n\n    // mouth\n    f = .02-length(p*vec2(1.,4.1));\n    canvas = mix(canvas, skin+.1,  step( 0.002, f));\n\n    // nose\n    f = .03-length(p*vec2(2.,2.1)+vec2(0.,-.06));\n    canvas = mix(canvas, skin+.1,  step( 0.002, f));\n\n    // hat\n    f =        .03-length(p*vec2(1.0,2.1)+vec2(0.,-.22));\n    f = max(f, .03-length(p*vec2(1.5,2.1)+vec2(0.,-.25)));\n    canvas = mix(canvas, vec3(1.),  step( 0.002, f));\n\n    // eye white\n    f = .01-length(p*vec2(1.,2.1)+vec2((p.x>0.)?-0.01:0.01,-.13));\n    canvas = mix(canvas, vec3(1.),  step( 0.002, f));\n\n    // eye black\n    f = .007-length(p*vec2(1.,1.1)+vec2((p.x>0.)?-0.01:0.01,-.07));\n    canvas = mix(canvas, vec3(0.),  step( 0.002, f));\n\n    ////////////////\n    p *= vec2(1.5);\n\t\n    float side = (p.x>0.)?-1.:1.;\n    //arms\n    f = .07-length(rotate((t2-0.5+side)*.1)*p*vec2(3.,-0.9)+vec2( side*0.1,-.13));\n    canvas = mix(canvas, skin,  step( 0.002, f));\n\tcanvas = mix(canvas, vec3(0.),  step( 0.002, 0.008-abs(f)));\n  \t\n \t//legs\n    f = .07-length(rotate((t2-0.5+side)*.03)*p*vec2(3.,-0.9)+vec2((p.x>0.)?-0.05:0.05,-.26));\n    canvas = mix(canvas, skin,  step( 0.002, f));\n    canvas = mix(canvas, vec3(0.),  step( 0.002, 0.008-abs(f)));\n\n    // body\n    f = .07-length(p*vec2(3.,-0.9)+vec2((p.x>0.)?-0.01:0.01,-.13+0.02));\n    canvas = mix(canvas, skin,  step( 0.002, f));\n \tcanvas = mix(canvas, vec3(0.),  step( 0.002, 0.008-abs(f)));\n  \n    // pants\n    f = .07-length((p)*vec2(3.,-1.7)+vec2((p.x>0.)?-0.01:0.01,-.35));\n    canvas = mix(canvas, vec3(1.),  step( 0.002, f));\n    canvas = mix(canvas, vec3(0.),  step( 0.002, 0.008-abs(f)));\n  \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float re = 400.;\n    \n    vec2 r= iResolution.xy;\n    uv = fragCoord/iResolution.xy;\n    uv = floor(uv*re)/re;\n    vec2 cp = vec2(0.,1.)+uv*vec2(1.,-1.);\n\t\n    vec2 aspectRatio  = vec2( iResolution.x/iResolution.y,1.);\n    vec2 p = (uv-.5)*aspectRatio;\n\tvec2 pt = (uv-.5)*aspectRatio;\n\t\n    vec3 canvas ;\n    canvas = vec3(0.,0.97,0.97);\n  \n    float c = clouds(uv);\n    vec3 cloud = bit(canvas+ abs(vec3(c))+.5);\n    \n    float cb1 = step(.3,clouds(uv))-step(.3,clouds(uv-vec2(1./r)));\n    float cb2 = step(.5,clouds(uv))-step(.5,clouds(uv-vec2(1./r)));\n    float cb3 = step(.8,clouds(uv))-step(.8,clouds(uv-vec2(1./r)));\n    cloud = mix(cloud, vec3(0.8), step( 0.5, cb1 ));\n    cloud = mix(cloud, vec3(0.8), step( 0.5, cb2 ));\n    cloud = mix(cloud, vec3(0.8), step( 0.5, cb3 ));\n\n    canvas = mix(canvas, cloud, 1.-step( 0.4, cp.y ));\n    \n    float w2 = water(uv+vec2(0.,-0.7));\n    float w = water(uv);\n    canvas = mix(canvas, vec3(0.,0.5,0.97), step( 0.4, cp.y )*bit(w2));\n    canvas = mix(canvas, vec3(0.,0.0,0.97), step( 0.45, cp.y ));\n    canvas = mix(canvas, vec3(0.,0.0,0.48), step( 0.5, cp.y )*bit(w) );\n    \n    \n    float down = step(.63, cp.y);\n    float up = 1.-down;\n    \n    float pn = bit(perlin_noise(p*20.*vec2(1.,2.))*.4+.35)+.95;\n    \n    canvas = mix(canvas, vec3(0.9,.9,0.48), down*step( 0.0, .2-length((cp-vec2(0.,(1.,.5)))*vec2(1.,4.)-.5) ) );\n    canvas = mix(canvas, vec3(1.,1.0,0.48)*pn, up *step( 0.0, .2-length((cp-vec2(0.,(1.,.4)))*vec2(1.,2.)-.5) ) );\n    \n    coconutTree(canvas, p);\n    johnny(canvas, p);\n   \n    canvas = mix(canvas, vec3(0.),          step( 0.01, (length(p)-iTime+.3)  ));\n \n    fragColor = vec4(canvas,1.0);\n}\n// --------[ Original ShaderToy ends here ]---------- //\n\nvoid main(void)\n{\n    mainImage(gl_FragColor, gl_FragCoord.xy);\n}";
        ShaderList2.Berge = "/*\n * Original shader from: https://www.shadertoy.com/view/Wld3RS\n */\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n// glslsandbox uniforms\nuniform float time;\nuniform vec2 resolution;\n\n// shadertoy emulation\n#define iTime time\n#define iResolution resolution\n\n// --------[ Original ShaderToy begins here ]---------- //\n#define MAX_RAY_STEPS 100\n#define EPS 0.0001\n#define PI radians(180.)\n\nfloat rand(vec2 uv) {\n    return fract(sin(dot(sin(uv), vec2(12.9898, 78.233))) * 143758.5453);\n}\n\nmat2 rot(float a) {\n\tfloat ca = cos(a);\n    float sa = sin(a);\n    return mat2(ca, -sa, sa, ca);\n}\n\nfloat noise(vec2 uv, float scale) {\n    vec2 uvs = uv * scale;\n\tvec2 id = floor(uvs);\n    vec2 q = smoothstep(0., 1., fract(uvs));\n    vec2 e = vec2(1, 0);\n     \n    float rsx = mix(rand(id), rand(id + e.xy), q.x);\n    float rnx = mix(rand(id + e.yx), rand(id + e.xx), q.x);\n    \n    return mix(rsx, rnx, q.y);\n}\n\nfloat snoise(vec2 uv, float scale, float steps) {\n\tfloat s = 0., sk = 0.; \n    for (float i = 0.; i < 6.; i++) {\n        if (i >= steps) break;\n        float k = pow(2., i);\n    \ts += noise(uv, scale * k) / k;\n        sk += 1. / k;\n        uv *= rot(2. * PI * (i + 1.) / steps);\n    } \n    return smoothstep(0., 1., s / sk);\n}\n\nstruct Light {\n\tvec3 p;\n    float r;\n};\n\nstruct RayMarchInfo {\n    float sdf;\n    int steps;\n};\n\nfloat SceneSdf(vec3 p, float t) {\n    float sn = 4.;\n    float stn = 6.;\n    float amp = 0.4;\n    float d = p.y - snoise(vec2(p.x, p.z - t), sn, stn) * amp;    \n    return d / sn / amp;\n}\n\nvec3 GetNormal(vec3 p, float t) {\n\tfloat d = SceneSdf(p, t);\n    vec2 e = vec2(0.001, 0.);\n    vec3 n = d - vec3(\n        SceneSdf(p - e.xyy, t),\n        SceneSdf(p - e.yxy, t),\n        SceneSdf(p - e.yyx, t)\n    );\n    \n    return normalize(n);\n}\n\nRayMarchInfo RayMarch(vec3 ro, vec3 rd, float t) {\n    int raySteps = 0;\n    vec3 end = ro;\n    float sdf = 0.;\n    for(int i = 0; i < MAX_RAY_STEPS; i++) {\n        raySteps++;\n    \tfloat d = SceneSdf(end, t);\n        if (abs(d) < EPS) {\n        \tbreak;\n        }\n        end += d * rd;\n        sdf += d;\n    }\n    return RayMarchInfo(sdf, raySteps);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1.));\n    vec3 ro = vec3(0.5, 0.5, -2.);\n    vec3 col = vec3(0.);\n    float t = iTime;\n    \n    ro.z -= t;\n    \n    Light light = Light(vec3(0.5, 1.5, -4.), 0.06);\n    RayMarchInfo rmi = RayMarch(ro, rd, t);\n\n    vec3 p = ro + rmi.sdf * rd;\n    vec3 n = GetNormal(p, t); \n    vec3 pToL = light.p - p;\n    vec3 pToLN = normalize(pToL);\n    \n    RayMarchInfo lrmi = RayMarch(p + 0.3 * n, pToLN, t);\n    \n    col = vec3(1. / pow(length(pToL), 0.8));\n    \n    float diffuse = clamp(dot(n, pToLN), 0., 1.);\n    \n    if (lrmi.sdf < length(pToL) - light.r) {\n    \tcol *= 0.3;\n    }\n    \n    col *= diffuse;\n    \n    float fogCoef = 1. - exp(-rmi.sdf * 0.2);\n    float rxL = max(dot(rd, normalize(light.p - ro)), 0.);\n    vec3 fogCol = mix(vec3(0.53, 0.81, 0.92), vec3(0.98, 0.83, 0.64), pow(rxL, 50.));\n    \n    col = mix(col, fogCol, fogCoef);   \n    col += 0.35 * pow(rxL, 1. + pow(length(light.p - ro), 2.));\n    \n    fragColor = vec4(col, 1.0);\n}\n// --------[ Original ShaderToy ends here ]---------- //\n\nvoid main(void)\n{\n    mainImage(gl_FragColor, gl_FragCoord.xy);\n}";
        ShaderList2.Wasserwirbel = "/*\n * Original shader from: https://www.shadertoy.com/view/tlt3WS\n */\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n// glslsandbox uniforms\nuniform float time;\nuniform vec2 resolution;\n\n// shadertoy emulation\n#define iTime time\n#define iResolution resolution\n\n// --------[ Original ShaderToy begins here ]---------- //\n// by @etiennejcb\n// Using code from : https://www.shadertoy.com/view/Xt2XDt\n// and 3D Simplex noise from https://www.shadertoy.com/view/XsX3zB\n// Got help from @tdhooper\n\nconst float MAX_TRACE_DISTANCE = 100.0;           // max trace distance\nconst float INTERSECTION_PRECISION = 0.0001;        // precision of the intersection\nconst int NUM_OF_TRACE_STEPS = 190;\n\n\nvec3 random3(vec3 c) {\n\tfloat j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n\tvec3 r;\n\tr.z = fract(512.0*j);\n\tj *= .125;\n\tr.x = fract(512.0*j);\n\tj *= .125;\n\tr.y = fract(512.0*j);\n\treturn r-0.5;\n}\n\n/* skew constants for 3d simplex functions */\nconst float F3 =  0.3333333;\nconst float G3 =  0.1666667;\n\n/* 3d simplex noise */\nfloat simplex3d(vec3 p) {\n\t /* 1. find current tetrahedron T and it's four vertices */\n\t /* s, s+i1, s+i2, s+1.0 - absolute skewed (integer) coordinates of T vertices */\n\t /* x, x1, x2, x3 - unskewed coordinates of p relative to each of T vertices*/\n\t \n\t /* calculate s and x */\n\t vec3 s = floor(p + dot(p, vec3(F3)));\n\t vec3 x = p - s + dot(s, vec3(G3));\n\t \n\t /* calculate i1 and i2 */\n\t vec3 e = step(vec3(0.0), x - x.yzx);\n\t vec3 i1 = e*(1.0 - e.zxy);\n\t vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\t \t\n\t /* x1, x2, x3 */\n\t vec3 x1 = x - i1 + G3;\n\t vec3 x2 = x - i2 + 2.0*G3;\n\t vec3 x3 = x - 1.0 + 3.0*G3;\n\t \n\t /* 2. find four surflets and store them in d */\n\t vec4 w, d;\n\t \n\t /* calculate surflet weights */\n\t w.x = dot(x, x);\n\t w.y = dot(x1, x1);\n\t w.z = dot(x2, x2);\n\t w.w = dot(x3, x3);\n\t \n\t /* w fades from 0.6 at the center of the surflet to 0.0 at the margin */\n\t w = max(0.6 - w, 0.0);\n\t \n\t /* calculate surflet components */\n\t d.x = dot(random3(s), x);\n\t d.y = dot(random3(s + i1), x1);\n\t d.z = dot(random3(s + i2), x2);\n\t d.w = dot(random3(s + 1.0), x3);\n\t \n\t /* multiply d by w^4 */\n\t w *= w;\n\t w *= w;\n\t d *= w;\n\t \n\t /* 3. return the sum of the four surflets */\n\t return dot(d, vec4(52.0));\n}\n\n//----\n// Camera Stuffs\n//----\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\n// checks to see which intersection is closer\n// and makes the y of the vec2 be the proper id\nvec2 opU( vec2 d1, vec2 d2 ){\n    \n\treturn (d1.x<d2.x) ? d1 : d2;\n    \n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nfloat TWO_PI = 2.0*3.141592;\n\n\nfloat sdTunnel( vec3 p, float s )\n{\n  vec3 inp = vec3(5.5*p.x,1.5*p.y,20.0*p.z-5.0*iTime);\n  float ns =  simplex3d(inp);\n  float yy = -0.45*pow(max(0.,-0.5*p.z),1.5);\n  float angle2 = atan((p.y+yy),p.x);\n  float sph = abs(length(vec2(p.x,p.y+yy))-s)+0.01+0.017*sin(5.0*angle2+6.0*p.z-TWO_PI*iTime);\n  float offset2 = 0.05;\n  if (sph < offset2) {\n    sph += offset2 * ns;\n  }\n  return sph;\n}\n\n\n//--------------------------------\n// Modelling \n//--------------------------------\nvec2 map( vec3 pos ){  \n    \n \tvec2 res = vec2( sdTunnel( pos - vec3( .0 , .0 , -0.4 ) , 0.7 ) , 1. ); \n    \n    return res;\n    \n}\n\nvec3 result;\n\nvec2 calcIntersection( in vec3 ro, in vec3 rd ){\n    float h =  INTERSECTION_PRECISION*2.0;\n    float t = 0.0;\n\tfloat res = -1.0;\n    float id = -1.;\n    \n    for( int i=0; i< NUM_OF_TRACE_STEPS ; i++ ){\n        \n        if(t > MAX_TRACE_DISTANCE ) break;\n\t   \tvec2 m = map( ro+rd*t );\n        h = m.x;\n        t += max(abs(h), INTERSECTION_PRECISION);\n        id = m.y;\n        result += vec3(4.*0.013/(0.5+3.0*abs((ro+rd*t).z-2.0)));\n    }\n\n    if( t < MAX_TRACE_DISTANCE ) res = t;\n    if( t > MAX_TRACE_DISTANCE ) id =-1.0;\n    \n    return vec2( res , id );\n    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    result = vec3(0.);\n    vec3 color = vec3(0.,0.,0.);\n    vec2 p = (-iResolution.xy + 2.0*(fragCoord.xy+vec2(0,0)))/iResolution.y;\n\n    vec3 ro = vec3( 0., 0., 2.);\n    vec3 ta = vec3( 0. , 0. , 0. );\n\n    mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 );  // 0.0 is the camera roll\n\n    vec3 rd = normalize( camMat * vec3(p.xy,2.0) ); // 2.0 is the lens length\n\n    vec2 res = calcIntersection( ro , rd  );\n    \n    fragColor = vec4(result,1.0);\n}\n\n// --------[ Original ShaderToy ends here ]---------- //\n\nvoid main(void)\n{\n    mainImage(gl_FragColor, gl_FragCoord.xy);\n}";
        ShaderList2.Whitekugel = "/*\n * Original shader from: https://www.shadertoy.com/view/3lt3DS\n */\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n// glslsandbox uniforms\nuniform float time;\nuniform vec2 resolution;\n\n// shadertoy emulation\n#define iTime time\n#define iResolution resolution\n\n// --------[ Original ShaderToy begins here ]---------- //\nconst float DETAIL    = 1.;\nconst int   MAX_STEPS = 128;\nconst float MAX_MARCH = 20.;\n\nconst vec3 cameraPosition = vec3(-3,3,2)*1.7;\nconst vec3 cameraLook = vec3(0,-.8,0);\nconst vec3 cameraDirection = normalize(cameraLook-cameraPosition);\nconst vec3 cameraRight = normalize(cross(cameraDirection,vec3(0,1,0)));\nconst vec3 cameraUp = -cross(cameraDirection,cameraRight);\n\nconst float ZOOM = .33;\n\nconst vec3  SKY_COLOR  = vec3(.45,.56,1.);\nconst vec3  SUN_VECTOR = normalize(vec3(1,1.2,.8));\nconst vec3  SUN_COLOR  = vec3(1.);\nconst float SUN_SIZE   = 0.0001;\n\nconst float OCCLUSION_SPREAD    = 0.01;\nconst float OCCLUSION_INTENSITY = .1;\nconst int   OCCLUSION_SAMPLES   = 3;\n\nconst float RADIUS = .35;\nconst float OFFSET = 1.5;\nconst float BASEW = (OFFSET*2.+RADIUS)*.8;\nconst float BASEH = 0.4; //percentage\nconst float THICK = .02;\nconst float SPEED = .7;\n\nconst int AA = 1;//sqaure root of the samples per pixel for anti-aliasing\n\nmat2 getRotation(float a){  \n    float c = cos(a);\n    float s = sin(a);\n    return mat2(\n         c, s,\n        -s, c\n    ); \n}\n\nvec3 getSky(vec3 dir){\n    vec3 d = dir-SUN_VECTOR;\n    return SKY_COLOR + SUN_COLOR*min(SUN_SIZE/dot(d,d),1.);\n}\n\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nconst vec3 n1 = normalize(vec3(1,0,-1));\nconst vec3 n2 = vec3(0.38268343236,0,-0.92387953251);\nconst vec3 n3 = vec3(0.19509032201,0,-0.9807852804);\n\nfloat distanceSpinny(vec3 p){\n    float dis = MAX_MARCH;\n    mat2 R1 = getRotation(iTime*SPEED);\n    mat2 R2 = getRotation(-iTime*SPEED*2.);\n    \n    p.xz *= R1; \n    p.x -= OFFSET;  \n    p.xz *= R2;\n    \n    float main = sdCappedCylinder(p-vec3(0,RADIUS*2.+3.,0),THICK,3.);\n    dis = min(dis,main);\n    \n    p.xz = abs(p.xz);\n    p -= 2.*min(0.,dot(p, n1)) * n1;\n    p -= 2.*min(0.,dot(p, n2)) * n2;\n    \n    p.x -= OFFSET;\n    \n    float ball = length(p)-RADIUS;\n    dis = min(dis,ball);\n    \n    float stick = sdCappedCylinder(p-vec3(0,1.5*RADIUS,0),THICK,RADIUS*.5);\n    dis = min(dis,stick);\n    \n    float joint = length(p-vec3(0,RADIUS*2.,0))-THICK;\n    dis = min(dis,joint);\n    \n    p.x += OFFSET*.5;\n    p.y -= RADIUS*2.;\n    float spoke = sdCappedCylinder(p.yxz,THICK,OFFSET*.5); \n    dis = min(dis,spoke);\n    \n    return dis;\n}\n\nfloat distanceCylinders(vec3 p){\n    float dis = MAX_MARCH;\n\n    p.xz = abs(p.xz);\n    p -= 2.*min(0.,dot(p, n1)) * n1;\n    p -= 2.*min(0.,dot(p, n2)) * n2;\n    p -= 2.*min(0.,dot(p, n3)) * n3;\n    \n    p.x -= OFFSET;\n\n    p = p.yxz;\n    dis = min(dis,sdCappedCylinder(p,RADIUS,OFFSET*2.+RADIUS));\n    \n    return dis;\n}\n\nfloat distanceBase(vec3 p){\n    float base = sdCappedCylinder(p+vec3(0,RADIUS*(1.-BASEH),0), BASEW , RADIUS*BASEH);\n    float cyl = distanceCylinders(p);\n    return max(base,-cyl);\n}\n\nfloat getDistance(vec3 p){\n    float dis = MAX_MARCH;\n    \n    dis = min(dis,p.y+1.);\n    dis = min(dis,distanceSpinny(p));\n    dis = min(dis,distanceBase(p));\n    \n\treturn dis;   \n    \n}\n\nvec3 getColor(vec3 p){\n    return vec3(.75);\n}\n\nvec3 getNormal(vec3 p, float eps){\n    eps = max(eps,1e-7);\n    vec2 k = vec2(1,-1);\n    vec2 d = k*eps;\n    return normalize( k.xyy*getDistance( p + d.xyy ) + \n                      k.yyx*getDistance( p + d.yyx ) + \n                      k.yxy*getDistance( p + d.yxy ) + \n                      k.xxx*getDistance( p + d.xxx ) );\n}\n\n\nvoid raymarch(in vec3 p, in vec3 d, float eps, inout int steps, inout float dis, inout float meps, inout float t){\n\tfor (int i=0;i<MAX_STEPS;++i){\n\t\tdis = getDistance(p + d*t);     \n        t += dis;\n        meps = abs(t)*eps;\n\n\t\tif(dis<=meps){\n            t -= (meps-dis);\n            break;\n        }\n        \n        if(t>=MAX_MARCH){\n            t = MAX_MARCH;\n            break;\n        }\n\t\tsteps = i;\n\t}\n}\n\nfloat softshadow(vec3 p, vec3 d, float k, float eps){\n    float res = 1.0;\n    float ph  = 1e20;\n    float t   = 2.*eps;\n    \n    for(int i=0;i<MAX_STEPS;i++){\n        float h = getDistance(p + d*t);\n        \n        if( h < eps ) return 0.0;\n        \n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, k*d/max(0.0,t-y) );\n        ph = h;\n        t += h;\n        \n        if(t>MAX_MARCH) break;\n    }\n    \n    return res;\n}\n\nfloat occlusion(vec3 p, vec3 n, float t){\n    float o = 1.0;\n    float s = OCCLUSION_SPREAD*t;               \n    float k = OCCLUSION_INTENSITY/s;  \n    float d = 2.0*s;           \n    \n    for (int i = 0; i < OCCLUSION_SAMPLES; ++i) {\n        o -= (d - getDistance(p + n * d)) * k;\n        d += s;\n        k *= 0.5;\n    }\n    \n    return clamp(o, 0.0, 1.0);\n}\n\n\nvec3 raymarcher(vec3 p, vec3 d, float eps){ \n    int   steps = 0;\n    float dis = 0.;\n    float meps = 0.;\n    float t = 0.;\n    raymarch(p,d,eps,steps,dis,meps,t);\n    vec3 hitPos    = p + d*t;\n\n    if(dis<meps){\n\n        vec3 hitColor  = getColor(hitPos);\n        vec3 hitNormal = getNormal(hitPos,meps);\n        vec3 reflectDir = reflect(d,hitNormal);\n\n        float diffuse   = max(dot(hitNormal,SUN_VECTOR),0.);\n        float shadow    = diffuse>0. ? softshadow(hitPos + hitNormal*meps*2.,SUN_VECTOR,.1/SUN_SIZE,meps) : 0.;\n        float specular  = diffuse>0. && shadow>0. ? pow(max(dot(reflectDir,SUN_VECTOR),0.),32.) : 0.;\n        float occlusion = occlusion(hitPos,hitNormal,t);\n\n        vec3 c = hitColor*SUN_COLOR*diffuse*shadow + hitColor*SKY_COLOR*occlusion + SUN_COLOR*specular*shadow*.3;\n\n        return c;\n        \n    }else{\n\n        return getSky(d); \n\n    }   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    float minResolution = min(iResolution.x,iResolution.y);\n    float eps = ZOOM*DETAIL/minResolution;\n    \n    vec3 col = vec3(0);\n    \n    for(int i=1; i<=AA; i++)\n    for(int j=1; j<=AA; j++){\n\t\tvec2 p = fragCoord.xy + vec2(i,j)/float(AA);\n        \n        vec2 uv = (p*2.-iResolution.xy)/minResolution*ZOOM;\n    \n        vec3 ori = cameraPosition;\n        vec3 dir = normalize(cameraDirection+uv.x*cameraRight+uv.y*cameraUp);\n\n        col += raymarcher(ori,dir,eps);\n    }\n    \n    col /= float(AA*AA);\n\n    const float GAMMA = 2.2;\n    fragColor = vec4(pow(col, vec3(1./GAMMA)),1.0);\n}\n// --------[ Original ShaderToy ends here ]---------- //\n\nvoid main(void)\n{\n    mainImage(gl_FragColor, gl_FragCoord.xy);\n}";
        ShaderList2.Planet = "/*\n * Original shader from: https://www.shadertoy.com/view/wtc3Wj\n */\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n// glslsandbox uniforms\nuniform float time;\nuniform vec2 resolution;\n\n// shadertoy emulation\n#define iTime time\n#define iResolution resolution\n\n// --------[ Original ShaderToy begins here ]---------- //\n// Ecosphere - the procedural creation of a planet like sphere.\n//\n// Patrik Sandahl, 2019 - patrik.sandahl@gmail.com\n//\n// 3D noise algorithm by Ian McEwan, Ashima Arts.\n\n#define EPSILON 0.001\n#define DEFAULT_ZOOM 1.0\n\n#define PI 3.141592653589\n\n#define MAX_OCTAVES 9.0\n\n// Material for nothing. I.e. the empty space.\n#define MAT_NOTHING 0\n\n// Material for the colored sphere.\n#define MAT_COLOR_SPHERE 1\n\n// Material for the sea water.\n#define MAT_WATER_SPHERE 2\n\n// World seed - skew the input for the noise.\n#define WORLD_SEED 47.159\n\n// Initial scene - base sphere goes from dark to light and\n// gradually morphs into the naked ecosphere.\n#define SCENE0 0\n\n// Second scene - the colored ecosphere.\n#define SCENE1 1\n\n// Third scene - sea level rises.\n#define SCENE2 2\n\n// Forth scene - one day and night cycle.\n#define SCENE3 3\n\n// A ray object with origin and direction.\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n    \n// Force normalization of direction when creating a ray.\nRay ray(vec3 origin, vec3 direction);\n\n// Calculate a point at distance d along the ray.\nvec3 point(Ray r, float d);\n\n// Generate a primary camera ray given:\n// eye - the camera position.\n// at - the position where the camera is looking.\n// up - the world up position.\n// focalLength - the zoom value for the camera. A greater value zoom in.\n// uv - the uv coordinate for which the ray is produced. It is assumed\n// that uv zero is in the middle of the projection.\n// The camera is assuming an OpenGL like coordinate system.\nRay cameraRay(vec3 eye, vec3 at, vec3 up, float focalLength, vec2 uv);\n\n// An intersection object with distance along the ray, an displacement\n// offset for the object and the material id for the object.\nstruct Intersection {\n    float dist;\n    float offset;\n    int material;\n};\n\n// Produce the closest intersection from the scene given the position.\nIntersection intersectScene(int sceneId, vec3 pos);\n\n// March the ray for an intersection with the scene.\nIntersection march(int sceneId, Ray r, float far);\n    \n// Calculate a normal through central difference. It's very expensive\n// though. Consider a noise function with analytical derivatives as\n// future improvement.\nvec3 calcNormal(int sceneId, vec3 pos);\n\n// Calculate a 2D rotations matrix.\nmat2 calcRotate2d(float theta);\n\n// Distance function for the base sphere.\nfloat baseSphere(vec3 pos);\n\n// Distance function for a shere. The position - relative origin - and\n// the radius for the sphere.\nfloat sphere(vec3 pos, float radius);\n\n// Get the sun's position.\nvec3 sunPosition(int sceneId);\n\n// Normalize the height offset from ~[-1 : 1] to ~[0 : 1].\nfloat normalizeOffset(float offset);\n\n// Get the terrain color the given height offset.\nvec3 terrainColor(float offset);\n\n// Estimate the needed number of octaves from screen with.\nint estimateOctaves(float width);\n\n// Noise functions.\nfloat fbm(vec3 pos, int numOctaves);\nfloat snoise(vec3 v);\n\n// Entry point for generating the image.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalized pixel coordinate where origo is in the\n    // middle and compensation is made for aspect ratio.\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    // Make a primary ray for the uv position.\n    vec3 eye = vec3(0.0, 0.0, 25.0);\n    vec3 at = vec3(0.0);\n    vec3 up = normalize(vec3(0.5, 1.0, 0.0)); // Tilt the view a little.\n    \n    Ray primaryRay = cameraRay(eye, at, up, DEFAULT_ZOOM, uv);\n            \n    // Determine scene id from time.   \n    int sceneId = SCENE0;\n    if (iTime >= 24.0) {\n      \tsceneId = SCENE3;\n    } else if (iTime >= 16.0) {\n        sceneId = SCENE2;\n    } else if (iTime >= 12.0) {\n        sceneId = SCENE1;\n    }\n    \n    // Perform the ray marching, keep the far plane near ;-)\n    Intersection intersection = march(sceneId, primaryRay, 45.0);\n    \n    // Create a default color for the current pixel.\n    vec3 color = vec3(0.0);\n    \n    if (intersection.material == MAT_COLOR_SPHERE) {\n        // A sphere colored using its height offset.\n         \tvec3 pos = point(primaryRay, intersection.dist);\n    \t\tvec3 lightDirection = normalize(sunPosition(sceneId) - pos);\n    \t\tvec3 normal = calcNormal(sceneId, pos);                \n    \t\tfloat light = max(0.0, dot(normal, lightDirection));            \n                            \n            vec3 graySphere = vec3(normalizeOffset(intersection.offset));\n            vec3 colorSphere = terrainColor(intersection.offset);\n            color = mix(graySphere, colorSphere, smoothstep(12.0, 16.0, iTime));\n                \n        \tcolor = color * light;\n    }\n    else if (intersection.material == MAT_WATER_SPHERE) {\n        // A sphere with ocean color.\n            vec3 pos = point(primaryRay, intersection.dist);\n    \t\tvec3 lightDirection = normalize(sunPosition(sceneId) - pos);\n    \t\tvec3 normal = calcNormal(sceneId, pos);                \n    \t\tfloat light = max(0.0, dot(normal, lightDirection));\n            \n            vec3 ocean = vec3(0.0, 67.0 / 255.0, 123.0 / 255.0);\n            color = ocean * light;\n    }\n\n    // Output to screen.\n    fragColor = vec4(color, 1.0);\n}\n\nRay ray(vec3 origin, vec3 direction)\n{\n    return Ray(origin, normalize(direction));\n}\n\nvec3 point(Ray r, float d)\n{\n    return r.origin + r.direction * d;\n}\n\nRay cameraRay(vec3 eye, vec3 at, vec3 up, float focalLength, vec2 uv)\n{\n    vec3 z = normalize(at - eye);\n    vec3 x = normalize(cross(z, up));\n    vec3 y = cross(x, z);\n    \n    vec3 center = eye + z * focalLength;\n    vec3 xy = center + uv.x * x + uv.y * y;\n    \n    return ray(eye, xy - eye);\n}\n\nIntersection intersectScene(int sceneId, vec3 pos)\n{\n    // The sphere shall be rotated in all scenes.\n    pos.xz = calcRotate2d(iTime * 0.05) * pos.xz;\n    \n    // And there always be a base sphere.\n    float sphereDist = baseSphere(pos - vec3(0.0));\n    \n    // There shall always be height offset.\n    float offset = fbm((pos + WORLD_SEED) * 0.13, estimateOctaves(iResolution.y));\n    \n    if (sceneId == SCENE0) {\n        \n        // Mix between the base sphere and the ecosphere.\n        float factor = smoothstep(4.0, 10.0, iTime);\n        float dist = mix(sphereDist, sphereDist - offset, factor);\n        \n        return Intersection(dist, offset, MAT_COLOR_SPHERE);      \n    }  else if (sceneId == SCENE1) {\n        \n        // Just the ecosphere.\n        return Intersection(sphereDist - offset, offset, MAT_COLOR_SPHERE);      \n    } else {\n        \n        // The ecosphere and sea.\n        float seaDist = sphere(pos - vec3(0.0), mix(9.00, 9.88, smoothstep(16.0, 24.0, iTime)));        \n        if (seaDist < sphereDist - offset) {\n            return Intersection(seaDist, 0.0, MAT_WATER_SPHERE);\n        } else {\n            return Intersection(sphereDist - offset, offset, MAT_COLOR_SPHERE);\n        }\n    }\n}\n\nIntersection march(int sceneId, Ray r, float far)\n{\n    float rayDistance = 0.0;\n    Intersection intersection = Intersection(0.0, 0.0, MAT_NOTHING);\n    \n    for (int i = 0; i < 100; ++i) {       \n        intersection = intersectScene(sceneId, point(r, rayDistance));\n        \n        rayDistance += intersection.dist;\n        if (intersection.dist < EPSILON) break;\n        if (rayDistance > far) {\n            intersection.material = MAT_NOTHING;\n            break;\n        }\n    }\n    \n    intersection.dist = rayDistance;\n    return intersection;\n}\n\nvec3 calcNormal(int sceneId, vec3 pos)\n{\n    float d = intersectScene(sceneId, pos).dist;\n    vec2 e = vec2(EPSILON, 0.0);\n    \n    vec3 n = d - vec3(\n        intersectScene(sceneId, pos - e.xyy).dist,\n        intersectScene(sceneId, pos - e.yxy).dist,\n        intersectScene(sceneId, pos - e.yyx).dist\n    );\n    \n    return normalize(n);\n}\n\nmat2 calcRotate2d(float theta)\n{\n    return mat2(vec2(cos(theta), -sin(theta)), vec2(sin(theta), cos(theta)));\n}\n\nfloat baseSphere(vec3 pos)\n{\n    return sphere(pos, 10.0);\n}\n\nfloat sphere(vec3 pos, float radius)\n{\n    return length(pos) - radius;\n}\n\nvec3 sunPosition(int sceneId)\n{\n    // The base position for the sun.\n    vec3 basePosition = vec3(100.0, 0.0, 100.0);\n    \n    if (sceneId == SCENE0) {\n        // Let the sun travel one half orbit from back of sphere to base.\n        float theta = mix(-PI, 0.0, smoothstep(0.0, 10.0, iTime));\n        basePosition.xz = calcRotate2d(theta) * basePosition.xz;\n    } else if (sceneId == SCENE3) {\n        // Let the sun orbit. 20 seconds for a full circle.\n        float theta = mix(0.0, PI * 2.0, smoothstep(24.0, 34.0, iTime));\n        basePosition.xz = calcRotate2d(theta) * basePosition.xz;\n    }\n    \n    return basePosition;\n}\n\nfloat normalizeOffset(float offset)\n{\n    return offset * 0.75 + 0.5;\n}\n\nvec3 terrainColor(float offset)\n{\n    offset = normalizeOffset(offset);\n    \n    vec3 clay = vec3(127.0 / 255.0, 95.0 / 255.0, 63.0 / 255.0);\n    vec3 fern = vec3(79.0 / 255.0, 121.0 / 255.0, 66.0 / 255.0);\n    vec3 forest = vec3(11.0 / 255.0, 102.0 / 255.0, 35.0 / 255.0);\n    vec3 granite = vec3(97.0 / 255.0, 97.0 / 255.0, 97.0 / 255.0);\n    vec3 snow = vec3(1.0, 250.0 / 255.0, 250.0 / 255.0);\n    \n    vec3 color = mix(clay, fern, smoothstep(0.0, 0.4, offset));\n    color = mix(color, forest, smoothstep(0.4, 0.55, offset));\n    color = mix(color, granite, smoothstep(0.55, 0.65, offset));\n    color = mix(color, snow, smoothstep(0.65, 1.0, offset));\n    \n    return vec3(color);\n}\n\nint estimateOctaves(float height)\n{\n    // Ad hoc heuristics for the selection of octaves. Made from what's looking good.\n    if (height <= 450.0) {\n        return 7;\n    } else if (height <= 675.0) {\n        return 8;\n    } else {\n        return 9;\n    }\n}\n\nfloat fbm(vec3 pos, int numOctaves) {\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tvec3 shift = vec3(100);\n\tfor (int i = 0; i < 10; ++i) {\n\t\tif (i >= numOctaves) break;\n\t\tv += a * snoise(pos);\n\t\tpos = pos * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n\n//\tSimplex 3D Noise \n//\tby Ian McEwan, Ashima Arts\n//\nvec4 permute(vec4 x) {return mod(((x*34.0)+1.0)*x, 289.0);}\nvec4 taylorInvSqrt(vec4 r) {return 1.79284291400159 - 0.85373472095314 * r;}\n\nfloat snoise(vec3 v)\n{ \n  \tconst vec2 C = vec2(1.0/6.0, 1.0/3.0) ;\n  \tconst vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n\t// First corner\n  \tvec3 i = floor(v + dot(v, C.yyy) );\n  \tvec3 x0 = v - i + dot(i, C.xxx) ;\n\n\t// Other corners\n  \tvec3 g = step(x0.yzx, x0.xyz);\n  \tvec3 l = 1.0 - g;\n  \tvec3 i1 = min( g.xyz, l.zxy );\n  \tvec3 i2 = max( g.xyz, l.zxy );\n\n  \t//  x0 = x0 - 0. + 0.0 * C \n  \tvec3 x1 = x0 - i1 + 1.0 * C.xxx;\n  \tvec3 x2 = x0 - i2 + 2.0 * C.xxx;\n  \tvec3 x3 = x0 - 1. + 3.0 * C.xxx;\n\n\t// Permutations\n  \ti = mod(i, 289.0 ); \n  \tvec4 p = permute( permute( permute( \n    \t              i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n        \t   \t\t  + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n                      + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n\t// Gradients\n\t// ( N*N points uniformly over a square, mapped onto an octahedron.)\n  \tfloat n_ = 1.0/7.0; // N=7\n  \tvec3  ns = n_ * D.wyz - D.xzx;\n\n  \tvec4 j = p - 49.0 * floor(p * ns.z *ns.z);  //  mod(p,N*N)\n\n  \tvec4 x_ = floor(j * ns.z);\n  \tvec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  \tvec4 x = x_ *ns.x + ns.yyyy;\n  \tvec4 y = y_ *ns.x + ns.yyyy;\n  \tvec4 h = 1.0 - abs(x) - abs(y);\n\n  \tvec4 b0 = vec4( x.xy, y.xy );\n  \tvec4 b1 = vec4( x.zw, y.zw );\n\n  \tvec4 s0 = floor(b0)*2.0 + 1.0;\n  \tvec4 s1 = floor(b1)*2.0 + 1.0;\n  \tvec4 sh = -step(h, vec4(0.0));\n\n  \tvec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  \tvec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  \tvec3 p0 = vec3(a0.xy,h.x);\n  \tvec3 p1 = vec3(a0.zw,h.y);\n  \tvec3 p2 = vec3(a1.xy,h.z);\n  \tvec3 p3 = vec3(a1.zw,h.w);\n\n\t//Normalise gradients\n  \tvec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  \tp0 *= norm.x;\n  \tp1 *= norm.y;\n  \tp2 *= norm.z;\n  \tp3 *= norm.w;\n\n\t// Mix final noise value\n  \tvec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  \tm = m * m;\n  \treturn 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                  dot(p2,x2), dot(p3,x3) ) );\n}\n// --------[ Original ShaderToy ends here ]---------- //\n\nvoid main(void)\n{\n    mainImage(gl_FragColor, gl_FragCoord.xy);\n}";
        ShaderList2.Radar = "\n\n// \n// radar sonar simulation demo code glsl\n// code by Twareintor (2017) - copyright (c) 2017 Claudiu Ciutacu\n// doesn't uses the render buffer anymore; in this case\n//     the DECAY get another function: the spread angle\n// mailto: ciutacu/d]gmail*com\n\n// doesn't use the backbuffer\n// note: my graphic card: NVIDIA GeForce\n\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#extension GL_OES_standard_derivatives : enable\n\n\n\n#define PI 3.14159265359\n\n#define SPOT 7.\n#define OMEGA 0.42 \t// \n#define RADIUS 180. // \n#define DECAY .975 // max.0.98\n#define GRIDON true // \n#define DIRECTION 1. // 1. (right) or -1. \n#define TRAVELSPEED 10.\n#define OBSTACLESIZE .24 // reasonable???\n\n\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n\n\n\nfloat circleA(vec3 p0, float rad, float size)\n{\n    float q;\n    vec3 p = gl_FragCoord.xyz-p0;\n    q = clamp(size/2./abs((abs(length(gl_FragCoord.xyz-p0)-rad))), 0., 1.);\n    return q;\n}\n\nfloat point(vec3 p0, float size)\n{\n    float q = clamp(1.-float(length(gl_FragCoord.xyz-p0)/size), 0., 1.);\n    return q;\n}\n\nfloat line(vec3 p0, vec3 p1, float size)\n{\n    vec3 pos = p0+normalize(p1-p0)*length(gl_FragCoord.xyz-p0)*dot(normalize(p1-p0), normalize(gl_FragCoord.xyz-p0));\n    float q = clamp(1.-float(length(gl_FragCoord.xyz-pos)/size), 0., 1.); \n    return q;\n}\n\nfloat segment(vec3 p0, vec3 p1, float size, bool ends)\n{\n    float q = line(p0, p1, size);\n    // limit the line at its ends:\n    q*=float(0.0>=dot(normalize(gl_FragCoord.xyz-p0), normalize(gl_FragCoord.xyz-p1)));\n    if(ends) q = max(q, point(p0, size)); // adding points same size at ends\n    return q;\n}\n\n/** block from: \"http://www.glslsandbox.com/e#40767.0\" */\nfloat r(vec2 n) {\n    return fract(cos(dot(n,vec2(36.26,73.12)))*354.63);\n}\n\nfloat noise(vec2 n) \n{\n    vec2 fn = floor(n);\n    vec2 sn = smoothstep(0.,1.,fract(n));\n    \n    float h1 = mix(r(fn),           r(fn+vec2(1,0)), sn.x);\n    float h2 = mix(r(fn+vec2(0,1)), r(fn+1.)       , sn.x);\n    return mix(h1,h2,sn.y);\n}\n\nfloat perlin(vec2 n) {  \n    return noise(n/32.)*0.5875+noise(n/16.)/5.+noise(n/8.)/10.+noise(n/4.)/20.+noise(n/2.)/40.+noise(n)/80.;\n}\n\n/** ~block from: */\n\n\nvoid main() \n{\n\tfloat t = time;\n\tvec2 cen = resolution.xy/2.0;\n\tvec2 enem = cen+vec2(mouse.x, mouse.y)*RADIUS;\n\tfloat r = .0;\n\tfloat g = .0;\n\tfloat b = .0;\n\tvec2 f = gl_FragCoord.xy-cen;\n\tif(length(f)<RADIUS)\n\t{\n\t    /** the trace is green... */\n\t    g = f.x/length(f)*cos(t)+f.y/length(f)*sin(t)*DIRECTION;\n\t    g*=1.0-length(f)/RADIUS/128.9;\n\t    g = pow(g, 45.*DECAY);\n\t    g-=(SPOT-length(gl_FragCoord.xy-enem))*float((length(gl_FragCoord.xy-enem)<SPOT));\n            g+=point(vec3(cen, 0.), 4.);\n            float map = float(perlin(vec2(\n\t\t    gl_FragCoord.x, gl_FragCoord.y+time*TRAVELSPEED\n\t    \t))>(1.-OBSTACLESIZE));\n            g-=map;\n\t}\n\telse\n\t{\n\t    r=.1; g=.1; b=.1;\n\t}\n\tvec4 outColor = vec4(r, g, b, 1.0);\n    /**   */\n    float grid, grid2;\n    if(GRIDON)\t/** the grid  */\n    {\n        grid = circleA(vec3(cen, 0.), RADIUS+1., 1.35);\n        grid+=circleA(vec3(cen, 0.), RADIUS/2., .31);\n        grid+=circleA(vec3(cen, 0.), RADIUS/4., .21);\n\tgrid+=circleA(vec3(cen, 0.), RADIUS*3./4., .21);\n        for(int i=0; i<8; i++)\n        {\n            float phase = 2.*PI/8.*float(i);\n            vec3 p0 = vec3(cen, 0.)+RADIUS/4.*vec3(cos(phase), sin(phase), 0.);\n            vec3 p1 = vec3(cen, 0.)+RADIUS*vec3(cos(phase), sin(phase), 0.);\n            grid2+=segment(p0, p1, 3.75, false);\n\t    /**** removed peripherial grid ****/\n            p0 = vec3(cen, 0.)+RADIUS/1.25*vec3(cos(phase+PI/8.), sin(phase+PI/8.), 0.);\n            p1 = vec3(cen, 0.)+RADIUS*vec3(cos(phase+PI/8.), sin(phase+PI/8.), 0.);\t\t\n            grid2+=segment(p0, p1, 3.75, false);\n            \n        }\n\t    \n    }\n    outColor = vec4(mix(grid, grid2, 0.15), g, 0., 1.0);\n\tgl_FragColor = outColor;\n\n}";
        ShaderList2.Wuerfellego = "/*\n * Original shader from: https://www.shadertoy.com/view/wlcXWn\n */\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n// glslsandbox uniforms\nuniform float time;\nuniform vec2 resolution;\n\n// shadertoy emulation\n#define iTime time\n#define iResolution resolution\nconst vec4 iMouse = vec4(0.);\n\n// --------[ Original ShaderToy begins here ]---------- //\nconst float PI = 3.14159265359;\n\nfloat sdBox( vec3 p, vec3 b )\n{\n vec3 d = abs(p) - b;\n return length(max(d,0.0)); \n}\n\n\nfloat dBar(vec2 p, float width) {\n vec2 d = abs(p) - width;\n return min(max(d.x, d.y), 0.0) + length(max(d, 0.)) + 0.01 * width;\n}\n\nfloat dCrossBar(vec3 p, float x) {\n float bar_x = dBar(p.yz, x);\n float bar_y = dBar(p.zx, x);\n float bar_z = dBar(p.xy, x);\n return min(bar_z, min(bar_x, bar_y));\n}\n\nmat2 Rot(float a) {\n float s = sin(a);\n float c = cos(a);\n return mat2(c, -s, s, c);\n}\n\nfloat sdOctahedron( vec3 p, float s)\n{\n p = abs(p);\n return (p.x+p.y+p.z-s)*0.57735027;\n}\n\nfloat dMengerSponge(vec3 p) \n{\n float d = sdBox(p, vec3(0.6));\n const float itt = 5.;\n float one_third = 2. / itt;\n for (float i = 0.0; i < itt; i++) {\n  float k = pow(one_third, i);\n  float kh = k * 1.;\n  d = max(d, -dCrossBar(mod(p + kh, k * 2.) - kh, k * one_third));\n }\n return d;\n}\nfloat dMengerSponge2(vec3 p) \n{\n float d = sdBox(p, vec3(0.4));\n const float itt = 4.;\n float one_third = 1. / itt;\n for (float i = 0.0; i < itt; i++) {\n  float k = pow(one_third, i);\n  float kh = k * 1.;\n  d = max(d, -dCrossBar(mod(p + kh, k * 2.) - kh, k * one_third));\n }\n return d;\n}\n\nvec2 condmin(in vec2 d1, in vec2 d2) {\nreturn vec2(min(d1.x, d2.x), mix(d1.y, d2.y, step(d2.x, d1.x)));\n}\n\nfloat g1;\nvec2 GetDist(vec3 p) {\t\n    \n float gap = 1.;\n p.xyz = mod(p.xyz + gap,2.0 * gap) - gap;\n vec2 d;\n d=vec2(1.0);  \n vec3 p5 = p;\n p5.xz *= Rot(sin(0.09*.4*6.28));\n vec2 dm1= vec2(dMengerSponge(p5),2);\n p = abs(p-.4);   \n vec3 p1 = p-vec3(-.0,1.,1.0);\n vec3 p2 = p-vec3(1.,0.0,1.0);\n vec3 p4 = p-vec3(1.,1.0,.0);   \n vec2  dm2=vec2(dMengerSponge2(p1),1);\n vec2  dm3=vec2(dMengerSponge2(p2),1);\n vec2  dm4=vec2(dMengerSponge2(p4),1);\n dm2.x *=0.6;\n dm3.x *=0.6;  \n dm4.x *=0.6;\n d = condmin( d,dm1);\n d = condmin( d,dm2);\n d = condmin( d,dm3);\n d = condmin( d,dm4);\n g1 +=1./(.02+pow(abs(dm1.x),10.));\n return d;\n}\n\nvec2 RayMarch (vec3 ro, vec3 rd) \n {\n vec2 h, t=vec2( 0.);\n for (int i=0; i<64; i++) \n  {\n h = GetDist(ro + t.x * rd);\n if(h.x<0.001||t.x>100. ) break;\n  t.x+=h.x;t.y=h.y;\n }\n if(t.x>100.) t.x=0.;\n return t;\n}\n\nvec3 GetNormal(vec3 p){\nvec2 e = vec2(.00035, -.00035); \nreturn normalize(\n e.xyy * GetDist(p + e.xyy).x + \n e.yyx * GetDist(p + e.yyx).x + \n e.yxy * GetDist(p + e.yxy).x + \n e.xxx * GetDist(p + e.xxx).x);\n}\n\nvec3 cameraPath(float t) {\n t *= PI *.5 ;\n float t2 =  cos(t)+0.;\n float c = cos(t*2.);\n float x = 0.;\n float y = 0.;\n float z = 0.;\n if (t2<0.){\n  x = 1. /1. + 2. +c;\n };       \n if (t2>0.){\n  y = 1. /1. + 2. +c;\n };\n vec3 xyz =vec3(x,y,z);\n return xyz;\n}\n\nfloat GetLightPos(vec3 p, vec3 lpos) {\n float s = mod(iTime * 0.25, 1.0);\n float t = 2. * (2.0 * s - s * s);\n vec3 cameraPos = cameraPath(t);\n vec3 lightPos1 = vec3(-cameraPos-vec3(4,4.,2.0));\n vec3 l1 = normalize(lightPos1-p);\n vec3 n1 = GetNormal(p);    \n float dif1 = clamp(dot(n1, l1), 0., 1.);\n vec2 d1 = RayMarch(p+n1*0.001*1., l1);\n if(d1.x<length(lightPos1-p)) dif1 *= 1.;    \n return (dif1)/1.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n vec2 m = iMouse.xy/iResolution.xy;\n vec3 col = vec3(0);\n float s = mod(iTime * 0.25, 1.0);\n float t = 2. * (2.0 * s - s * s);  \n vec3 cameraPos = cameraPath(t);\n vec3 ro = vec3(-cameraPos);\n vec3 rd = normalize(vec3(uv.x, uv.y, 0.4));\n float the = iTime *0.3;\n rd.xz *= mat2(cos(the), -sin(the), sin(the), cos(the));\n rd.yz *= mat2(cos(the), -sin(the), sin(the), cos(the));\n rd.xy *= mat2(cos(the), -sin(the), sin(the), cos(the));\n vec2 d = RayMarch(ro, rd);\n float t2;\n t2=d.x;   \n if(t2>0.)\n {\n  vec3 p = ro + rd * t2;\n  vec3 baseColor = vec3(0.,0.6,0.);\n  if(d.y==1.) baseColor=vec3((sin(iTime*1.5)*0.5+0.5),0.,0);\n  if(d.y==2.) baseColor=vec3((cos(iTime*1.5)*0.5+0.5),0.,0);\n;\n  float dif = GetLightPos(p, ro);\n  col = vec3(dif);\n  col+=baseColor;\n }  \n col*=g1*vec3(.0007);  \n float fog = 1. / (2. + d.x * d.x * 1.);\n col *= vec3(fog);  \n vec3 sky = vec3(1., 1., 1.);\n col = mix(sky, col, 1.1/(d.x*d.x/1./1.*.1+.8)); \n fragColor = vec4(col,1.0);\n}\n// --------[ Original ShaderToy ends here ]---------- //\n\nvoid main(void)\n{\n    mainImage(gl_FragColor, gl_FragCoord.xy);\n}";
        ShaderList2.Spin = "/*\n * Original shader from: https://www.shadertoy.com/view/ttV3Dt\n */\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n// glslsandbox uniforms\nuniform float time;\nuniform vec2 resolution;\nuniform vec2 mouse;\n\n// shadertoy emulation\n#define iTime time\n#define iResolution resolution\nvec4 iMouse = vec4(0.);\n\n// --------[ Original ShaderToy begins here ]---------- //\n\nvec3 rotate(vec3 p, float angle, vec3 axis){\n\tvec3 a = normalize(axis);\n\tfloat s = sin(angle);\n\tfloat c = cos(angle);\n\tfloat r = 1.0 - c;\n\tmat3 m = mat3(\n\t\ta.x * a.x * r + c,\n\t\ta.y * a.x * r + a.z * s,\n\t\ta.z * a.x * r - a.y * s,\n\t\ta.x * a.y * r - a.z * s,\n\t\ta.y * a.y * r + c,\n\t\ta.z * a.y * r + a.x * s,\n\t\ta.x * a.z * r + a.y * s,\n\t\ta.y * a.z * r - a.x * s,\n\t\ta.z * a.z * r + c\n\t);\n\treturn m * p;\n}\n\nconst float THRESHOLD = 0.0001;\nconst float maiorRadius = 5.0;\nconst float minorRadius = 3.0;\n\n// --------------------------------------------------------------------------\n\n// distance estimators\nfloat torusDist(vec3 p) {\n\tfloat f1 = min(abs(0.3 * sin(10.0 * atan(p.z, p.x))), 0.1);\n\tvec2 uv = vec2(-atan(p.z, p.x), atan(p.y, length(p.xz) - maiorRadius)) / 2.0 / 3.141592 + 0.5;\n\tfloat f2 = max(sin(200. * uv.x) * sin(200. * uv.y) - 0.95, 0.0);\n\tfloat dis1 = minorRadius - (f1 + f2) - length(vec2(length(p.xz) - maiorRadius, p.y));\n\treturn dis1;\n}\n\nfloat tubesDist(vec3 p) {\n\tfloat d1 = length(vec2(length(p.xz) - (maiorRadius + minorRadius - 0.5), p.y - 1.3)) - 0.2;\n\tfloat d2 = length(vec2(length(p.xz) - (maiorRadius + minorRadius - 0.5), p.y + 1.3)) - 0.2;\n\tfloat d3 = length(vec2(length(p.xz) - (maiorRadius - minorRadius + 0.6), p.y + 1.5)) - 0.2;\n\tfloat d4 = length(vec2(length(p.xz) - (maiorRadius - minorRadius + 1.0), p.y + 2.0)) - 0.2;\n\treturn min(min(d1, d2), min(d3, d4));\n}\n\nfloat floorDist(vec3 p) {\n\treturn p.y + 2.7;\n}\n\nfloat ceilDist(vec3 p) {\n\tfloat f = max(sin(10. * atan(p.z, p.x)) - 0.6, 0.0);\n\tfloat d1 = length(vec2(length(p.xz) - maiorRadius + 1.0, p.y - minorRadius - 2.0)) - 2.5 - f;\n\tfloat d2 = length(vec2(length(p.xz) - maiorRadius - 1.0, p.y - minorRadius - 2.0)) - 2.5 - f;\n\treturn min(d1, d2);\n}\n\nfloat protonsDist(vec3 p) {\n\tvec3 p1 = rotate(p, 10.0 * iTime, vec3(0., 1., 0.));\n\tfloat d1 = length(vec2(length(p1.xz) - maiorRadius, p1.y + 0.0)) - 0.1 * (sin(0.5 * atan(p1.z, p1.x)) + 1.0);\n\treturn d1;\n}\n\nfloat sceneDist(vec3 p) {\n\tfloat v = min(min(torusDist(p), tubesDist(p)), min(floorDist(p), ceilDist(p)));\n\treturn min(v, protonsDist(p));\n}\n\n// --------------------------------------------------------------------------\n\nvec3 torusColor(vec3 p) {\n\treturn vec3(0.9, 0.9, 1.0);\n}\n\nvec3 floorColor(vec3 p) {\n\treturn vec3(max(sin(50.0 * p.x) - 0.5, 0.0) + max(sin(50.0 * p.z) - 0.5, 0.0));\n}\n\nvec3 ceilColor(vec3 p) {\n\treturn vec3(0.9, 0.9, 1.0);\n}\n\nvec3 tubesColor(vec3 p) {\n\treturn vec3(0.8, 0.9, 1.0);\n}\n    \n// --------------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = ( gl_FragCoord.xy * 2. - iResolution.xy ) / min(iResolution.x, iResolution.y);\n\tvec2 mo = iMouse.xy / iResolution.xy - 0.5;\n\n\tvec3 cameraPos = vec3(0., -0.5, -7.);\n\tfloat screenZ = 2.0;\n\tvec3 rayDirection = normalize(vec3(p, screenZ));\n\n\trayDirection = rotate(rayDirection, -0.05, vec3(0., 0., 1.));\n\n\trayDirection = rotate(rayDirection, 2. * mo.x, vec3(0., 1., 0.));\n\trayDirection = rotate(rayDirection, 2. * mo.y, vec3(1., 0., 0.));\n\n\tcameraPos = rotate(cameraPos, iTime, vec3(0., 1., 0.));\n\trayDirection = rotate(rayDirection, iTime, vec3(0., 1., 0.));\n\n\tfloat depth = 0.0;\n\tvec3 col = vec3(1.0);\n\tvec3 rayPos;\n\n\t// ray marching\n\tint i = 0;\n\tfor (int ii = 0; ii < 99; ii++) {\n\t\trayPos = cameraPos + rayDirection * depth;\n\t\tfloat dist = sceneDist(rayPos);\n\t\tif (dist < THRESHOLD) {\n\t\t\tif      (torusDist(rayPos) < THRESHOLD) col = torusColor(rayPos);\n\t\t\telse if (floorDist(rayPos) < THRESHOLD) col = floorColor(rayPos);\n\t\t\telse if (ceilDist(rayPos)  < THRESHOLD) col = ceilColor(rayPos);\n\t\t\telse if (tubesDist(rayPos) < THRESHOLD) col = tubesColor(rayPos);\n\t\t\tif (protonsDist(rayPos) < THRESHOLD) col = vec3(100.0);\n\t\t\tbreak;\n\t\t}\n\t\tdepth += dist;\n\t\t++i;\n\t}\n\n\tcol = col * (1.6 / (1.0 + 0.1 * depth)); // scurisce con la profondita'\n\tcol = 0.1 * col * max(0.3 * float(i), 1.0); // effetto aura (schiarisce all'aumentare di i)\n    col = mix(col, vec3(0.6, 0.5, 1.0), max(1.0 - minorRadius - rayPos.y, 0.0));\n\n\t// luce rossa lampeggiante\n\tfloat f = sin(6. * iTime) * 0.3 + 0.3;\n\tcol = col * vec3(1., 1. - f, 1. - f);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n// --------[ Original ShaderToy ends here ]---------- //\n\nvoid main(void)\n{\n    iMouse = vec4(mouse * resolution, 0., 0.);\n    mainImage(gl_FragColor, gl_FragCoord.xy);\n}";
        ShaderList2.Glasstown = "/*\n * Original shader from: https://www.shadertoy.com/view/tt3SW7\n */\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n// glslsandbox uniforms\nuniform float time;\nuniform vec2 resolution;\n\n// shadertoy emulation\n#define iTime time\n#define iResolution resolution\n\n// --------[ Original ShaderToy begins here ]---------- //\nvec3 lightColor = normalize(vec3(0.8, 1.0, 1.0));\nvec3 skyColor1 = normalize(vec3(0.2, 0.6, 1.0));\nvec3 skyColor2 = normalize(vec3(0.8, 0.9, 1.0));\nvec3 buildingColor = vec3(0., 0., 0.);\n\nmat4 rotationMatrix(vec3 axis, float angle)\n{\n\taxis = normalize(axis);\n\tfloat s = sin(angle);\n\tfloat c = cos(angle);\n\tfloat oc = 1.0 - c;\n\n\treturn mat4(oc * axis.x * axis.x + c, oc * axis.x * axis.y - axis.z * s, oc * axis.z * axis.x + axis.y * s, 0.0,\n\t\toc * axis.x * axis.y + axis.z * s, oc * axis.y * axis.y + c, oc * axis.y * axis.z - axis.x * s, 0.0,\n\t\toc * axis.z * axis.x - axis.y * s, oc * axis.y * axis.z + axis.x * s, oc * axis.z * axis.z + c, 0.0,\n\t\t0.0, 0.0, 0.0, 1.0);\n}\n\nvec3 rotate(vec3 v, vec3 axis, float angle)\n{\n\tmat4 m = rotationMatrix(axis, angle);\n\treturn (m * vec4(v, 1.0)).xyz;\n}\n\nfloat GetDist(vec3 p)\n{\n\tfloat dist = 99999999.;\n\n\tfor (int i = -5; i < 3; i++)\n\t{\n\t\tfloat s = pow(2., float(-i));\n\t\tvec3 p = vec3(mod(p.x, s), p.y, mod(p.z, s));\n\t\tvec3 c = vec3(0.5 * s, -2., 0.5 * s);\n\t\tvec3 b = vec3(0.1, 0.4, 0.1) * s;\n\t\tvec3 q = abs(p - c) - b;\n\t\tfloat d = length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n\t\tdist = min(dist, d);\n\t}\n\tdist = min(dist, p.y + 2.);\n\n\treturn dist;\n}\n\nfloat RayMarch(vec3 rayOrigin, vec3 rayDir)\n{\n\tfloat rayLength = 0.;\n\n\tfor (int marches = 0; marches < 500; marches++)\n\t{\n\t\tfloat dist = GetDist(rayOrigin + rayDir * rayLength);\n\t\trayLength += dist;\n\n\t\tif (rayLength > 100.)\n\t\t\treturn -1.;\n\t\telse if (dist < 0.01)\n\t\t\treturn rayLength;\n\t}\n\n\treturn -1.;\n}\n\nvec3 GetNormal(vec3 point)\n{\n\tfloat d = GetDist(point);\n\tvec2 e = vec2(0, 0.01);\n\treturn normalize(vec3(\n\t\td - GetDist(point - e.yxx),\n\t\td - GetDist(point - e.xyx),\n\t\td - GetDist(point - e.xxy)\n\t));\n}\n\nvec3 GetColor(vec3 camPos, vec3 lightDir, vec3 rayDir)\n{\n\tvec3 totalColor = vec3(0);\n\tfloat r = 1.;\n\tfor (int i = 0; i < 2; i++)\n\t{\n\t\t//calculate raymarch\n\t\tfloat rayMarch = RayMarch(camPos + rayDir * 0.02, rayDir);\n\t\tvec3 point = camPos + rayMarch * rayDir;\n\n\t\t//calculate lights\n\t\tvec3 color = buildingColor;\n\t\tvec3 normal = GetNormal(point);\n\t\tcolor *= lightColor * clamp(dot(-lightDir, normal), 0., 1.);\n\t\tcolor += lightColor * pow(max(dot(reflect(-lightDir, normal), rayDir), 0.), 32.);\n\t\tif (rayMarch == -1.)\n\t\t{\n\t\t\tcolor = mix(skyColor1, skyColor2, 1. - rayDir.y);\n\t\t\ttotalColor += color * r;\n\t\t\tr /= 5.;\n\t\t\tbreak;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcolor = mix(color, mix(skyColor1, skyColor2, 1. - rayDir.y), clamp(rayMarch / 100., 0., 1.));\n\t\t\ttotalColor += color * r;\n\t\t\tr /= 5.;\n\t\t}\n\t\tcamPos = point;\n\t\trayDir = reflect(rayDir, normal);\n\t}\n\n\treturn totalColor;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n\tvec3 rayDir = normalize(vec3(uv, 0.5));\n\tvec3 camPos = vec3(3., 0., iTime * 5.);\n\tvec3 lightDir = normalize(vec3(-5, -3, -1));\n\trayDir = rotate(rayDir, vec3(0., 1., 0.), sin(iTime) * 0.1 + 1.);\n    \n    uv = fragCoord.xy / iResolution.xy;\n    uv *=  1.0 - uv.yx;\n    float vig = uv.x*uv.y * 20.0;\n    vig = pow(vig, 0.25);\n\n    // Output to screen\n    fragColor = vec4(pow(GetColor(camPos, lightDir, rayDir) * vig, vec3(1.0/1.5)), 1.0);\n}\n// --------[ Original ShaderToy ends here ]---------- //\n\nvoid main(void)\n{\n    mainImage(gl_FragColor, gl_FragCoord.xy);\n}";
        ShaderList2.Blue = "#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#extension GL_OES_standard_derivatives : enable\n\n//2.3\n//OSCILADORES\n//Frecuencia y tiempo.\n//Taller de Livecoding con visuales en GLSL \n\n\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n\n//COMO EL NUMERO PI NO VIENE INCLUDO EN GLSL LO DEFINIMOS MANUALMENTE.\n//Utilizamos la estructura #define para definir constantes en el programa.\n#define PI 3.14159265359\n\nvoid main(void)\n{   \n\n    vec2 uv = gl_FragCoord.xy / resolution; //Obtengo las coordenadas UV(coordenadas cartesianas.\n    \n    vec2 p = vec2(.7) - uv; //Genero un punto en el espacio(en este caso en el medio.\n    float r = length(p);  //Obtengo el radio\n    float a = atan(p.x,p.y);//obtengo el angulo. \n\t\n\t\n    //Si a la funci\u00f3?enoidal le sumamos una variable. veremos que oscilara en relaci\u00f3?n esa variable. \n    //En este caso si le colocamos uv.x va a ir haciendo un constante degrade : \n    \n    \n    //Si a la frecuencia la multiplicamos por PI obtendremos exactamente ese numero de \"lineas\".\n    float freq = 20.3*PI; \n    \n    //float forma1 = sin(r*20-time)*0.5+0.5; //Degrade constante en X\n    //float forma2 = sin(uv.y*PI/time)*0.5+0.5; //Degrade constante en Y\n    float forma3 = sin(r*2.-time); //Degrade constante en X+Y\n    float forma4 = sin(a*10.+time+sin(r*5.5-time))*2.5+3.5; //As?e ve cuando una oscilaci\u00f3?s entre -1 y 1\n    \n    vec3 color1 = vec3(1.7,0.0,1.0) ; \n    vec3 color2 = vec3(0.0,0.0,1.0) ;\n\t\n    \n    vec3 cuentafinal = color1 * forma3 + color2 * forma4;      \n    gl_FragColor = vec4(vec3(cuentafinal),2.40); \n\n}";
        ShaderList2.Wolken = "#ifdef GL_ES\nprecision mediump float;\n#endif\n\n// glslsandbox uniforms\nuniform float time;\nuniform vec2 resolution;\n\n// shadertoy emulation\n#define iTime time\n#define iResolution resolution\n\n// --------[ Original ShaderToy begins here ]---------- //\nfloat random (in vec2 _st) {\n    return fract(sin(dot(_st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nfloat noise (in vec2 _st) {\n    vec2 i = floor(_st);\n    vec2 f = fract(_st);\n\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\nfloat fbm ( in vec2 _st) {\n    float v = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(100.0);\n    mat2 rot = mat2(cos(0.5), sin(0.5),\n                    -sin(0.5), cos(0.50));\n    for (int i = 0; i < 5; ++i) {\n        v += a * noise(_st);\n        _st = rot * _st * 2.0 + shift;\n        a *= 0.5;\n    }\n    return v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n\n    vec3 col = vec3(0.0);\n    \n    vec2 q = vec2(0.);\n    q.x = fbm( uv + 0.30*iTime);\n    q.y = fbm( uv + vec2(2.0));\n\n    vec2 r = vec2(0.);\n    r.x = fbm( uv + 1.0*q + vec2(1.7,9.2)+ 0.15*iTime );\n    r.y = fbm( uv + 1.0*q + vec2(8.3,2.8)+ 0.126*iTime);\n\n    float f = fbm(uv+r);\n\n    col = mix(vec3(0.101961,0.619608,0.666667),\n                vec3(0.666667,0.666667,0.498039),\n                clamp((f*f)*4.0,0.0,1.0));\n\n    col = mix(col,\n                vec3(0,0,0.164706),\n                clamp(length(q),0.0,1.0));\n\n    col = mix(col,\n                vec3(0.666667,1,1),\n                clamp(length(r.x),0.0,1.0));\n    \n    col = (f*f*f+.6*f*f+.5*f)*col;\n\n\n    fragColor = vec4(col,1.0);\n}\n// --------[ Original ShaderToy ends here ]---------- //\n\nvoid main(void)\n{\n    mainImage(gl_FragColor, gl_FragCoord.xy);\n}";
        ShaderList2.Floor = "/*\n * Original shader from: https://www.shadertoy.com/view/wlsfDH\n */\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n// glslsandbox uniforms\nuniform float time;\nuniform vec2 resolution;\n\n// shadertoy emulation\n#define iTime time\n#define iResolution resolution\n\n// --------[ Original ShaderToy begins here ]---------- //\nmat2 rot(float x) {\n    return mat2(cos(x), sin(x), -sin(x), cos(x));\n}\n\nfloat half_tile(vec2 p, float k) {\n    p.x -= 0.5;\n    vec2 a = abs(p);\n    float r1 = max(abs(p.x + 0.5), a.y) - 0.25;\n    float r2 = length(vec2(p.x + 0.5, a.y)) - 0.25;\n    float r = mix(r1, r2, k);\n    vec2 s = (vec2(p.x, a.y) + vec2(0.25, 0.0)) * rot(3.141592 * 0.25);\n    r = min(r, max(abs(s.x - 0.1) - 0.1, abs(s.y) - 0.01));\n    return r;\n}\n\nfloat inner_tile(vec2 p) {\n    p.x -= 0.5;\n    return 0.23 - max(abs(p.x + 0.5), abs(p.y));\n}\n\nfloat tile(vec2 p) {\n    p += vec2(0.5, -0.5);\n    vec2 a = abs(p);\n    float d = max(max(a.x, a.y) - 0.5, 0.48 - max(a.x, a.y));\n    p.x += 0.5;\n    p.y += 0.5;\n\td = min(d, half_tile(p, 0.0));\n    p.x -= 1.0;\n    p.y -= 1.0;\n    p.y = -p.y;\n    p.x = -p.x;\n    d = min(d, half_tile(p, 1.0));\n    return d;\n}\n\nfloat rep_tile(vec2 p) {\n\tfloat d = 1000.0;\n    d = min(d, tile(p));\n    p.x = - p.x;\n    p.y += 1.0;\n    d = min(d, tile(p));\n    return d;\n}\n\nfloat map(vec3 p) {\n\tvec3 a = abs(p);\n    float d = -max(a.x - 2.0, a.y - 1.0);\n    float az = (fract(p.z / 2.0) - 0.5) * 2.0;\n    d = min(d, max(abs(p.x - 1.0), abs(az - 0.25)) - 0.25);\n    d = min(d, max(abs(p.x + 1.0), abs(az + 0.25)) - 0.25);\n    float bz = (fract((p.z + 1.0) / 2.0) - 0.5) * 2.0;\n    d = min(d, max(abs(abs(p.y) - 1.0), abs(bz)) - 0.25);\n    return d;\n}\n\nvec3 normal(vec3 p)\n{\n\tvec3 o = vec3(0.0001, 0.0, 0.0);\n    return normalize(vec3(map(p+o.xyy) - map(p-o.xyy),\n                          map(p+o.yxy) - map(p-o.yxy),\n                          map(p+o.yyx) - map(p-o.yyx)));\n}\n\nfloat trace(vec3 o, vec3 r) {\n    float t = 0.0;\n    for (int i = 0; i < 64; ++i) {\n\t\tt += map(o + r * t) * 0.7;\n    }\n    return t;\n}\n\nfloat thetex(vec2 p, float t) {\n    p *= 4.0;\n    vec2 pa = p - vec2(floor(mod(t, 2.0)), floor(mod(t, 3.0)));\n    pa *= rot(3.141592 * 0.5 * floor(mod(t, 5.0)));\n    vec2 s = mod(floor((pa + vec2(0.0, 3.0)) / 3.0), 2.0) * 2.0 - 1.0;\n    pa = (fract(pa / 3.0) - 0.5) * 3.0;\n    pa *= s.yx;\n\tfloat d = rep_tile(pa);\n    d = min(d, abs(pa.x) - 0.02);\n    d = max(d, 0.0);\n    d = 1.0 / (1.0 + d * d * 10000.0);\n    return d;\n}\n\nfloat vectex(vec3 p, float t) {\n    float r = max(thetex(p.xy, t), thetex(p.xz, t + 1.0));\n    return max(r, thetex(p.yz, t + 2.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 r = normalize(vec3(uv, 1.0 - dot(uv, uv) * 0.2));\n    vec3 o = vec3(0.0, -0.1, 1.0 + iTime + sin(3.41592 * iTime) * 0.12);\n\n    float rt = clamp(fract(iTime), 0.0, 1.0);\n    float rtt = clamp(fract(iTime), 0.0, 1.0);\n    r.yz *= rot(sin(1.0 + iTime + sin(3.41592 * iTime) * 0.12) * 0.12);\n\n    float t = trace(o, r);\n    vec3 w = o + r * t;\n    vec3 n = normal(w);\n    float aoc = map(w + n * 0.3);\n\n    float gt = 0.0;\n\n    vec3 k = vec3(vectex(w, gt)) * vec3(1.0, 1.0, 0.5);\n    \n    vec3 col = vec3(0.0);\n    col += k * 3.0 + (1.0 - k) * vec3(0.0, 0.25, 0.25);\n    col += vec3(1.0, 0.0, 0.0) * abs(n.y);\n    col *= 1.0 / (1.0 + pow(t * 0.4, 4.0));\n    col *= mix(0.1, 1.0, aoc);\n    \n    fragColor = vec4(sqrt(col), 1.0);\n}\n\n// --------[ Original ShaderToy ends here ]---------- //\n\nvoid main(void)\n{\n    mainImage(gl_FragColor, gl_FragCoord.xy);\n}";
        ShaderList2.Crack = "#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#extension GL_OES_standard_derivatives : enable\n\nuniform vec2 resolution;\nuniform float time;\nuniform vec2 mouse;\n\n\n\n#define ITERATIONS 10.0\n\nvoid main() {\n\tvec2 p = \n\t\t(4.0 * gl_FragCoord.xy - resolution) / min(resolution.x, resolution.y)\n\t\t;\n\tp-=0.5;\n\tp.x = dot(p,p);\n\n\tfor(float i = 1.0; i < ITERATIONS; i++) {\n\t\tp.x += 0.5 / i * sin(i * 4.0*p.y+p.x+sin(time+p.y*3.0)) + 1.0 + (time * 0.5);\n\t\tp.y += i * cos(i * p.x)*.13;\n\t\t\tp.y += sin(p.y)*4.0+sin(dot(p,p)*0.1)*.1;\n\n\t}\n\n\tvec3 col;\n\tcol = vec3(sin(p.x), cos(length(p)*0.4+p.x + time), sin(sin(p.x*4.0-p.y+p.x)+p.x));\n\tgl_FragColor = vec4(col, 1.0);\n}\n";
        ShaderList2.Line = "#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#extension GL_OES_standard_derivatives : enable\n\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n\n// http://polycu.be/edit/?h=cpcFVB\n// http://www.pouet.net/topic.php?which=11100\n\n// #template shader\n\n// Signed distance to quadratic bezier with parametrization.\n// Tom'2017 \n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n// Based on:\n// Signed Distance to a Quadratic Bezier Curve\n// - Adam Simmons (@adamjsimmons) 2015\n// https://www.shadertoy.com/view/ltXSDB\n\n// Do we care about endpoints? 0 = no\n#define ENDPOINTS 0\n\n// Solve cubic equation for roots\nvec3 solveCubic(float a, float b, float c)\n{\n   float p = b - a*a / 3.0, p3 = p*p*p;\n   float q = a * (2.0*a*a - 9.0*b) / 27.0 + c;\n   float d = q*q + 4.0*p3 / 27.0;\n   float offset = -a / 3.0;\n   if(d >= 0.0) { \n      float z = sqrt(d);\n      vec2 x = (vec2(z, -z) - q) / 2.0;\n      vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n      return vec3(offset + uv.x + uv.y);\n   }\n   float v = acos(-sqrt(-27.0 / p3) * q / 2.0) / 3.0;\n   float m = cos(v), n = sin(v)*1.732050808;\n   return vec3(m + m, -n - m, n - m) * sqrt(-p / 3.0) + offset;\n}\n\n// Signed distance to quadratic bezier with parametrization.\n// Tom'2017\n// returns vec4( \n//  unsigned distance to clamped curve,\n//  signed distance to extended curve,\n//  extended t )\nvec3 sdBezier(vec2 A, vec2 B, vec2 C, vec2 p)\n{\n   B = mix(B + vec2(1e-4), B, abs(sign(B * 2.0 - A - C)));\n   vec2 a = B - A, b = A - B * 2.0 + C, c = a * 2.0, d = A - p;\n   vec3 k = vec3(3.*dot(a,b),2.*dot(a,a)+dot(d,b),dot(d,a)) / dot(b,b);\n\n   vec2 t = clamp(solveCubic(k.x, k.y, k.z).xy, 0.0, 1.0);\n   vec2 dp1 = d + (c + b*t.x)*t.x;\n   float d1 = dot(dp1, dp1);\n   vec2 dp2 = d + (c + b*t.y)*t.y;\n   float d2 = dot(dp2, dp2);\n\n   // note: 3rd root is actually never closest, we can just ignore it\n   \n#if ENDPOINTS == 1   \n   \n   // Find closest distance and t\n   vec2 r = (d1 < d2) ? vec2(d1, t.x) : vec2(d2, t.y);\n   \n   // Find on which side (t=0 or t=1) is extension\n   vec2 e = vec2(step(0.,-r.y),step(1.,r.y));\n\n   // Calc. gradient\n   vec2 g = 2.*b*r.y + c;\n   \n   // Calc. extension to t\n   float et = (e.x*dot(-d,g) + e.y*dot(p-C,g))/dot(g,g);\n   \n   // Find closest point on curve with extension\n   vec2 dp = d + (c + b*r.y)*r.y + et*g;\n   \n   // Sign is just cross product with gradient\n   float s =  sign(g.x*dp.y - g.y*dp.x);\n   \n   return vec3(sqrt(r.x), s*length(dp), r.y + et);\n   \n#else\n\n   // If we don't care about endpoint extension, it's simpler.\n   \n   vec4 r = (d1 < d2) ? vec4(d1, t.x, dp1) : vec4(d2, t.y, dp2);\n   \n   // Sign is just cross product with gradient\n   vec2 g = 2.*b*r.y + c;\n   float s =  sign(g.x*r.w - g.y*r.z);\n   \n   float dist = sqrt(r.x);\n   return vec3(dist, s*dist, r.y);\n\n#endif\n}\n\n\nvoid main( void ) {\n\t\t\n   const float sc = 2.;\n   vec2 p = (2.0*gl_FragCoord.xy-resolution.xy)*sc/resolution.y;\n//   vec2 m = mix((2.0*mouse.xy-resolution.xy)*sc/resolution.y,\n//      vec2(cos(time * 1.2) * 0.8, -0.6), step(mouse.z, 0.0)); wtf is mouse.z\n  vec2 m = 2.0*mouse - resolution / resolution.x;\n   \n   // Define the control points of our curve\n   vec2 A = vec2(0.0, -1.2), C = vec2(0.0, 0.0), B = (4.0 * m - A - C) / 2.0;\n   vec2 D = (2.0 * C - B), E = vec2(1.0, 1.4);\n   \n   // Render the control points\n   float d = distance(p, m);\n   if (d < 0.06) { gl_FragColor = vec4(1.0 - smoothstep(0.045, 0.054, d), 0,0,1); return; }\n   d = min(distance(p, B),distance(p, C));\n   d = min(distance(p, A),d);\n   d = min(distance(p, D),d);\n   d = min(distance(p, E),d);\n   if (d < 0.04) { gl_FragColor = vec4(1.0 - smoothstep(0.025, 0.034, d)); return; }\n   \n   // Get the signed distance with parametrization to closest bezier curve\n   // If second one is closer, add 1 to \"t\"\n   vec3 r1 = sdBezier(A, B, C, p);\n   vec3 r2 = sdBezier(C, D, E, p);\n   vec3 r = (r1.x < r2.x) ? r1 : vec3(r2.xy,r2.z+1.);\n   vec2 uv = r.yz;\n\n   // Visualize the distance field \n   // fragColor = texture2D(iChannel0, uv*3.)*(smoothstep(.31,.3,r.x)*.7+.3);\n   gl_FragColor = vec4((smoothstep(.11,.1,r.x)*.7+.3));\t\n}\n\n\n";
        ShaderList2.Street = "#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#extension GL_OES_standard_derivatives : enable\n\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n\n#define BUMPMAP\n#define MARCHSTEPS 128\n#define MARCHSTEPSREFLECTION 48\n#define LIGHTINTENSITY 5.\n\n//----------------------------------------------------------------------\n\nconst vec3 backgroundColor = vec3(0.2, 0.4, 0.6) * 0.09;\n\n//----------------------------------------------------------------------\n// noises\n\nfloat hash(float n) { return fract(sin(n) * 687.3123); }\n\nfloat noise(in vec2 x) {\n  vec2 p = floor(x);\n  vec2 f = fract(x);\n  f = f * f * (3.0 - 2.0 * f);\n  float n = p.x + p.y * 157.0;\n  return mix(mix(hash(n + 0.0), hash(n + 1.0), f.x),\n             mix(hash(n + 157.0), hash(n + 158.0), f.x), f.y);\n}\n\nconst mat2 m2 = mat2(0.80, -0.60, 0.60, 0.80);\n\nfloat fbm(vec2 p) {\n  float f = 0.0;\n  f += 0.5000 * noise(p);\n  p = m2 * p * 2.02;\n  f += 0.2500 * noise(p);\n  p = m2 * p * 2.03;\n  f += 0.1250 * noise(p);\n  p = m2 * p * 2.01;\n  //    f += 0.0625*noise( p );\n\n  return f / 0.9375;\n}\n\n//----------------------------------------------------------------------\n// distance primitives\n\nfloat udRoundBox(vec3 p, vec3 b, float r) {\n  return length(max(abs(p) - b, 0.0)) - r;\n}\n\nfloat sdBox(in vec3 p, in vec3 b) {\n  vec3 d = abs(p) - b;\n  return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdSphere(in vec3 p, in float s) { return length(p) - s; }\n\nfloat sdCylinder(in vec3 p, in vec2 h) {\n  vec2 d = abs(vec2(length(p.xz), p.y)) - h;\n  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\n//----------------------------------------------------------------------\n// distance operators\n\nfloat opU(float d2, float d1) { return min(d1, d2); }\nfloat opS(float d2, float d1) { return max(-d1, d2); }\nfloat smin(float a, float b, float k) {\n  return -log(exp(-k * a) + exp(-k * b)) / k;\n}  // from iq\n\n//----------------------------------------------------------------------\n// Map functions\n\nfloat mapCar(in vec3 p0) {\n  vec3 p = p0 + vec3(0.0, 1.24, 0.0);\n  float r = length(p.yz);\n  float d =\n      length(max(vec3(abs(p.x) - 0.35, r - 1.92, -p.y + 1.4), 0.0)) - 0.05;\n  d = max(d, p.z - 1.0);\n  p = p0 + vec3(0.0, -0.22, 0.39);\n  p.xz = abs(p.xz) - vec2(0.5300, 0.9600);\n  p.x = abs(p.x);\n  r = length(p.yz);\n  d = smin(d, length(max(vec3(p.x - 0.08, r - 0.25, -p.y - 0.08), 0.0)) - 0.04,\n           8.0);\n  d = max(d, -max(p.x - 0.165, r - 0.24));\n  float d2 = length(vec2(max(p.x - 0.13, 0.0), r - 0.2)) - 0.02;\n  d = min(d, d2);\n\n  return d;\n}\n\nfloat dL;  // minimal distance to light\n\nfloat map(const in vec3 p) {\n  vec3 pd = p;\n  float d;\n\n  pd.x = abs(pd.x);\n  pd.z *= -sign(p.x);\n\n  float ch = hash(floor((pd.z + 18. * time) / 40.));\n  float lh = hash(floor(pd.z / 13.));\n\n  vec3 pdm = vec3(pd.x, pd.y, mod(pd.z, 10.) - 5.);\n  dL = sdSphere(vec3(pdm.x - 8.1, pdm.y - 4.5, pdm.z), 0.1);\n\n  dL = opU(dL, sdBox(vec3(pdm.x - 12., pdm.y - 9.5 - lh, mod(pd.z, 91.) - 45.5),\n                     vec3(0.2, 4.5, 0.2)));\n  dL =\n      opU(dL, sdBox(vec3(pdm.x - 12., pdm.y - 11.5 + lh, mod(pd.z, 31.) - 15.5),\n                    vec3(0.22, 5.5, 0.2)));\n  dL = opU(dL, sdBox(vec3(pdm.x - 12., pdm.y - 8.5 - lh, mod(pd.z, 41.) - 20.5),\n                     vec3(0.24, 3.5, 0.2)));\n\n  if (lh > 0.5) {\n    dL = opU(dL,\n             sdBox(vec3(pdm.x - 12.5, pdm.y - 2.75 - lh, mod(pd.z, 13.) - 6.5),\n                   vec3(0.1, 0.25, 3.2)));\n  }\n\n  vec3 pm = vec3(mod(pd.x + floor(pd.z * 4.) * 0.25, 0.5) - 0.25, pd.y,\n                 mod(pd.z, 0.25) - 0.125);\n  d = udRoundBox(pm, vec3(0.245, 0.1, 0.12), 0.005);\n\n  d = opS(d, -(p.x + 8.));\n  d = opU(d, pd.y);\n\n  vec3 pdc = vec3(pd.x, pd.y, mod(pd.z + 18. * time, 40.) - 20.);\n\n  // car\n  if (ch > 0.15) {\n    pdc.x += (ch - 0.75) * 4.;\n    dL = opU(\n        dL, sdSphere(vec3(abs(pdc.x - 5.) - 1.05, pdc.y - 0.55, pdc.z), 0.025));\n    dL = opU(dL,\n             sdSphere(vec3(abs(pdc.x - 5.) - 1.2, pdc.y - 0.65, pdc.z + 6.05),\n                      0.025));\n\n    d = opU(d, mapCar((pdc - vec3(5., -0.025, -2.3)) * 0.45));\n  }\n\n  d = opU(d, 13. - pd.x);\n  d = opU(d, sdCylinder(vec3(pdm.x - 8.5, pdm.y, pdm.z), vec2(0.075, 4.5)));\n  d = opU(d, dL);\n\n  return d;\n}\n\n//----------------------------------------------------------------------\n\nvec3 calcNormalSimple(in vec3 pos) {\n  const vec2 e = vec2(1.0, -1.0) * 0.005;\n\n  vec3 n = normalize(e.xyy * map(pos + e.xyy) + e.yyx * map(pos + e.yyx) +\n                     e.yxy * map(pos + e.yxy) + e.xxx * map(pos + e.xxx));\n  return n;\n}\n\nvec3 calcNormal(in vec3 pos) {\n  vec3 n = calcNormalSimple(pos);\n  if (pos.y > 0.12) return n;\n\n#ifdef BUMPMAP\n  vec2 oc = floor(vec2(pos.x + floor(pos.z * 4.) * 0.25, pos.z) * vec2(2., 4.));\n\n  if (abs(pos.x) < 8.) {\n    oc = pos.xz;\n  }\n\n  vec3 p = pos * 250.;\n  vec3 xn = 0.05 * vec3(noise(p.xz) - 0.5, 0., noise(p.zx) - 0.5);\n  xn += 0.1 * vec3(fbm(oc.xy) - 0.5, 0., fbm(oc.yx) - 0.5);\n\n  n = normalize(xn + n);\n#endif\n\n  return n;\n}\n\nvec3 int1, int2, nor1;\nvec4 lint1, lint2;\n\nfloat intersect(in vec3 ro, in vec3 rd) {\n  const float precis = 0.001;\n  float h = precis * 2.0;\n  float t = 0.;\n  int1 = int2 = vec3(-500.);\n  lint1 = lint2 = vec4(-500.);\n  float mld = 100.;\n\n  for (int i = 0; i < MARCHSTEPS; i++) {\n    h = map(ro + rd * t);\n    if (dL < mld) {\n      mld = dL;\n      lint1.xyz = ro + rd * t;\n      lint1.w = abs(dL);\n    }\n    if (h < precis) {\n      int1.xyz = ro + rd * t;\n      break;\n    }\n    t += max(h, precis * 2.);\n  }\n\n  if (int1.z < -400. || t > 300.) {\n    float d = -(ro.y + 0.1) / rd.y;\n    if (d > 0.) {\n      int1.xyz = ro + rd * d;\n    } else {\n      return -1.;\n    }\n  }\n  ro = ro + rd * t;\n  nor1 = calcNormal(ro);\n  ro += 0.01 * nor1;\n  rd = reflect(rd, nor1);\n  t = 0.0;\n  h = precis * 2.0;\n  mld = 100.;\n  for (int i = 0; i < MARCHSTEPSREFLECTION; i++) {\n    h = map(ro + rd * t);\n    if (dL < mld) {\n      mld = dL;\n      lint2.xyz = ro + rd * t;\n      lint2.w = abs(dL);\n    }\n    if (h < precis) {\n      int2.xyz = ro + rd * t;\n      return 1.0;\n    }\n    t += max(h, precis * 2.0);\n  }\n  return 0.0;\n}\nvec3 shade(in vec3 ro, in vec3 pos, in vec3 nor) {\n  vec3 col = vec3(0.5);\n\n  if (abs(pos.x) > 15. || abs(pos.x) < 8.) col = vec3(0.02);\n  if (pos.y < 0.01) {\n    if (abs(int1.x) < 0.1) col = vec3(0.9);\n    if (abs(abs(int1.x) - 7.4) < 0.1) col = vec3(0.9);\n  }\n\n  float sh = clamp(dot(nor, normalize(vec3(-0.3, 0.3, -0.5))), 0., 1.);\n  col *= (sh * backgroundColor);\n\n  if (abs(pos.x) > 12.9 && pos.y > 9.) {  // windows\n    float ha = hash(133.1234 * floor(pos.y / 3.) + floor((pos.z) / 3.));\n    if (ha > 0.95) {\n      col = ((ha - 0.95) * 10.) * vec3(1., 0.7, 0.4);\n    }\n  }\n\n  col = mix(backgroundColor, col,\n            exp(min(max(0.1 * pos.y, 0.25) - 0.065 * distance(pos, ro), 0.)));\n\n  return col;\n}\n\nvec3 getLightColor(in vec3 pos) {\n  vec3 lcol = vec3(1., .7, .5);\n\n  vec3 pd = pos;\n  pd.x = abs(pd.x);\n  pd.z *= -sign(pos.x);\n\n  float ch = hash(floor((pd.z + 18. * time) / 40.));\n  vec3 pdc = vec3(pd.x, pd.y, mod(pd.z + 18. * time, 40.) - 20.);\n\n  if (ch > 0.75) {  // car\n    pdc.x += (ch - 0.75) * 4.;\n    if (sdSphere(vec3(abs(pdc.x - 5.) - 1.05, pdc.y - 0.55, pdc.z), 0.25) <\n        2.) {\n      lcol = vec3(1., 0.05, 0.01);\n    }\n  }\n  if (pd.y > 2. && abs(pd.x) > 10. && pd.y < 5.) {\n    float fl = floor(pd.z / 13.);\n    lcol = 0.4 * lcol + 0.5 * vec3(hash(.1562 + fl), hash(.423134 + fl), 0.);\n  }\n  if (abs(pd.x) > 10. && pd.y > 5.) {\n    float fl = floor(pd.z / 2.);\n    lcol = 0.5 * lcol +\n           0.5 * vec3(hash(.1562 + fl), hash(.923134 + fl), hash(.423134 + fl));\n  }\n\n  return lcol;\n}\n\nfloat randomStart(vec2 co) {\n  return 0.8 + 0.2 * hash(dot(co, vec2(123.42, 117.853)) * 412.453);\n}\n\nvoid main(void) {\n  vec2 q = gl_FragCoord.xy / resolution.xy;\n  vec2 p = -1.0 + 2.0 * q;\n  p.x *= resolution.x / resolution.y;\n\n  if (q.y < .12 || q.y >= .88) {\n    gl_FragColor = vec4(0., 0., 0., 1.);\n    return;\n  }\n\n  // camera\n  float z = time;\n  float x = -10.9 + 1. * sin(time * 0.2);\n  vec3 ro = vec3(x, 1.3, z - 1.);\n  vec3 ta = vec3(-8., 1.3 + .4 * cos(time * 0.26), z + 4. + cos(time * 0.04));\n\n  vec3 ww = normalize(ta - ro);\n  vec3 uu = normalize(cross(ww, vec3(0.0, 1.0, 0.0)));\n  vec3 vv = normalize(cross(uu, ww));\n  vec3 rd = normalize(-p.x * uu + p.y * vv + 2.2 * ww);\n\n  vec3 col = backgroundColor;\n\n  // raymarch\n  float ints = intersect(ro + randomStart(p) * rd, rd);\n  if (ints > -0.5) {\n    // calculate reflectance\n    float r = 0.09;\n    if (int1.y > 0.129)\n      r = 0.025 * hash(133.1234 * floor(int1.y / 3.) + floor(int1.z / 3.));\n    if (abs(int1.x) < 8.) {\n      if (int1.y < 0.01) {  // road\n        r = 0.007 * fbm(int1.xz);\n      } else {  // car\n        r = 0.02;\n      }\n    }\n    if (abs(int1.x) < 0.1) r *= 4.;\n    if (abs(abs(int1.x) - 7.4) < 0.1) r *= 4.;\n\n    r *= 2.;\n\n    col = shade(ro, int1.xyz, nor1);\n\n    if (ints > 0.5) {\n      col += r * shade(int1.xyz, int2.xyz, calcNormalSimple(int2.xyz));\n    }\n    if (lint2.w > 0.) {\n      col +=\n          (r * LIGHTINTENSITY * exp(-lint2.w * 7.0)) * getLightColor(lint2.xyz);\n    }\n  }\n\n  vec2 st =\n      256. * (p * vec2(.5, .01) + vec2(time * .13 - q.y * .6, time * .13));\n  float f = noise(st) * noise(st * 0.773) * 1.55;\n  f = 0.25 + clamp(pow(abs(f), 13.0) * 13.0, 0.0, q.y * .14);\n\n  if (lint1.w > 0.) {\n    col +=\n        (f * LIGHTINTENSITY * exp(-lint1.w * 7.0)) * getLightColor(lint1.xyz);\n  }\n\n  col += 0.25 * f * (0.2 + backgroundColor);\n  col = pow(clamp(col, 0.0, 1.0), vec3(0.4545));\n  col *= 1.2 * vec3(1., 0.99, 0.95);\n  col = clamp(1.06 * col - 0.03, 0., 1.);\n  q.y = (q.y - .12) * (1. / 0.76);\n  col *= 0.5 + 0.5 * pow(16.0 * q.x * q.y * (1.0 - q.x) * (1.0 - q.y), 0.1);\n\n  gl_FragColor = vec4(col, 1.0);\n}";
        ShaderList2.Sonne = "/*\n * Original shader from: https://www.shadertoy.com/view/tsfcWB\n */\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n// glslsandbox uniforms\nuniform float time;\nuniform vec2 resolution;\n\n// shadertoy emulation\n#define iTime time\n#define iResolution resolution\n\n// --------[ Original ShaderToy begins here ]---------- //\n#define MAX_STEPS 100\n#define FAR_DISTANCE 4.\n#define MIN_DISTANCE 0.0001\n#define SPEED .2\n#define SHOW_FRAME true\n#define SHOW_FULL_PLANET false\n#define PLANET_LAND_COLOR vec3(0.3, .3, .1)\n#define PLANET_OCEAN_COLOR vec3(0., 0., .5)\n#define PLANET_SNOW_COLOR vec3(.5, .2, .1)\n#define PLANET_CLOUD_COLOR vec3(1., 1., 1.) * .6\n#define PLANET_GLOW_COLOR vec3(0., 1.3, 2.8)\n#define SPACE_GLOW_COLOR vec3(0., 1.3, 2.8)\n#define PLANET_DEEP_COLOR vec3(0., 0., 0.3)\n#define PI 3.14\n#define SUN_COLOR vec3(0.9, .3, .1)\n#define ECLIPSE_COLOR vec3(0., 1., 0.)\n#define SECOND_SUN_COLOR vec3(0.5, 0.2, .90)\n\nstruct sEclipse {\n    vec3 color;\n    float d;\n    float shift;\n};\n\nfloat n21(vec2 p) {\n    return fract(sin(p.x*223.32+p.y*5677.)*4332.23);\n}\n\nfloat rand(vec2 n) {\n\treturn fract(sin(dot(n, vec2(12.9898 + .00019, 4.1414))) * 43759.5453);\n}\n\nfloat smoothNoise(vec2 uv) {\n    vec2 lv = smoothstep(0., 1., fract(uv));\n    vec2 id = floor(uv);\n\n    float bl = n21(id);\n    float br = n21(id + vec2(1.,0.));\n    float b = mix(bl, br, lv.x);\n\n    float tl = n21(id + vec2(0.,1.));\n    float tr = n21(id + vec2(1.,1.));\n    float t = mix(tl, tr, lv.x);\n\n    float n = mix(b, t, lv.y);\n    return n;\n}\n\nfloat noise(vec2 uv, int level) {\n    float n = 0.;\n    float d = 1.;\n    if (level > 0) {\n\t    n += smoothNoise(uv * 4.);\n    }\n    if (level > 1) {\n\t    n += smoothNoise(uv * 8.) * .5;\n        d += .5;\n    }\n    if (level > 2) {\n    \tn += smoothNoise(uv * 16.) * .25;\n        d += .25;\n    }\n    if (level > 3) {\n\t    n += smoothNoise(uv * 32.) * .125;\n        d += .125;\n    }\n    if (level > 4) {\n\t    n += smoothNoise(uv * 64.) * .025;\n        d += .0625;\n    }\n    return n / d;\n}\n\nfloat noise(vec2 p){\n    // p += iTime;\n\tvec2 ip = floor(p);\n\tvec2 u = fract(p);\n\tu = u*u*(3.0-2.0*u);\n\n\tfloat res = mix(\n\t\tmix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n\t\tmix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n\treturn res*res;\n}\n\nconst mat2 m2 = mat2(0.8,-0.6,0.6,0.8);\n\nfloat fbm2( in vec2 p ){\n    float f = 0.0;\n    f += 0.5000*noise( p); p = m2*p*2.02;\n    f += 0.2500*noise( p); p = m2*p*2.03;\n    f += 0.1250*noise( p); p = m2*p*2.01;\n    f += 0.0625*noise( p);\n\n    return f/0.9375;\n}\n\nvec3 getOceanTexture(vec2 uv) {\n    return fbm2(uv*4. * fbm2(uv*4. * fbm2(uv*2. + vec2(0., iTime/10.)) + iTime/10.)) * PLANET_OCEAN_COLOR * 5.;\n    // return PLANET_OCEAN_COLOR;\n}\n\n\nvec3 getPlanetTexture(vec2 uv) {\n    vec3 col = vec3(0.);\n    float size = 450.;\n\n    vec2 guv = uv;\n\n    uv *= size;\n\n    vec2 id = floor(uv);\n    uv = fract(uv);\n\n    // float n = noise(id/500. + vec2(-iTime/8.*SPEED, iTime/4.*SPEED), 5) * .6;\n    float n = fbm2(id/150. + vec2(-iTime/8.*SPEED, iTime/4.*SPEED));//* clamp(sin(iTime) * .5 + .5, .7, 1.);\n    n *= 1.3;\n    // n = fract(n * 1.);\n    float deep = smoothstep(.12, .13, n*.8);\n    float snow = smoothstep(0.57, 0.58, n);\n    float ocean = clamp(n-.1, 0., 1.);\n\n    vec3 oceanTexture = getOceanTexture(guv);\n\n    vec3 land = mix(oceanTexture, PLANET_LAND_COLOR, smoothstep(0.4, 0.41, n));\n\n    col += mix(\n        PLANET_SNOW_COLOR,\n        mix(land, land * 6., pow(abs(n - .35), .4))/2.5,\n        1. -snow\n    );\n\n    col = (1. - step(0.001, col)) * oceanTexture + col;\n\n    col = mix(PLANET_DEEP_COLOR, col, deep);\n\n    if (n < .4 && n > .12) {\n        col *= .6;\n    }\n\n    vec2 cuv = vec2(atan(guv.x*2., guv.y*4.), length(guv) ) ;\n    float aa = iTime/512.;\n    vec2 cid = floor((cuv*mat2(vec2(sin(aa), cos(aa)), vec2(-cos(aa), sin(aa))))*450.);\n\n    float cloudN = noise(cid/150. + iTime/16. * SPEED, 5);\n    vec3 cloudColor = PLANET_CLOUD_COLOR;\n\n    if (n < .12) {\n        cloudColor *= 1.1;\n        cloudColor.rb *= 1.2;\n    }\n\n\n    // col = vec3(0.);\n    col = mix(cloudColor, col, smoothstep(.2, .6 + sin(iTime/32. + cos(iTime*SPEED*cuv.x + sin(iTime/32.)))*.2, cloudN));\n    // col = oceanTexture;\n\n    return col;\n}\n\nsEclipse getEclipse(vec2 uv, vec2 center, float stage) {\n    vec3 col = vec3(0.);\n\n    float size = .1;\n\n    vec2 moonPosition = vec2(stage * size * 2. + sin(iTime*.0)*.1, 0.) + center;\n    vec2 sunPosition = vec2(0., 0.) + center;\n\n    float moonD = length(uv - moonPosition);\n    float sunD = length(uv - sunPosition);\n\n    float shift = length(moonPosition - sunPosition);\n\n\n    vec3 sun_color = mix(ECLIPSE_COLOR, SUN_COLOR, pow(shift/.2, .3));\n\n    float a = atan(uv.x - center.x, uv.y - center.y)*1.;\n\n    float n = fbm2((vec2(sin(a), cos(a)) + iTime/12.) * mix(.5, 3.5, shift/.2)) * clamp(mix(1., 3.5, shift/.2), 1., 2.);\n\n    float sunSize = size + clamp(n*(.2*(1. - pow(shift/.08, .3))), 0., 10.);\n\n    vec3 sun = pow(sunSize/sunD, 11. - clamp((shift * 30.), 0., 10.)) * sun_color;\n\n    vec3 moon = step(moonD, size * .98) * vec3(.0);\n\n    col = mix(moon, sun, smoothstep(size*.9, size, moonD));\n    sEclipse res;\n    res.color = col;\n    res.d = sunD;\n    res.shift = shift;\n    return res;\n}\n\nvec3 getStars(vec2 guv) {\n    float a = iTime / 50.;\n    guv -= .2;\n    guv *= mat2(vec2(sin(a), cos(a)), vec2(-cos(a), sin(a)));\n    guv += .2;\n    guv *= 15.;\n    vec2 uv = fract(guv) - .5;\n    vec2 id = floor(guv);\n    vec3 col = vec3(0.);\n\n    for(int x = -1 ; x <= 1 ; x++) {\n        for(int y = -1 ; y <= 1; y++) {\n            vec2 offset = vec2(x,y);\n            vec2 cid = id + offset;\n            float n = n21(cid);\n            vec2 shift = vec2(n, fract(n * 123.43))-.5;\n            float d = length(uv - offset - shift);\n            if (fract(n * 5543.234) > .8) {\n                col = max(col, smoothstep(.1, .9, (.005 + .02 * fract(n*32342.22))/d)) * (.7 + 0.3 * fract(n*4443322.33));\n            }\n        }\n    }\n\n\n    return col;\n}\n\nvec3 getSecondSun(vec2 uv) {\n    vec3 col = vec3(0.);\n\n    float d = pow(.1/length(uv), 1.9) * .3;\n\n    col += d;\n\n    return col * SECOND_SUN_COLOR;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoords) {\n    vec2 uv = fragCoords / iResolution.xy;\n    uv -= .5;\n    uv.x *= iResolution.x / iResolution.y;\n\n    vec2 guv = uv;\n\n    float wobble = sin(iTime + cos(iTime/2.))*.005;\n\n    if (!SHOW_FULL_PLANET) {\n        uv.y += 1.35 + wobble;\n    }\n\n\n    vec3 col = vec3(0.0);\n\n    float a = 2.5;\n    vec3 ro = vec3(0. + sin(a), 0.+cos(a), -1);\n    vec3 lookat = vec3(0.05, .0, 0.);\n\n    float zoom = 22.;\n\n    if (SHOW_FULL_PLANET) {\n         zoom = 4.;\n         ro = vec3(0., 0., -1);\n         lookat = vec3(0.);\n    }\n\n    vec3 f = normalize(lookat - ro);\n    vec3 r = normalize(cross(vec3(0., 1., 0), f));\n    vec3 u = cross(f, r);\n    vec3 c = ro + f * zoom;\n\n    vec3 i = c + uv.x*r + uv.y*u;\n    vec3 rd = normalize(i - ro);\n\n    vec3 p = vec3(0., 0., 0.);\n\n    float d = length(cross(rd, p - ro))/length(rd);\n\n    vec3 ds = vec3(0.), dt = vec3(0.);\n    float sd = 0.;\n    int steps = 0;\n\n    for(int i = 0 ; i < MAX_STEPS ; i++) {\n        p = ro + rd * ds;\n        steps += 1;\n\n        sd = length(p) - .0999;\n\n        ds += sd;\n\n        if (sd < MIN_DISTANCE || sd > FAR_DISTANCE) {\n            break;\n        }\n    }\n\n    vec3 globe = vec3(0.);\n    vec2 wuv = guv + vec2(0., wobble);\n\n    sEclipse eclipse = getEclipse(wuv * 2., vec2(-0.6, .65), 1. - sin(iTime/10.));\n\n    vec3 spaceGlowColor = mix(PLANET_GLOW_COLOR, vec3(SUN_COLOR), eclipse.shift / .1);\n\n    if (sd < MIN_DISTANCE) {\n        float x = acos(p.y/length(p));\n        float y = atan(p.z, p.x);\n        vec2 uv = vec2(x, y);\n        globe += smoothstep(.0, 1., clamp(float(steps)/40., 0., 1.))* .3 * spaceGlowColor * .8;\n        globe += getPlanetTexture(uv);\n    } else {\n\n        if (!SHOW_FULL_PLANET) {\n            col += eclipse.color;\n            col += getStars(wuv) * clamp(eclipse.d*2., 0., 1.);\n            col += getSecondSun(wuv + vec2(-0.4, .1));\n        }\n    }\n\n    float glowMask = 1. - mix(smoothstep(.20, .02, d*1.5), .0, step(d, .1)) * .8;\n    float planetGlowMask = (1. - smoothstep(.1, .11, d*1.07))*smoothstep(.1, .11, d*1.02)*3.;\n\n    globe += (1. - glowMask) * mix(PLANET_GLOW_COLOR, spaceGlowColor, eclipse.shift / .4) + (planetGlowMask * PLANET_GLOW_COLOR);\n\n    col += globe;\n\n    if (SHOW_FRAME) {\n        d = length(guv);\n        col *= step(d, .7);\n        vec3 frame = (step(d, .71) - step(d, .70)) * vec3(.8);\n        col += frame;\n    }\n\n    fragColor = vec4(col, 1.);\n\n}\n// --------[ Original ShaderToy ends here ]---------- //\n\nvoid main(void)\n{\n    mainImage(gl_FragColor, gl_FragCoord.xy);\n}";
        ShaderList2.Darkblue = "\n#ifdef GL_ES\nprecision mediump float;\n#endif\n#extension GL_OES_standard_derivatives : enable\n\n#define PI2 6.28318530718\n#define MAX_ITER 5\n\nuniform float time;\nuniform vec2 resolution;\nuniform float spectrum;\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = time * .12;\n    vec2 uv = fragCoord.xy / resolution.xy;\n\n    vec2 p = mod(uv * PI2, PI2) - 100.0  ;\n    vec2 i = vec2(p);\n    float c = 0.5;\n    float inten =  .0094;\n\n    for (int n = 0; n < MAX_ITER; n++) {\n        float t = time * (4.5 - (2.2 / float(n + 122)));\n        i = p + vec2(cos(t - i.x) + sin(t + i.y), sin(t - i.y) + cos(t + i.x));\n        c += 1.0 / length(vec2(p.x / (sin(i.x + t) / inten + spectrum), p.y / (cos(i.y + t) / inten)));\n    }\n\n    c /= float(MAX_ITER);\n    c = 1.10-pow(c, 1.26);\n    vec3 colour = vec3(0.098, 0.098, .098+pow(abs(c), 4.1));\n\n    fragColor = vec4(colour, 1.3);\n}\n\n\nvoid main( void ) {\n    mainImage(gl_FragColor, gl_FragCoord.xy);\n}";
        ShaderList2.Test8 = "/*\n * Original shader from: https://www.shadertoy.com/view/tsfcWB\n */\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n// glslsandbox uniforms\nuniform float time;\nuniform vec2 resolution;\n\n// shadertoy emulation\n#define iTime time\n#define iResolution resolution\n\n// --------[ Original ShaderToy begins here ]---------- //\n#define MAX_STEPS 100\n#define FAR_DISTANCE 4.\n#define MIN_DISTANCE 0.0001\n#define SPEED .2\n#define SHOW_FRAME true\n#define SHOW_FULL_PLANET false\n#define PLANET_LAND_COLOR vec3(0.3, .3, .1)\n#define PLANET_OCEAN_COLOR vec3(0., 0., .5)\n#define PLANET_SNOW_COLOR vec3(.5, .2, .1)\n#define PLANET_CLOUD_COLOR vec3(1., 1., 1.) * .6\n#define PLANET_GLOW_COLOR vec3(0., 1.3, 2.8)\n#define SPACE_GLOW_COLOR vec3(0., 1.3, 2.8)\n#define PLANET_DEEP_COLOR vec3(0., 0., 0.3)\n#define PI 3.14\n#define SUN_COLOR vec3(0.9, .3, .1)\n#define ECLIPSE_COLOR vec3(0., 1., 0.)\n#define SECOND_SUN_COLOR vec3(0.5, 0.2, .90)\n\nstruct sEclipse {\n    vec3 color;\n    float d;\n    float shift;\n};\n\nfloat n21(vec2 p) {\n    return fract(sin(p.x*223.32+p.y*5677.)*4332.23);\n}\n\nfloat rand(vec2 n) {\n\treturn fract(sin(dot(n, vec2(12.9898 + .00019, 4.1414))) * 43759.5453);\n}\n\nfloat smoothNoise(vec2 uv) {\n    vec2 lv = smoothstep(0., 1.4, fract(uv));\n    vec2 id = floor(uv);\n\n    float bl = n21(id);\n    float br = n21(id + vec2(3.4,0.7));\n    float b = mix(bl, br, lv.x);\n\n    float tl = n21(id + vec2(0.,1.));\n    float tr = n21(id + vec2(1.,1.));\n    float t = mix(tl, tr, lv.x);\n\n    float n = mix(b, t, lv.y);\n    return n;\n}\n\nfloat noise(vec2 uv, int level) {\n    float n = 0.6;\n    float d = 1.1;\n    if (level > 0) {\n\t    n += smoothNoise(uv * 4.);\n    }\n    if (level > 1) {\n\t    n += smoothNoise(uv * 8.) * .5;\n        d += .5;\n    }\n    if (level > 2) {\n    \tn += smoothNoise(uv * 16.) * .25;\n        d += .25;\n    }\n    if (level > 3) {\n\t    n += smoothNoise(uv * 32.) * .125;\n        d += .125;\n    }\n    if (level > 4) {\n\t    n += smoothNoise(uv * 64.) * .025;\n        d += .0625;\n    }\n    return n / d;\n}\n\nfloat noise(vec2 p){\n    // p += iTime;\n\tvec2 ip = floor(p);\n\tvec2 u = fract(p);\n\tu = u*u*(4.0-2.0*u);\n\n\tfloat res = mix(\n\t\tmix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n\t\tmix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n\treturn res*res;\n}\n\nconst mat2 m2 = mat2(0.8,-0.6,0.6,0.8);\n\nfloat fbm2( in vec2 p ){\n    float f = 0.0;\n    f += 0.5000*noise( p); p = m2*p*2.02;\n    f += 0.2500*noise( p); p = m2*p*2.03;\n    f += 0.1250*noise( p); p = m2*p*2.01;\n    f += 0.0625*noise( p);\n\n    return f/0.9375;\n}\n\nvec3 getOceanTexture(vec2 uv) {\n    return fbm2(uv*4. * fbm2(uv*4. * fbm2(uv*2. + vec2(0., iTime/10.)) + iTime/10.)) * PLANET_OCEAN_COLOR * 5.;\n    // return PLANET_OCEAN_COLOR;\n}\n\n\nvec3 getPlanetTexture(vec2 uv) {\n    vec3 col = vec3(0.);\n    float size = 450.;\n\n    vec2 guv = uv;\n\n    uv *= size;\n\n    vec2 id = floor(uv);\n    uv = fract(uv);\n\n    // float n = noise(id/500. + vec2(-iTime/8.*SPEED, iTime/4.*SPEED), 5) * .6;\n    float n = fbm2(id/150. + vec2(-iTime/8.*SPEED, iTime/4.*SPEED));//* clamp(sin(iTime) * .5 + .5, .7, 1.);\n    n *= 1.3;\n    // n = fract(n * 1.);\n    float deep = smoothstep(.12, .13, n*.8);\n    float snow = smoothstep(0.57, 0.58, n);\n    float ocean = clamp(n-.1, 0., 1.);\n\n    vec3 oceanTexture = getOceanTexture(guv);\n\n    vec3 land = mix(oceanTexture, PLANET_LAND_COLOR, smoothstep(0.4, 0.41, n));\n\n    col += mix(\n        PLANET_SNOW_COLOR,\n        mix(land, land * 6., pow(abs(n - .35), .4))/2.5,\n        1. -snow\n    );\n\n    col = (1. - step(0.001, col)) * oceanTexture + col;\n\n    col = mix(PLANET_DEEP_COLOR, col, deep);\n\n    if (n < .4 && n > .12) {\n        col *= .6;\n    }\n\n    vec2 cuv = vec2(atan(guv.x*2., guv.y*4.), length(guv) ) ;\n    float aa = iTime/512.;\n    vec2 cid = floor((cuv*mat2(vec2(sin(aa), cos(aa)), vec2(-cos(aa), sin(aa))))*450.);\n\n    float cloudN = noise(cid/150. + iTime/16. * SPEED, 5);\n    vec3 cloudColor = PLANET_CLOUD_COLOR;\n\n    if (n < .12) {\n        cloudColor *= 1.1;\n        cloudColor.rb *= 1.2;\n    }\n\n\n    // col = vec3(0.);\n    col = mix(cloudColor, col, smoothstep(.2, .6 + sin(iTime/32. + cos(iTime*SPEED*cuv.x + sin(iTime/32.)))*.2, cloudN));\n    // col = oceanTexture;\n\n    return col;\n}\n\nsEclipse getEclipse(vec2 uv, vec2 center, float stage) {\n    vec3 col = vec3(0.);\n\n    float size = .1;\n\n    vec2 moonPosition = vec2(stage * size * 2. + sin(iTime*.0)*.1, 0.) + center;\n    vec2 sunPosition = vec2(0., 0.) + center;\n\n    float moonD = length(uv - moonPosition);\n    float sunD = length(uv - sunPosition);\n\n    float shift = length(moonPosition - sunPosition);\n\n\n    vec3 sun_color = mix(ECLIPSE_COLOR, SUN_COLOR, pow(shift/.2, .3));\n\n    float a = atan(uv.x - center.x, uv.y - center.y)*1.;\n\n    float n = fbm2((vec2(sin(a), cos(a)) + iTime/12.) * mix(.5, 3.5, shift/.2)) * clamp(mix(1., 3.5, shift/.2), 1., 2.);\n\n    float sunSize = size + clamp(n*(.2*(1. - pow(shift/.08, .3))), 0., 10.);\n\n    vec3 sun = pow(sunSize/sunD, 11. - clamp((shift * 30.), 0., 10.)) * sun_color;\n\n    vec3 moon = step(moonD, size * .98) * vec3(.0);\n\n    col = mix(moon, sun, smoothstep(size*.9, size, moonD));\n    sEclipse res;\n    res.color = col;\n    res.d = sunD;\n    res.shift = shift;\n    return res;\n}\n\nvec3 getStars(vec2 guv) {\n    float a = iTime / 50.;\n    guv -= .2;\n    guv *= mat2(vec2(sin(a), cos(a)), vec2(-cos(a), sin(a)));\n    guv += .2;\n    guv *= 15.;\n    vec2 uv = fract(guv) - .5;\n    vec2 id = floor(guv);\n    vec3 col = vec3(0.);\n\n    for(int x = -1 ; x <= 1 ; x++) {\n        for(int y = -1 ; y <= 1; y++) {\n            vec2 offset = vec2(x,y);\n            vec2 cid = id + offset;\n            float n = n21(cid);\n            vec2 shift = vec2(n, fract(n * 123.43))-.5;\n            float d = length(uv - offset - shift);\n            if (fract(n * 5543.234) > .8) {\n                col = max(col, smoothstep(.1, .9, (.005 + .02 * fract(n*32342.22))/d)) * (.7 + 0.3 * fract(n*4443322.33));\n            }\n        }\n    }\n\n\n    return col;\n}\n\nvec3 getSecondSun(vec2 uv) {\n    vec3 col = vec3(0.);\n\n    float d = pow(.1/length(uv), 1.9) * .3;\n\n    col += d;\n\n    return col * SECOND_SUN_COLOR;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoords) {\n    vec2 uv = fragCoords / iResolution.xy;\n    uv -= .5;\n    uv.x *= iResolution.x / iResolution.y;\n\n    vec2 guv = uv;\n\n    float wobble = sin(iTime + cos(iTime/2.))*.005;\n\n    if (!SHOW_FULL_PLANET) {\n        uv.y += 1.35 + wobble;\n    }\n\n\n    vec3 col = vec3(0.0);\n\n    float a = 2.5;\n    vec3 ro = vec3(0. + sin(a), 0.+cos(a), -1);\n    vec3 lookat = vec3(0.05, .0, 0.);\n\n    float zoom = 22.;\n\n    if (SHOW_FULL_PLANET) {\n         zoom = 4.;\n         ro = vec3(0., 0., -1);\n         lookat = vec3(0.);\n    }\n\n    vec3 f = normalize(lookat - ro);\n    vec3 r = normalize(cross(vec3(0., 1., 0), f));\n    vec3 u = cross(f, r);\n    vec3 c = ro + f * zoom;\n\n    vec3 i = c + uv.x*r + uv.y*u;\n    vec3 rd = normalize(i - ro);\n\n    vec3 p = vec3(0., 0., 0.);\n\n    float d = length(cross(rd, p - ro))/length(rd);\n\n    vec3 ds = vec3(0.), dt = vec3(0.);\n    float sd = 0.;\n    int steps = 0;\n\n    for(int i = 0 ; i < MAX_STEPS ; i++) {\n        p = ro + rd * ds;\n        steps += 1;\n\n        sd = length(p) - .0999;\n\n        ds += sd;\n\n        if (sd < MIN_DISTANCE || sd > FAR_DISTANCE) {\n            break;\n        }\n    }\n\n    vec3 globe = vec3(0.);\n    vec2 wuv = guv + vec2(0., wobble);\n\n    sEclipse eclipse = getEclipse(wuv * 2., vec2(-0.6, .65), 1. - sin(iTime/10.));\n\n    vec3 spaceGlowColor = mix(PLANET_GLOW_COLOR, vec3(SUN_COLOR), eclipse.shift / .1);\n\n    if (sd < MIN_DISTANCE) {\n        float x = acos(p.y/length(p));\n        float y = atan(p.z, p.x);\n        vec2 uv = vec2(x, y);\n        globe += smoothstep(.0, 1., clamp(float(steps)/40., 0., 1.))* .3 * spaceGlowColor * .8;\n        globe += getPlanetTexture(uv);\n    } else {\n\n        if (!SHOW_FULL_PLANET) {\n            col += eclipse.color;\n            col += getStars(wuv) * clamp(eclipse.d*2., 0., 1.);\n            col += getSecondSun(wuv + vec2(-0.4, .1));\n        }\n    }\n\n    float glowMask = 1. - mix(smoothstep(.20, .02, d*1.5), .0, step(d, .1)) * .8;\n    float planetGlowMask = (1. - smoothstep(.1, .11, d*1.07))*smoothstep(.1, .11, d*1.02)*3.;\n\n    globe += (1. - glowMask) * mix(PLANET_GLOW_COLOR, spaceGlowColor, eclipse.shift / .4) + (planetGlowMask * PLANET_GLOW_COLOR);\n\n    col += globe;\n\n    if (SHOW_FRAME) {\n        d = length(guv);\n        col *= step(d, .7);\n        vec3 frame = (step(d, .71) - step(d, .70)) * vec3(.8);\n        col += frame;\n    }\n\n    fragColor = vec4(col, 1.);\n\n}\n// --------[ Original ShaderToy ends here ]---------- //\n\nvoid main(void)\n{\n    mainImage(gl_FragColor, gl_FragCoord.xy);\n}";
        ShaderList2.Greentown = "/*\n * Original shader from: https://www.shadertoy.com/view/tdjczK\n */\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n// glslsandbox uniforms\nuniform float time;\nuniform vec2 resolution;\n\n// shadertoy emulation\n#define iTime time\n#define iResolution resolution\nconst vec4 iMouse = vec4(0.);\n\n// Emulate some GLSL ES 3.x\n#define round(x) (floor((x) + 0.5))\n\n// --------[ Original ShaderToy begins here ]---------- //\n#define CAMERA_RANGE 8.\n#define CAMERA_TIME_SCALE .1\n#define SHOW_CARS true\n#define COLOR_WINDOW vec3(1., .9, .45)\n#define COLOR_WINDOW_TINT vec3(0.9, .3, .1)\n#define COLOR_BUILDING_BASE vec3(0.3,.5, .1)\n#define COLOR_ROAD_DELIMETER vec3(0.87, .72, .14)\n#define COLOR_ROAD vec3(0.1)\n#define COLOR_ROAD_SIDEWALK vec3(.7)\n#define COLOR_CAR_ROOF vec3(.3)\n#define MAX_STEPS 256\n#define MIN_DISTANCE 0.0001\n#define MAX_DISTANCE 10.\n#define defaultBaseSize .3\n#define defaultBaseSpacing 2.5\n#define bounds vec3(7.0, 7.0, 0.)\n#define BLD_RECT 1.\n#define BLD_HEX 2.\n#define BLD_TUBE 4.\n#define OBJ_FLOOR 3.\n#define OBJ_CAMERA 5.\n#define OBJ_DOME 6.\n#define OBJ_CAR 7.\n#define BULDING_BASE_SIZE .4\n#define PI 3.14\n\nvec2 mouse = vec2(0.);\n\nfloat CELL_SIZE = (defaultBaseSize + defaultBaseSpacing/2.);\nfloat HALF_CELL_SIZE = 0.;\n\nstruct Camera {\n    float z;\n    float x;\n    float y;\n    float verticalAngle;\n    float horizontalAngle;\n    float rotation;\n};\n\nCamera camera = Camera(0., 0., 0., 0., 0., 0.);\n\nbool isScripted = true;\n\n// #iUniform float my_scalar = 1.0 in { 0.0, 5.0 } // This will expose a slider to edit the value\n\n\n\nstruct DistBuilding {\n    float d;\n    vec3 size;\n    float height;\n    vec3 q1;\n    float objId;\n};\n\nstruct DistResult {\n    float d;\n    vec3 id;\n    vec3 q1;\n    vec3 p;\n    float h;\n    float obj;\n    DistBuilding building;\n    DistBuilding cars;\n};\n\nstruct TraceResult {\n    vec3 id;\n    float dt;\n    float ds;\n    float h;\n    vec3 p;\n    vec3 q1;\n    DistResult dist;\n    float obj;\n};\n\n\n\n\nfloat hexDist(vec2 uv) {\n    uv = abs(uv);\n    return max(uv.x, dot(uv, normalize(vec2(1., 1.73))));\n}\n\n\nmat2 rot2d(float a) {\n    float ca = cos(a);\n    float sa = sin(a);\n    return mat2(vec2(sa, ca), vec2(-ca, sa));\n}\n\nfloat n21(vec2 n) {\n    return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat smoothNoise(vec2 uv) {\n    vec2 lv = smoothstep(0., 1., fract(uv));\n    vec2 id = floor(uv);\n\n    float bl = n21(id);\n    float br = n21(id + vec2(1.,0.));\n    float b = mix(bl, br, lv.x);\n\n    float tl = n21(id + vec2(0.,1.));\n    float tr = n21(id + vec2(1.,1.));\n    float t = mix(tl, tr, lv.x);\n\n    float n = mix(b, t, lv.y);\n    return n;\n}\n\nfloat noise(vec2 uv, int level) {\n    float n = 0.;\n    float d = 1.;\n    if (level > 0) {\n\t    n += smoothNoise(uv * 4.);\n    }\n    if (level > 1) {\n\t    n += smoothNoise(uv * 8.) * .5;\n        d += .5;\n    }\n    if (level > 2) {\n    \tn += smoothNoise(uv * 16.) * .25;\n        d += .25;\n    }\n    if (level > 3) {\n\t    n += smoothNoise(uv * 32.) * .125;\n        d += .125;\n    }\n    if (level > 4) {\n\t    n += smoothNoise(uv * 64.) * .025;\n        d += .0625;\n    }\n    return n / d;\n}\n\nvec3 getColorById(vec3 id) {\n    float n = max(.2, n21(vec2(id.x, id.y)));\n    vec3 rcol = vec3(n, fract(n*567.433), fract(n*1689.33));\n    return rcol;\n}\n\nvec3 withMouse(vec3 p) {\n        vec2 mouse = iMouse.xy/iResolution.xy;\n        float a = max(mouse.y, .505) * 3.14 * 2.;\n        p.yz *= rot2d(a);\n        float aa = mouse.x * 3.14 * 2.;\n        p.xy *= rot2d(aa);\n        return p;\n}\n\nvec3 setSceneAngle(vec3 p) {\n    vec2 mouse = iMouse.xy/iResolution.xy;\n    p.yz *= rot2d(PI);\n    p.xy *= rot2d(camera.horizontalAngle);\n    p.x += HALF_CELL_SIZE;\n    p.y += HALF_CELL_SIZE;\n    // p.xy -= .77;\n    p += vec3(camera.x, camera.y, camera.z);\n    return p;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n  const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n  p = abs(p);\n  p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n  vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nDistBuilding distBuilding(vec3 q1, vec3 id) {\n    DistBuilding res;\n    float n = n21(id.xy);\n    float n1 = fract(n*4553.33);\n    float n2 = fract(n*145.33);\n\n    float obj = BLD_RECT;\n\n    if (n1 > .7) {\n        obj = BLD_HEX;\n    } else if (n2 > .8) {\n        obj = BLD_TUBE;\n    }\n\n    float baseSize = defaultBaseSize;\n\n    float h = baseSize;\n\n    if (obj == BLD_TUBE && n1 < .2 ) {\n        n = (sin(q1.x + (n1*50.)) * .5 + .5);\n    }\n\n    float ah = n * .5;\n\n    h += ah;\n    q1.z -= ah;\n    q1.z -= defaultBaseSize;\n\n    float d = 0.;\n\n\n\n    vec3 size = vec3(baseSize, baseSize, h);\n\n    if (obj == BLD_HEX) {\n        d = sdHexPrism(q1, vec2(size.x, size.z));\n    } else if (obj == BLD_TUBE) {\n        float tmp = q1.z;\n        q1.z = q1.y;\n        q1.y = tmp;\n        d = sdCappedCylinder(q1, baseSize, size.z);\n    } else {\n        if (n1 > .3) {\n            size.x *= .5;\n            size.y *= 1.5;\n        } else if (n2 > .5) {\n            size.y *= .5;\n            size.x *= 1.5;\n        }\n\n        if (n < .6) {\n            vec3 q2,nsize, nsize3, q3, d3;\n            if (n2 < .2 && size.x == size.y) {\n                d = sdBox(q1, size);\n                q2 = vec3(q1.x, q1.y, q1.z - size.z);\n                nsize = vec3(size.xy/1.5, size.z*2.);\n                q3 = vec3(q1.x, q1.y, q1.z - size.z - size.z / 1.8);\n                nsize3 = vec3(size.xy/(1.5*1.5), size.z*2. + size.z / 1.8);\n            } else {\n                q1 += vec3(0.1, -0.08, 0.);\n                d = sdBox(q1, size);\n                float extraH = size.z + size.z * n1;\n                q2 = vec3(q1.x - .18, q1.y + .18, q1.z - extraH);\n                nsize = vec3(size.xy, size.z + extraH);\n                if (n1 > .4) {\n                    nsize.xy = nsize.yx;\n                }\n            }\n\n            float d2 = sdBox(q2, nsize);\n            if (d2 < d) {\n                q1 = q2;\n                size = nsize;\n                d = d2;\n            }\n\n            if (nsize3.x != 0.) {\n                float d3 = sdBox(q3, nsize3);\n                if (d3 < d) {\n                    q1 = q3;\n                    size = nsize3;\n                    d = d3;\n                }\n            }\n\n        } else {\n            d = sdBox(q1, size);\n        }\n    }\n\n    res.d = d;\n    res.q1 = q1;\n    res.size = size;\n    res.objId = obj;\n    res.height = size.z;\n\n    return res;\n}\n\nDistBuilding distCars(vec3 po) {\n    DistBuilding res;\n\n\n    float carSize = .02;\n\n    po -= vec3(vec2(HALF_CELL_SIZE), carSize / 2.);\n\n    vec3 baseSpacing = vec3(CELL_SIZE);\n    vec3 rc1 = vec3(baseSpacing);\n    vec3 direction = vec3(-1, 0., 0.);\n\n    float t = iTime * 2.;\n\n    vec3 p = po;\n\n    p.x -= t;\n\n    vec3 id = round(p/rc1);\n    if (mod(id.y, 2.) == 0.) {\n        p = po;\n        p.x += t;\n        id = round(p/rc1);\n        direction.x = 1.;\n    }\n    float n = n21(id.xy);\n\n    vec3 q1 = p - rc1*vec3(id.xy, 0.);\n\n    q1.x -= (sin(iTime*7. * n)*.5 + .5)*HALF_CELL_SIZE;\n    q1.y -= (n - .5)/6.;\n\n    float d = sdBox(q1, vec3(carSize*2., carSize, carSize));\n\n    p = po;\n\n    p.y -= t;\n    vec3 direction2 = vec3(0., -1., 0.);\n\n    id = round(p/rc1);\n    if (mod(id.x , 2.) == 0.) {\n        p = po;\n        p.y += t;\n        id = round(p/rc1);\n        direction2.y = 1.;\n    }\n    n = n21(id.xy);\n\n    q1 = p - rc1*vec3(id.xy, 0.);\n\n    q1.y -= (sin(iTime*5. * n)*.5 + .5)*HALF_CELL_SIZE; //(n - .5)/CELL_SIZE;\n    q1.x -= (n - .5)/6.;\n\n    float d1 = sdBox(q1, vec3(carSize, carSize * 2., carSize));\n\n    res.d = min(d, d1);\n    res.q1 = d1 > d ? direction : direction2;\n    return res;\n}\n\n\nDistResult getDist(vec3 p) {\n    vec3 baseSpacing = vec3(defaultBaseSize + defaultBaseSpacing/2.);\n\n    vec3 l = bounds;\n    vec3 rc1 = vec3(baseSpacing);\n\n    vec3 id = round(p/rc1);\n\n    vec3 q1 = p - rc1 * clamp(id, -l, l);\n\n    DistBuilding building = distBuilding(q1, id);\n\n    float d = building.d;\n    float obj = building.objId;\n    q1 = building.q1;\n\n    // d = 1000000.;\n    float floord = p.z;\n\n    if (floord < d) {\n        obj = OBJ_FLOOR;\n    }\n\n    d = min(d, floord);\n\n    float skyD = -(length(p) - 30.);\n\n    if (skyD < d) {\n        obj = OBJ_DOME;\n        d = skyD;\n    }\n    DistBuilding cars;\n    if (SHOW_CARS) {\n        cars = distCars(p);\n        if (cars.d < d) {\n            d = cars.d;\n            obj = OBJ_CAR;\n        }\n    }\n\n    // if (!isScripted) {\n    //     vec3 cameraQ = vec3(-p.x + HALF_CELL_SIZE, -p.y + HALF_CELL_SIZE, p.z-.3) + vec3(camera.x, camera.y, camera.z);\n    //     cameraQ.xy *= rot2d(-camera.horizontalAngle);\n    //     float cd = sdBox(cameraQ, vec3(.1, .2, .1));\n    //     if (cd < d) {\n    //         p = cameraQ;\n    //         obj = OBJ_CAMERA;\n    //     }\n\n    //     d = min(d, cd);\n    // }\n\n\n    DistResult r;\n    r.d = d;\n    r.id = id;\n    r.q1 = q1;\n    r.building = building;\n    r.cars = cars;\n    r.p = p;\n    r.obj = obj;\n    return r;\n}\n\nTraceResult trace(vec3 ro, vec3 rd) {\n    float ds = 0.,dt;\n    float n;\n    vec3 id, shift;\n    vec3 p;\n    vec3 q1;\n\n    DistResult dist;\n\n\n    for(int i = 0 ; i < MAX_STEPS ; i++) {\n        p = ro + rd * ds;\n\n        if (isScripted) {\n            p = setSceneAngle(p);\n        } else {\n            p = withMouse(p);\n        }\n\n        dist = getDist(p);\n\n        dt = dist.d;\n        id = dist.id;\n        q1 = dist.q1;\n\n        ds += dt * .4;\n\n        if (abs(dt) < MIN_DISTANCE || dt > MAX_DISTANCE) {\n            break;\n        }\n    }\n\n    TraceResult res;\n\n    res.id = id;\n    res.dt = dt;\n    res.ds = ds;\n    res.p = p;\n    res.q1 = q1;\n    res.obj = dist.obj;\n    res.dist = dist;\n\n    return res;\n}\n\nvec3 getNormal(vec3 p, float d) {\n    vec2 e = vec2(0.00001, 0.);\n    vec3 n = d - vec3(\n        getDist(p - e.xyy).d,\n        getDist(p - e.yxy).d,\n        getDist(p - e.yyx).d\n    );\n    return normalize(n);\n}\n\n\nvec3 getCubeUV(vec3 p, vec3 normal, vec3 fsize) {\n    vec2 cuv = vec2(0.);\n    vec2 size = fsize.yz;\n    if (normal.z != 0.) {\n        // roof\n        cuv.xy = vec2(p.x, p.y);\n        size = fsize.xy;\n        // size.y = size.x;\n    }\n    if (normal.x != 0.) {\n        cuv.xy = vec2(p.y, p.z);\n        size = fsize.yz;\n    }\n    if (normal.y != 0.) {\n        cuv = vec2(p.x, p.z);\n        size = fsize.xz;\n    }\n\n    cuv /= size*2.;\n\n    cuv += vec2(.5, .5);\n\n    float r = size.x / size.y;\n\n    cuv -= vec2((r-1.)*.03, 0.);\n\n    cuv.x *= r;\n\n    return vec3(cuv, r);\n}\n\nvec2 getTubeUV(vec3 p, vec3 normal, vec2 size) {\n    float x = atan(p.x, p.z) / 6.28;\n    float y = p.y/size.y;\n\n    vec2 cuv = vec2(x, y);\n    if (normal.z != 0.) {\n        cuv = p.xz / size.x;\n    }\n    return cuv;\n}\n\nvec2 getHexUV(vec3 p, vec3 normal, vec2 size) {\n\n    float x = atan(p.x, p.y) / 6.28;\n    float y = p.z/size.y;\n\n    vec2 cuv = vec2(x, y);\n\n    if (normal.z != 0.) {\n        cuv = p.xy / size.x;\n    }\n\n    cuv += vec2(.5, .5);\n\n    return cuv;\n}\n\nvec4 allWindowsSkyscraperTexture(vec3 p, vec2 uv, vec3 normal, vec3 bid, float xr, float obj, float w, vec3 size) {\n    vec3 col = vec3(0.15);\n    vec2 wuv = uv;\n\n    float frameWidth = .03;\n\n    float frame = 0.;\n\n    float fogMultiplier = 0.;\n\n    if (obj == BLD_RECT) {\n        if (normal.z == 0.) {\n            frame = step(uv.x, frameWidth) +  step((1. - frameWidth) * xr, uv.x) + step((1. - frameWidth), uv.y);\n            frame += step(uv.y, frameWidth);\n        } else {\n            if (size.x > size.y) {\n                frame = step(uv.x, frameWidth - .15) +  step((.95 - frameWidth) * xr, uv.x) + step((1. - frameWidth), uv.y);\n            } else {\n                frame = step(uv.x, frameWidth) +  step((1. - frameWidth) * xr, uv.x) + step((1. - frameWidth), uv.y);\n            }\n            frame += step(uv.y, frameWidth);\n        }\n        uv *= 40. * w / xr;\n    } else if (obj == BLD_HEX) {\n        vec2 huv = uv;\n        if (normal.z == 0.) {\n            frame = step(fract(huv.x*6. + .53), .1);\n            frame += step(1.46, huv.y);\n        } else {\n            frame = step(1. - frameWidth * 2., hexDist((uv - .5)*rot2d(3.14)));\n        }\n        float scaleY = 20. * defaultBaseSize / xr;\n        uv *= vec2(scaleY*(6.*xr), scaleY);\n    } else if (obj == BLD_TUBE) {\n        vec2 huv = uv;\n        if (normal.z != 0.) {\n            float hl = length(huv);\n            frame = step(hl, 1.1) - step(hl, 1. - frameWidth * 2.);\n        } else {\n            frame = step(1. - frameWidth * 2., huv.y);\n        }\n        float scaleY = 20. * defaultBaseSize / xr;\n        uv *= vec2(scaleY*(6.*xr), scaleY);\n    }\n\n    col += frame;\n\n    if (normal.z == 0. && frame == 0.) {\n\n        float bn = fract(n21(bid.xy)*567.85);\n        float distToBuilding = distance(bid*CELL_SIZE, vec3(camera.x, camera.y, camera.z));\n\n        bool isLight = bn > .6 && distToBuilding > 6. ? true : false;\n        col = vec3(0.);\n        vec2 id = floor(uv);\n        uv = fract(uv);\n        float n = n21(id + bid.xy + 22.*floor(normal.xy));\n        float borders = (step(uv.x, .3) + step(uv.y, .3));\n        if (!isLight && n > .7 && abs(sin(bid.x + bid.y + fract(n*23422.)*110. + iTime/50.)) > fract(n*123.22)) {\n            col += COLOR_WINDOW * (1. - borders);\n            col += borders * COLOR_WINDOW_TINT;\n            fogMultiplier = .3;\n        } else {\n            if (borders != 0.) {\n                col = vec3(0.2);\n                if (isLight) {\n                    vec2 lights = vec2(sin(wuv.x + iTime + fract(bn * 3322.)*10.), sin(wuv.y + iTime + fract(bn * 3322.)*10.));\n                    if (bn > .85) {\n                        col.rb += lights;\n                    } else {\n                        col.rg += lights;\n                    }\n                }\n            }\n        }\n\n    }\n\n    return vec4(col, fogMultiplier);\n}\n\nvec3 domeTexture(vec3 p) {\n    vec3 q1 = p;\n    q1.yz *= rot2d(PI);\n    p = q1;\n    vec3 col = vec3(.01);\n    float x = acos(p.y/length(p));\n    float y = atan(p.z, p.x) / 6.28;\n    vec2 uv = vec2(x, y) + .5;\n\n    float rize = .1 + sin(iTime/6.)*.1;\n\n    vec2 muv = uv*vec2(1., 5.);\n    vec2 id = floor(muv);\n    muv = fract(muv) - .5;\n    muv += vec2(rize, 0.);\n\n    bool isMoon = false;\n\n    if (id.y == 2.) {\n        float muvl = length(muv);\n        float ml = muvl * 1.5;\n        vec3 mc = step(ml, .1) * vec3(noise(5. + muv*4. + iTime/50., 5));\n        if (ml > .1) {\n            mc += pow(.05 / muvl, 6.0);\n        }\n        if (ml < .15) {\n            isMoon = true;\n        }\n        col += mc * vec3(.9, .6, .1);\n    }\n\n    vec2 suv = uv * vec2(30., 150.);\n    vec2 sid = floor(suv);\n    suv = fract(suv) - .5;\n\n    float n = n21(sid);\n    if (n > .7 && !isMoon) {\n        col += step(length(suv + vec2(fract(n*3432.33) - .5, fract(n*78953.2) - .5)), .04*fract(n*123.123));\n    }\n\n    return col;\n}\n\nvec4 floorTexture(vec3 p, vec3 q1) {\n    vec3 col = vec3(0.);\n\n    float fogMultiplier = 0.;\n\n    vec2 uv = mod((p.xy - HALF_CELL_SIZE), CELL_SIZE) / CELL_SIZE - .5;\n    vec2 roadUV = mod((p.xy), CELL_SIZE) / CELL_SIZE;\n    vec2 blockID = floor(p.xy / CELL_SIZE);\n\n    if (abs(blockID.x) > bounds.x || abs(blockID.y) > bounds.y) {\n        return vec4(COLOR_BUILDING_BASE, fogMultiplier);\n    }\n\n    float roadX = step(BULDING_BASE_SIZE, roadUV.x) - step(1. - BULDING_BASE_SIZE, roadUV.x);\n    float roadY = step(BULDING_BASE_SIZE, roadUV.y) - step(1. - BULDING_BASE_SIZE, roadUV.y);\n\n    float road = max(roadX, roadY);\n\n\n    col += road * COLOR_ROAD;\n\n    // col.rg = roadUV;\n    // col.rg = uv;\n\n    vec2 baseUV = abs(uv);\n    col += step(max(baseUV.x, baseUV.y), BULDING_BASE_SIZE*.9) * COLOR_BUILDING_BASE;\n\n    uv = fract((uv + .26)*8.);\n\n    if (roadX == 0.) {\n        uv.x /= 4.;\n    }\n    if (roadY == 0.) {\n        uv.y /= 4.;\n    }\n\n    float delimeter = step(max(uv.x, uv.y), .1) * road;\n\n    fogMultiplier = delimeter * 1.5;\n\n    col += delimeter * COLOR_ROAD_DELIMETER;\n\n    if (col.x == 0.) {\n        col = COLOR_ROAD_SIDEWALK;\n    }\n\n    vec2 zebraUV = roadUV * 12.;\n    vec2 zebraID = floor(zebraUV);\n    zebraUV = fract(zebraUV);\n\n    float n = n21(blockID);\n\n    if (zebraID.x == 3. && road > 0. && n > .7) {\n        col += step(fract((zebraUV - .08)*vec2(1., 3.)).y + .1, .4);\n    }\n    if (zebraID.y == 3. && road > 0. && fract(n*123.33) > .7) {\n        col += step(fract((zebraUV - .08)*vec2(3., 1.)).x + .1, .4);\n    }\n\n    return vec4(col, fogMultiplier);\n}\n\nvec3 carTexture(TraceResult tr, vec3 normal) {\n    vec3 col = vec3(0.);\n    vec3 dir = tr.dist.cars.q1;\n\n    if (normal.y > 0. && dir.x == 0.) {\n        if (dir.y > 0.) {\n            col.r += 1.;\n        } else {\n            col.rgb += 1.;\n        }\n    } else\n    if (normal.y < 0. && dir.x == 0.) {\n        if (dir.y < 0.) {\n            col.r += 1.;\n        } else {\n            col.rgb += 1.;\n        }\n    } else\n\n    if (normal.x > 0. && dir.y == 0.) {\n        if (dir.x > 0.) {\n            col.r += 1.;\n        } else {\n            col.rgb += 1.;\n        }\n    } else\n    if (normal.x < 0. && dir.y == 0.) {\n        if (dir.x < 0.) {\n            col.r += 1.;\n        } else {\n            col.rgb += 1.;\n        }\n    } else {\n        col = COLOR_CAR_ROOF;\n    }\n\n    return col;\n}\n\nvec4 getBuildingTexture(TraceResult tr, vec3 normal) {\n    vec3 col = vec3(0.);\n\n    vec3 id = tr.id;\n    float objId = tr.obj;\n\n    vec3 p = tr.p;\n\n    float baseSize = normal.x == 0. ? tr.dist.building.size.x : tr.dist.building.size.y;\n\n    vec2 size = vec2(baseSize, tr.dist.building.height);\n\n    vec3 cubeUV = getCubeUV(tr.q1, normal, tr.dist.building.size);\n    vec2 uv = cubeUV.xy;\n\n    if (objId == BLD_HEX) {\n        uv = getHexUV(tr.q1, normal, size);\n    }\n    if (objId == BLD_TUBE) {\n        uv = getTubeUV(tr.q1, normal, size);\n    }\n\n    vec4 tc = allWindowsSkyscraperTexture(p, uv, normal, id, cubeUV.z, tr.obj, baseSize, tr.dist.building.size);\n\n    col += tc.rgb;\n\n    return vec4(col, tc.w);\n}\n\nvec2 getCameraIterationPosition(float iteration) {\n    if (iteration == 0.) {\n        return vec2(0.);\n    }\n    float n = n21(vec2(iteration));\n\n    float m = CAMERA_RANGE;\n    return round(vec2((n - .5) * m, (fract(n*113.43) - .5) * m));\n}\n\nvec3 cameraNextPosition() {\n    float t = iTime * CAMERA_TIME_SCALE;\n\n    vec2 center = vec2(.0);\n\n    float iterationDuration = 1.;\n\n    float iteration = floor(t / iterationDuration) + 1.;\n    float stepSize = 1.;\n\n    float cellStepSize = CELL_SIZE*stepSize;\n\n    vec2 prevPosition = getCameraIterationPosition(iteration - 1.)*cellStepSize;\n    vec2 nextPosition = getCameraIterationPosition(iteration)*cellStepSize;\n\n\n    float iterationTime = mod(t, iterationDuration) / iterationDuration;\n\n    float iterationSteps = 2.;\n    float stepDuration = iterationDuration / iterationSteps;\n    float iterationStep = floor(iterationTime / stepDuration) + 1.;\n\n    float iterationStepTime = mod(iterationTime, stepDuration) / stepDuration;\n\n    vec2 f = (nextPosition - prevPosition) * vec2(iterationStepTime);\n\n    if (iterationStep == 1.) {\n        f.y = 0.;\n    } else if (iterationStep == 2.) {\n        prevPosition.x = nextPosition.x;\n        f.x = 0.;\n    }\n\n\n    center = prevPosition + f;\n\n    return vec3(center, iteration*2. - iterationStep);\n}\n\nvoid scriptCamera() {\n    float t = iTime / 18.;\n\n    vec3 nextPosition = cameraNextPosition();\n\n    camera.x = nextPosition.x;\n    camera.y = nextPosition.y;\n\n    camera.z = .5 - cos(iTime/2.) * .5;\n\n    float verticalA = 1.0;\n    float horizA = 0.;\n    horizA = sin(t*8.);\n\n    verticalA = 1. - (sin(t*8.)*.02 + .01);\n\n    camera.rotation = sin(iTime) * PI/64.;\n\n    float n = n21(vec2(nextPosition.z + 13.));\n\n    float topDown = step(.2, n);\n\n    horizA  *= topDown;\n    verticalA *= topDown;\n    camera.z -= (topDown - 1.) * n/2.;\n\n    if (length(mouse.xy - .5) > .1) {\n        horizA = PI * mouse.x;\n        verticalA = PI/3. * mouse.y;\n    }\n\n    camera.horizontalAngle = horizA;\n    camera.verticalAngle = verticalA;\n}\n\nvoid setupCamera() {\n    camera.x = 0.;\n    camera.y = 0.;\n    camera.z = 0.;\n    camera.rotation = 0.;\n    scriptCamera();\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoords) {\n\n    HALF_CELL_SIZE = CELL_SIZE / 2.;\n\n    mouse = iMouse.xy/iResolution.xy;\n    if (mouse.x == 0. || mouse.y == 0.) {\n        mouse += .5;\n    }\n    isScripted = true; //!isKeyDown(Key_Shift);\n\n    setupCamera();\n\n    vec2 uv = ((fragCoords.xy / iResolution.xy) - .5) * vec2(iResolution.x / iResolution.y, 1.);\n\n    vec3 col = vec3(.0);\n\n    float a = 0.;\n\n    vec3 ro = vec3(0., 1. , 0.1);\n    vec3 lookat = vec3(0., 1.*camera.verticalAngle, 0.);\n\n    if (!isScripted) {\n        ro = vec3(0., 0. , -4.);\n        lookat = vec3(0., 0., 0.);\n    }\n\n    float zoom = .9;\n    vec3 up = vec3(0., 1., 0.);\n    up.xy *= rot2d(PI / 2. + camera.rotation);\n\n    vec3 f = normalize(lookat - ro);\n    vec3 r = normalize(cross(up, f));\n    vec3 u = cross(f, r);\n\n    vec3 c = ro + f * zoom;\n    vec3 I = c + uv.x * r + uv.y * u;\n\n    vec3 rd = normalize(I - ro);\n\n    TraceResult tr = trace(ro, rd);\n    float fogMultiplier = 0.;\n\n    if (tr.dt < MIN_DISTANCE) {\n        float objId = tr.obj;\n\n        vec3 normal;\n\n        if (objId == OBJ_FLOOR) {\n            vec4 fc = floorTexture(tr.p, tr.q1);\n            col += fc.rgb;\n            normal = vec3(0., -1., 0.);\n            fogMultiplier = fc.w;\n        } else if (objId == OBJ_CAMERA) {\n            col += mix(vec3(0., 0., 1.), vec3(1., 0., 0.), (.7 + tr.dist.p.y*10.));\n        } else if (objId == OBJ_DOME) {\n            col += domeTexture(tr.p);\n        } else if (objId == OBJ_CAR) {\n            normal = getNormal(tr.p, tr.dt);\n            col += carTexture(tr, normal);\n            fogMultiplier = 2.;\n        } else {\n            normal = getNormal(tr.p, tr.dt);\n            vec4 bt = getBuildingTexture(tr, normal);\n            col += bt.rgb;\n            fogMultiplier = bt.w;\n        }\n\n    }\n\n    float d = length(tr.p - vec3(camera.x, camera.y, camera.z))/(1. + camera.z/8.);\n    float fog = (2.2) - d/1.8;\n\n    fragColor = vec4(min(vec3(1.), col), 1.);\n    if (tr.obj != OBJ_DOME) {\n        if (fogMultiplier != 0.) {\n             fragColor *= fog > -fogMultiplier ?  (1. - (fog < 0. ? abs(fog)/fogMultiplier : 0.)) : fog;\n        } else {\n            fragColor *= fog;\n        }\n\n    }\n}\n// --------[ Original ShaderToy ends here ]---------- //\n\nvoid main(void)\n{\n    mainImage(gl_FragColor, gl_FragCoord.xy);\n}";
        ShaderList2.Whitewuerfel = "/*\n * Original shader from: https://www.shadertoy.com/view/3d2BRW\n */\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n// glslsandbox uniforms\nuniform float time;\nuniform vec2 resolution;\n\n// shadertoy emulation\n#define iTime time\n#define iResolution resolution\n\n// Emulate some GLSL ES 3.x\n#define round(x) (floor((x) + 0.5))\n\n// --------[ Original ShaderToy begins here ]---------- //\n// Ayquo 2020\n// RayMarching starting point - https://www.shadertoy.com/view/WtGXDD\n\n#define MAX_STEPS 100\n#define MAX_DIST 400.\n#define SURF_DIST .001\n#define ZOOM_LAYERS 4.\n#define BASE_COLOR vec3(.2, .1, .5)\n#define CUBE_OFFSET_COUNT 26\n\nmat2 rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s*.5;\n    return length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\n// Create multiple copies of an object - http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nvec3 opRepLim( in vec3 p, in float s, in vec3 lima, in vec3 limb )\n{\n    return p-s*clamp(round(p/s),lima,limb);\n}\n\nfloat getDistCubes(vec3 p, float layer, float scale, float tx) {\n    vec3 dim = vec3(scale);\n    float f = (1.+tx+layer)*scale;\n    vec3 pr = opRepLim(p, f, vec3(-1.), vec3(1.));    \n\treturn max(sdBox(pr, dim), -sdBox(p, dim*1.1));\n}\n\nfloat getDist(vec3 p, float tx) {\n    float dim = mix(1., 3., tx);\n    float r = sdBox(p, vec3(dim));\n    for (float layer=0.; layer<ZOOM_LAYERS; layer+=1.)\n    {    \n        r = min(r, getDistCubes(p, layer, dim*pow(3., layer), tx));\n    }    \n    return r;\n}\n\nfloat rayMarch(vec3 ro, vec3 rd, float tx) {\n    float dO=0.;    \n    vec3 p;\n    float dS;\n    for(int i=0; i<MAX_STEPS; i++) \n    {\n        p = ro + rd*dO;\n        dS = getDist(p, tx);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }    \n    return dO;\n}\n\nvec3 getNormal(vec3 p, float tx) {\n    float d = getDist(p, tx);\n    vec2 e = vec2(.001, 0);    \n    vec3 n = d - vec3(\n        getDist(p-e.xyy, tx),\n        getDist(p-e.yxy, tx),\n        getDist(p-e.yyx, tx)\n    );    \n    return normalize(n);\n}\n\nvec3 getRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n\tr = normalize(cross(vec3(0,1,0), f)),\n    u = cross(f,r),\n    c = p+f*z,\n    i = c + uv.x*r + uv.y*u,\n    d = normalize(i-p);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime*.25;\n    float tm = mod(t, 1.);\n    // Weighted average of linear and squared time, for smooth transitions\n    float tx = (tm*tm*2.+tm*3.)/5.;\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;   \n    vec3 cp = vec3(9., 6, -3);\n    cp.xy *= rot(t/2.);\n    vec3 cd = getRayDir(uv, cp, vec3(0), 1.);\n    float d = rayMarch(cp, cd, tx);    \n    vec3 col = BASE_COLOR;    \n    if(d<MAX_DIST) {\n        vec3 p = cp + cd * d;\n        vec3 n = getNormal(p, tx);        \n        float dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n        col += dif;  \n    }\n\n    // Fog\n    col *= clamp(exp( -0.0008 * d * d * d ), 0.02, 1.); // Near\n    col *= clamp(exp( -0.00008 * d * d), 0.02, 1.); // Far\n    \n    // Gamma correction\n    col = pow(col, vec3(.4545));    \n   \n    fragColor = vec4(col,1.0);\n}\n// --------[ Original ShaderToy ends here ]---------- //\n\nvoid main(void)\n{\n    mainImage(gl_FragColor, gl_FragCoord.xy);\n}";
        ShaderList2.GalaxyGurtel = "/*\n * Original shader from: https://www.shadertoy.com/view/wsBBWD\n */\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n// glslsandbox uniforms\nuniform float time;\nuniform vec2 resolution;\n\n// shadertoy emulation\n#define iTime time\n#define iResolution resolution\n\n// Emulate some GLSL ES 3.x\nfloat tanh(float x) {\n    float ex = exp(2.0 * x);\n    return ((ex - 1.) / (ex + 1.));\n}\n\n// --------[ Original ShaderToy begins here ]---------- //\n// License CC0: Spiral galaxy\n//  Would benefit from anti-aliasing but looks okish when I run it in fullscreen in FF\n//  Lots of random coding and little thought so the code is kind of messy\n#define PI  3.141592654\n#define TAU (2.0*PI)\n\n#define TIME (iTime*0.1)\n\n#define LESS(a,b,c) mix(a,b,step(0.,c))\n\n#define SABS(x,k)    LESS((.5/k)*x*x+k*.5,abs(x),abs(x)-k)\n\n#define RESOLUTION   iResolution\n\nconst float twirly =2.5;\n\nvec2 toPolar(vec2 p) {\n  return vec2(length(p), atan(p.y, p.x));\n}\n\nvec2 toRect(vec2 p) {\n  return p.x*vec2(cos(p.y), sin(p.y));\n}\n\nvec2 mod2(inout vec2 p, vec2 size) {\n  vec2 c = floor((p + size*0.5)/size);\n  p = mod(p + size*0.5,size) - size*0.5;\n  return c;\n}\n\nfloat noise1(vec2 p) {\n  float s = 1.0;\n\n  p *= tanh(0.1*length(p));\n  float tm = TIME;\n\n  float a = cos(p.x);\n  float b = cos(p.y);\n\n  float c = cos(p.x*sqrt(3.5)+tm);\n  float d = cos(p.y*sqrt(1.5)+tm);\n\n  return a*b*c*d;\n}\n\nvoid rot(inout vec2 p, float a) {\n  float c = cos(a);\n  float s = sin(a);\n  p = vec2(c*p.x + s*p.y, -s*p.x + c*p.y);\n}\n\nvec2 twirl(vec2 p, float a, float z) {\n  vec2 pp = toPolar(p);\n  pp.y += pp.x*twirly + a;\n  p = toRect(pp);\n  \n  p *= z;\n  \n  return p;\n}\n\nfloat galaxy(vec2 p, float a, float z) {\n  p = twirl(p, a, z);\n  \n  return noise1(p);\n}\n\nfloat rand(vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n\nvec2 raySphere(vec3 ro, vec3 rd, vec3 center, float radius)\n{\n    //get the vector from the center of this circle to where the ray begins.\n    vec3 m = ro - center.xyz;\n\n    //get the dot product of the above vector and the ray's vector\n    float b = dot(m, rd);\n\n    float c = dot(m, m) - radius*radius;\n\n    //exit if r's origin outside s (c > 0) and r pointing away from s (b > 0)\n    if(c > 0.0 && b > 0.0) return vec2(-1.0, -1.0);\n\n    //calculate discriminant\n    float discr = b * b - c;\n\n    //a negative discriminant corresponds to ray missing sphere\n    if(discr < 0.0) return vec2(-1.0);\n\n    //ray now found to intersect sphere, compute smallest t value of intersection\n    float normalMultiplier = 1.0;\n    float s = sqrt(discr);\n    float t0 = -b - s;\n    float t1 = -b + s;;\n    \n    // return the time t that the collision happened, as well as the surface normal\n    return vec2(t0, t1);\n}\n\n\nvec3 stars(vec2 p) {\n  float l = length(p);\n\n  vec2 pp = toPolar(p);\n  pp.x /= (1.0+length(pp.x))*0.5;\n  p = toRect(pp);\n\n  float sz = 0.0075;\n  \n  vec3 s = vec3(10000.0);\n    \n  for (int i = 0; i < 3; ++i) {  \n    rot(p, 0.5);\n    vec2 ip = p;\n    vec2 n = mod2(ip, vec2(sz));\n    float r = rand(n);\n    vec2 o = -1.0 + 2.0*vec2(r, fract(r*1000.0));\n    s.x = min(s.x, length(ip-0.25*sz*o));\n    s.yz = n*0.1;\n  }\n  \n  return s;\n}\n\nfloat height(vec2 p) {\n  float ang = atan(p.y, p.x);\n  float l = length(p);\n  float sp = mix(1.0, pow(0.75 + 0.25*sin(2.0*(ang + l*twirly)), 3.0), tanh(6.0*l));\n  float s = 0.0;\n  float a = 1.0;\n  float f = 15.0;\n  float d = 0.0;\n  for (int i = 0; i < 11; ++i) {\n    float g = a*galaxy(p, TIME*(0.025*float(i)), f);\n    s += g;\n    a *= sqrt(0.45);\n    f *= sqrt(2.0);\n    d += a;\n  }\n  \n  s *= sp;\n  \n  return SABS((-0.25+ s/d), 0.5)*exp(-5.5*l*l);\n}\n\nvec3 normal(vec2 p) {\n  vec2 eps = vec2(0.000125, 0.0);\n  \n  vec3 n;\n  \n  n.x = height(p - eps.xy) - height(p + eps.xy);\n  n.y = 2.0*eps.x;\n  n.z = height(p - eps.yx) - height(p + eps.yx);\n  \n  return normalize(n);\n}\n\nconst vec3 colDust = vec3(1.0, 0.9, 0.75);\n\nvec3 galaxy(vec2 p, vec3 ro, vec3 rd, float d) {\n  rot(p, 0.5*TIME);\n\n  float h = height(p);\n  vec3 s = stars(p);\n  float th = tanh(h);\n  vec3 n = normal(p);\n  \n  vec3 p3 = vec3(p.x, th, p.y);\n  float lh = 0.5;\n  vec3 lp1 = vec3(-0.0, lh, 0.0);\n  vec3 ld1 = normalize(lp1 - p3);\n  vec3 lp2 = vec3(0.0, lh, 0.0);\n  vec3 ld2 = normalize(lp2 - p3);\n\n  float l = length(p);\n  float tl = tanh(l);\n\n  float diff1 = max(dot(ld1, n), 0.0);\n  float diff2 = max(dot(ld2, n), 0.0);\n\n  vec3 col = vec3(0.0);\n  col += vec3(0.5, 0.5, 0.75)*h;\n//  col += vec3(0.5)*pow(diff1, 20.0);\n  col += 0.25*pow(diff2, 4.0);\n  col += pow(vec3(0.5)*h, n.y*1.75*(mix(vec3(0.5, 1.0, 1.5), vec3(0.5, 1.0, 1.5).zyx, 1.25*tl)));\n//  col += 0.9*vec3(1.0, 0.9, 0.75)*exp(-10*l*l);\n\n\n  float sr = rand(s.yz);\n  float si = pow(th*sr, 0.25)*0.001;\n  vec3 scol = sr*5.0*exp(-2.5*l*l)*tanh(pow(si/(s.x), 2.5))*mix(vec3(0.5, 0.75, 1.0), vec3(1.0, 0.75, 0.5), sr*0.6);\n  scol = clamp(scol, 0.0, 1.0);\n  col += scol*smoothstep(0.0, 0.35, 1.0-n.y);\n  \n  float ddust = (h - ro.y)/rd.y;\n  if (ddust < d) {\n    float t = d - ddust;\n    col += 0.7*colDust*(1.0-exp(-2.0*t));\n  }\n\n  return col;\n}\n\nvec3 render(vec3 ro, vec3 rd) {\n  float dgalaxy = (0.0 - ro.y)/rd.y;\n  \n  vec3 col = vec3(0);\n  \n  if (dgalaxy > 0.0) {\n    col = vec3(0.5);\n    vec3 p = ro + dgalaxy*rd;\n    \n    col = galaxy(p.xz, ro, rd, dgalaxy);\n  }\n  \n  vec2 cgalaxy = raySphere(ro, rd, vec3(0.0), 0.125);\n\n  float t;\n  \n  if (dgalaxy > 0.0 && cgalaxy.x > 0.0) {\n    float t0 = max(dgalaxy - cgalaxy.x, 0.0);\n    float t1 = cgalaxy.y - cgalaxy.x;\n    t = min(t0, t1);\n  } else if (cgalaxy.x < cgalaxy.y){\n    t = cgalaxy.y - cgalaxy.x;\n  }\n  \n  col += 1.7*colDust*(1.0-exp(-1.0*t));\n  \n  \n  return col;\n}\n\n\nvec3 postProcess(vec3 col, vec2 q)  {\n  col=pow(clamp(col,0.0,1.0),vec3(0.75)); \n  col=col*0.6+0.4*col*col*(3.0-2.0*col);  // contrast\n  col=mix(col, vec3(dot(col, vec3(0.33))), -0.4);  // satuation\n  col*=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);  // vigneting\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n\n  vec3 ro = vec3(0.0, 0.7, 2.0)*0.75;\n  vec3 la = vec3(0.0, 0.0, 0.0);\n  vec3 up = vec3(-0.5, 1.0, 0.0);\n  vec3 ww = normalize(la - ro);\n  vec3 uu = normalize(cross(up, ww));\n  vec3 vv = normalize(cross(ww,uu));\n  vec3 rd = normalize(p.x*uu + p.y*vv + 2.5*ww);\n  \n  \n  vec3 col = render(ro, rd);\n\n  col = postProcess(col, q);\n\n  fragColor = vec4(col, 1.0);\n}\n\n// --------[ Original ShaderToy ends here ]---------- //\n\nvoid main(void)\n{\n    mainImage(gl_FragColor, gl_FragCoord.xy);\n}";
        ShaderList2.Zauberwuerfel = "/*\n * Original shader from: https://www.shadertoy.com/view/3djfWW\n */\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n// glslsandbox uniforms\nuniform float time;\nuniform vec2 resolution;\nuniform vec2 mouse;\n\n// shadertoy emulation\n#define iTime time\n#define iResolution resolution\nvec4 iMouse = vec4(0.);\n\n// --------[ Original ShaderToy begins here ]---------- //\n// \"Big Rubik Pseudosolver\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define SIZE4  1  // =1 for 4^3 cube; =0 for 3^3\n\n#define AA     0  // optional antialiasing\n\nmat3 VToRMat (vec3 v, float a);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nfloat Minv3 (vec3 p);\nfloat Maxv3 (vec3 p);\nfloat Hashff (float p);\n\n#define VAR_ZERO 0\n\nmat3 vuMat = mat3(0.);\nvec2 qBlk = vec2(0.);\nfloat tCur = 0., dstFar = 0., bSize = 0., rSeed = 0.;\nconst float pi = 3.1415927;\n\nvec4 BlkHit (vec3 ro, vec3 rd, vec3 p, mat3 m)\n{\n  vec3 rdm, v, tm, tp, u, fcBlk;\n  float dMin, dn, df;\n  dMin = dstFar;\n  rdm = m * rd;\n  v = (m * ro - p) / rdm;\n  tp = bSize / abs (rdm) - v;\n  tm = - tp - 2. * v;\n  dn = Maxv3 (tm);\n  df = Minv3 (tp);\n  if (df > 0. && dn < min (df, dMin)) {\n    dMin = dn;\n    fcBlk = - sign (rdm) * step (tm.zxy, tm) * step (tm.yzx, tm);\n    u = (v + dn) * rdm;\n  }\n  if (dMin < dstFar) {\n    qBlk = vec2 (dot (u.zxy, fcBlk), dot (u.yzx, fcBlk));\n  }\n  return vec4 (dMin, fcBlk);\n}\n\nvec4 SphHit (vec3 ro, vec3 rd, float rad)\n{\n  vec3 vn;\n  float b, d, w;\n  b = dot (rd, ro);\n  w = b * b + rad * rad - dot (ro, ro);\n  d = dstFar;\n  if (w > 0.) {\n    d = - b - sqrt (w);\n    vn = (ro + d * rd) / rad;\n  }\n  return vec4 (d, vn);\n}\n\n#if SIZE4\nconst float nbE = 4.;\nconst float nTwist = 28.;\n#else\nconst float nbE = 3.;\nconst float nTwist = 22.;\n#endif\n\nmat3 RotSeq (vec3 bId, float nt, float aRot)\n{                     // Derived rotation matrix sequence from Kali's \"Rubik\"\n  mat3 rMat, m;\n  vec3 ax[3], vSlice;\n  vec2 e;\n  float s, sa;\n  e = vec2 (1., 0.);\n  ax[0] = e.xyy;\n  ax[1] = e.yxy;\n  ax[2] = e.yyx;\n  rMat = mat3 (e.xyy, e.yxy, e.yyx);\n  for (float n = float (VAR_ZERO); n < nTwist; n ++) {\n    if (n > nt) break;\n    s = mod (n + floor (6. * Hashff (99. + rSeed)), 6.);\n    sa = sign (s - 2.5);\n    s = mod (s, 3.);\n    vSlice = (s == 0.) ? e.xyy : ((s == 1.) ? e.yxy : e.yyx);\n    if (length ((bId + 0.5 * (nbE + 1.)) * vSlice) - 1. == floor (nbE * Hashff (n + rSeed))) {\n      m = VToRMat (sa * ((s == 0.) ? ax[0] : ((s == 1.) ? ax[1] : ax[2])),\n         0.5 * pi * ((n < nt) ? 1. : aRot));\n      for (int k = 0; k < 3; k ++) ax[k] = m * ax[k];\n      rMat = m * rMat;\n      if (n < nt) bId = VToRMat (sa * vSlice, -0.5 * pi) * bId;\n    }\n  }\n  return rMat;\n}\n\nfloat LabSym (vec2 p)\n{\n  vec2 q;\n  float d, r;\n  r = length (p);\n  d = max (min (0.06 - abs (0.1 - abs (r - 0.8)), p.y), min (0.06 - abs (p.y), 1.1 - abs (p.x)));\n  q = Rot2D (p, 2. * pi * floor (16. * ((r > 0.) ? atan (p.y, - p.x) / (2. * pi) : 0.) + 0.5) / 16.);\n  d = max (d, min (min (0.06 - abs (q.y), 0.2 - abs (q.x + 1.1)), p.y + 0.1));\n  q.x += 1.5;\n  d = max (d, min (0.1 - length (q), p.y + 0.1));\n  return d;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  mat3 rMat, rMatH;\n  vec4 col4, bs4;\n  vec3 col, vn, ltDir, fcBlk, bId, bidH, cc[6], de3, ld, bLab;\n  vec2 qBlkH, de;\n  float dstBlk, dstSphr, d, nt, tCyc, shSpd, tWait, aRot, dSum, sSum, bMin;\n  cc[0] = vec3 (1., 0.2, 0.2);\n  cc[1] = vec3 (1., 0.4, 0.2);\n  cc[2] = vec3 (0.2, 0.2, 1.);\n  cc[3] = vec3 (0.2, 1., 0.2);\n  cc[4] = vec3 (1., 1., 0.2);\n  cc[5] = vec3 (1., 1., 1.);\n  bSize = 0.48;\n  shSpd = 10.;\n  tWait = 3.;\n  tCyc = (nTwist + tWait) * (1. + 1. / shSpd) + tWait;\n  nt = nTwist - max (0., mod (tCur, tCyc) - tWait);\n  if (nt + tWait < 0.) nt = - shSpd * (nt + tWait);\n  aRot = smoothstep (0.1, 0.9, max (0., fract (nt) * sign (nt)));\n  nt = max (0., floor (nt));\n  rSeed = 17.77 * floor ((tCur + (nTwist + tWait) / shSpd + tWait) / tCyc + 1.);\n  bMin = 0.5 * (nbE - 1.) - 0.5;\n  bLab = vec3 (0., 0., -1.);\n  if (nbE == 4.) bLab -= 0.5;\n  dstBlk = dstFar;\n  for (float j = float (VAR_ZERO); j < nbE * nbE * nbE; j ++) {\n    bId = vec3 (mod (j, nbE), mod (floor (j / nbE), nbE), floor (j / (nbE * nbE))) - 0.5 * (nbE - 1.);\n    if (Maxv3 (abs (bId)) > bMin) {\n      rMat = RotSeq (bId, nt, aRot);\n      bs4 = BlkHit (ro, rd, bId, rMat);\n      d = bs4.x;\n      if (d < dstBlk) {\n        dstBlk = d;\n        fcBlk = bs4.yzw;\n        rMatH = rMat;\n        qBlkH = qBlk;\n        bidH = bId;\n      }\n    }\n  }\n  bs4 = SphHit (ro, rd, (nbE - 0.2) * bSize);\n  dstSphr = bs4.x;\n  if (min (dstBlk, dstSphr) < dstFar) {\n    if (dstBlk < dstSphr) {\n      ro += dstBlk * rd;\n      de = smoothstep (-0.08, 0., abs (qBlkH.xy) - bSize);\n      de3 = vec3 (0.25 * pi * de * sign (qBlkH.xy), 0.);\n      vn = normalize (fcBlk + ((fcBlk.x != 0.) ? de3.zxy : ((fcBlk.y != 0.) ? de3.xzy : de3))) * rMatH;\n      if (length (max (abs (qBlkH) - bSize + 0.12, 0.)) < 0.07) {\n        if (abs (bidH.x) > bMin && sign (bidH.x) == fcBlk.x ||\n            abs (bidH.y) > bMin && sign (bidH.y) == fcBlk.y ||\n            abs (bidH.z) > bMin && sign (bidH.z) == fcBlk.z) {\n          if      (abs (fcBlk.x) == 1.) col4.rgb = (fcBlk.x > 0.) ? cc[0] : cc[1];\n          else if (abs (fcBlk.y) == 1.) col4.rgb = (fcBlk.y > 0.) ? cc[2] : cc[3];\n          else if (abs (fcBlk.z) == 1.) col4.rgb = (fcBlk.z > 0.) ? cc[4] : cc[5];\n          col4 = vec4 (mix (col4.rgb, vec3 (0.2, 0.2, 0.2), max (de.x, de.y)), 0.2);\n        } else {\n          col4 = vec4 (0.1, 0.1, 0.1, 0.);\n        }\n        if (bidH == bLab && sign (bidH.z) == fcBlk.z)\n           col4 *= 1. - 0.6 * smoothstep (-0.05, 0., LabSym (-16. * (vec2 (0.5, 0.5) * bSize + qBlkH.yx)));\n      } else {\n        col4 = vec4 (0.2, 0.2, 0.2, 0.2);\n      }\n    } else if (dstSphr < dstFar) {\n      ro += dstSphr * rd;\n      vn = bs4.yzw;\n      col4 = vec4 (0.1, 0.1, 0.1, 0.);\n    }\n    dSum = 0.;\n    sSum = 0.;\n    ltDir = normalize (vec3 (1., 1., -0.6));\n    for (int j = 0; j < 4; j ++) {\n      ltDir.xy = Rot2D (ltDir.xy, 0.5 * pi);\n      ld = vuMat * ltDir;\n      dSum += pow (max (dot (vn, ld), 0.), 1.5);\n      sSum += pow (max (dot (normalize (ld - rd), vn), 0.), 32.);\n    }\n    col = col4.rgb * (0.2 + 0.5 * dSum) + col4.a * sSum;\n    col = pow (clamp (col, 0., 1.), vec3 (0.8));\n  } else {\n    col = vec3 (0.6);\n  }\n  return col;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = -0.15 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  } else {\n    az -= 0.04 * pi * tCur;\n    el -= 0.07 * pi * (1. + sin (0.05 * pi * tCur));\n  }\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (0., 0., -10. * nbE / 3.);\n  zmFac = 3.7;\n  dstFar = 100.;\n  if (length (uv) < 0.99) {\n#if ! AA\n    const float naa = 1.;\n#else\n    const float naa = 3.;\n#endif  \n    col = vec3 (0.);\n    sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n    for (float a = float (VAR_ZERO); a < naa; a ++) {\n      rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n         sr * (0.667 * a + 0.5) * pi), zmFac));\n      col += (1. / naa) * ShowScene (ro, rd);\n    }\n  } else col = mix (vec3 (0.6), vec3 (0.82), smoothstep (0., 0.1, length (uv) - 0.99));\n  fragColor = vec4 (col, 1.);\n}\n\nmat3 VToRMat (vec3 v, float a)\n{\n  mat3 m;\n  vec3 w, b1, b2;\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  w = (1. - cs.x) * v * v + cs.x;\n  b1 = (1. - cs.x) * v.zyx * v.xzy;\n  b2 = - cs.y * v;\n  m[0][0] = w.x;  m[1][1] = w.y;  m[2][2] = w.z;\n  m[1][2] = b1.x + b2.x;  m[2][1] = b1.x - b2.x;\n  m[2][0] = b1.y + b2.y;  m[0][2] = b1.y - b2.y;\n  m[0][1] = b1.z + b2.z;  m[1][0] = b1.z - b2.z;\n  return m;\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashff (float p)\n{\n  return fract (sin (p) * cHashM);\n}\n// --------[ Original ShaderToy ends here ]---------- //\n\nvoid main(void)\n{\n    iMouse = vec4(mouse * resolution, 1., 0.);\n    mainImage(gl_FragColor, gl_FragCoord.xy);\n}";
        ShaderList2.Blackandwhite = "/*\n * Original shader from: https://www.shadertoy.com/view/ws2fDW\n */\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n// glslsandbox uniforms\nuniform float time;\nuniform vec2 resolution;\n\n// shadertoy emulation\n#define iTime time\n#define iResolution resolution\nconst vec4 iMouse = vec4(0.);\n\n// --------[ Original ShaderToy begins here ]---------- //\n// Made by Plento\n// An experiment with messing with space in a portal like fashion\nvec2 R;\n\n#define m vec2(R.x/R.y*(iMouse.x/R.x-.5),iMouse.y/R.y-.5)\n#define FAR 64.\n#define FAR2 12.\n\nmat2 rot(float a){return mat2(cos(a), -sin(a), sin(a), cos(a));}\n\nfloat box( vec3 p, vec3 b ){\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat hall(vec3 rp){\n    float d  = 999.;\n    rp.x = -abs(rp.x);\n    d = min(d, box(rp-vec3(-2., 0.0, 11.0), vec3(0.1, 2., 5.0)));\n    d = min(d, box(rp-vec3(0.0, 2.1, 11.0), vec3(2.1, 0.1, 5.0)));\n    return d;\n}\n\nvec3 b = vec3(8., 0., 0.);\n\n// distance field for hall and floor\nfloat map(vec3 rp){\n    float d = 999.;\n    \n    vec3 p = rp;\n    p = mod(p, b)-b*0.5;\n    \n    d = min(d, 2. + rp.y);\n    d = min(d, hall(p));\n    \n    return d;\n}\n// distance field for just portals\nfloat mapPortal(vec3 rp){\n    vec3 p = rp-vec3(0., 0., 6.);\n    p = mod(p, b)-b*0.5;\n    return box(p, vec3(1.9, 2., .001));\n}\n\nvec3 normal( in vec3 pos ){\n    vec2 e = vec2(0.002, -0.002);\n    return normalize(\n        e.xyy * map(pos + e.xyy) + \n        e.yyx * map(pos + e.yyx) + \n        e.yxy * map(pos + e.yxy) + \n        e.xxx * map(pos + e.xxx));\n}\n\n// march scene for color\nfloat march(vec3 rd, vec3 ro){\n \tfloat t = 0., d = 0.;  \n    \n    for(int i = 0; i < 99; i++){\n    \td = map(ro + rd*t); \t   \n        if(abs(d) < .0025 || t > FAR) break;\n        t += d * .95;\n    }\n    \n    return t;\n}\n\n// march scene for just portals with reduced step count\nfloat tracePortal(vec3 rd, vec3 ro){\n \tfloat t = 0., d = 0.;  \n    \n    for(int i = 0; i < 28; i++){\n    \td = mapPortal(ro + rd*t); \t   \n        \n        if(abs(d) < .0025) break;\n        if(t > FAR2){t = FAR2; break;}\n        \n        t += d * .75;\n    }\n    return t;\n}\n\nvec3 color(vec3 p, vec3 rd, vec3 n, vec2 u, float t){\n    vec3 lp = p+vec3(4., 16.0, -2.0);\n    vec3 ld = normalize(lp-p);\n   \tvec3 ref = reflect( rd, n );\n    \n    float lgd = length(lp - p);\n    float faloff = 1.-exp(-(4. / lgd));\n    \n    float dom = smoothstep(-0.1, 0.1, ref.y);\n    float dif = max(dot(n, ld), .025);\n    \n    vec3 col = vec3(0);    \n    vec3 lig = vec3(0);\n    \n    if(p.y <= -1.85){\n        vec2 id = floor(p.xz*1.);\n        float chk = mod(id.x+id.y, 2.);\n        col = mix(vec3(.6), vec3(0.), chk); \n    }\n    else{col = vec3(1., 1., 1.);}\n    \n    lig += .4*dom*vec3(0.2,0.1,1.0)*dom;\n    lig += 2.6*dif*vec3(1., 1., 1.) * faloff;\n    col *= lig;\n   \n    vec3 sky = mix(vec3(0.2, 0.48, 0.88), vec3(0.8, 0.48, 0.88), abs(rd.y*7.8));\n    col = mix(sky, col, exp(-t*t*t*0.00003));\n    \n\treturn col;   \n}\n\nvoid mainImage( out vec4 f, in vec2 u ){\n    R = iResolution.xy;\n    vec2 uv = vec2(u.xy - 0.5*R.xy)/R.y;\n    \n    vec3 rd = normalize(vec3(uv, 0.9));\n    vec3 ro = vec3(iTime*3., 0., 0.);\n    \n    if(iMouse.z > 0.){\n     \tro.x += m.x*42.;\n        ro.y += m.y*8.;\n    }\n    \n    vec3 p = vec3(0);\n    float t = 0.;\n    \n    vec3 col = vec3(0);\n    vec3 n = vec3(0);\n    \n    float tp = tracePortal(rd, ro);\n    \n    if(tp < FAR2){ // hit portal, do wacky stuff with ray\n    \tp = ro+rd*tp; \t   \n        \n        float id = floor(p.x/b.x);\n        float seq = floor(mod(id, 6.));\n        \n        if(seq==0.) rd.z *= 5.0;\n        else if(seq==1.) rd.z*=.1;   \n        else if(seq==2.) rd.xz*=rot(.6);     \n        else if(seq==3.) rd.xz*=rot(-.5);   \n        else if(seq==4.) rd.yz*=rot(.4);     \n        else if(seq==5.) rd.yz*=rot(-.23);     \n         \n        t = march(rd, p);\n        p += rd*t;\n        \n        n = normal(p);\n    \tcol = color(p, rd, n, u, t);\n    }\n    else{ // trace scene like normal\n        t = march(rd, ro);\n        p = ro+rd*t; \t \n        n = normal(p);\n    \tcol = color(p, rd, n, u, t);  \n    }\n    \n    col*=smoothstep(0.5, 0.0, abs(uv.y));\n    f = vec4(sqrt(clamp(col, .0, 1.)), 1.);\n    \n}\n\n\n\n// --------[ Original ShaderToy ends here ]---------- //\n\nvoid main(void)\n{\n    mainImage(gl_FragColor, gl_FragCoord.xy);\n}";
        ShaderList2.Pyramide = "/*\n * Original shader from: https://www.shadertoy.com/view/3sBBRK\n */\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n// glslsandbox uniforms\nuniform float time;\nuniform vec2 resolution;\n\n// shadertoy emulation\n#define iTime time\n#define iResolution resolution\n\n// Emulate some GLSL ES 3.x\n#define round(x) (floor((x) + 0.5))\n\n// --------[ Original ShaderToy begins here ]---------- //\n// The vanishing of Ashlar by NuSan\n// PC 4k intro made for Outline Online 2020\n\n// Unfortunately, the GPU Synthesizer I made cannot be ported on shadertoy, as it uses a second audio pass to compute reverbs\n// So only soundcloud for now ...\n\n// Original Tools: Leviathan, custom GPU synth based on Oidos, Shader Minifier, Crinkler\n// https://www.pouet.net/prod.php?which=85684\n// https://youtu.be/lAvug7LKiIE\n\nfloat pi=acos(-1.);\n\nfloat sat(float t) { return clamp(t, 0.,1.); }\n\n//DAVE HOSKINS' HASH FUNCTIONS\n// we use them mainly because they don't contain any sin/cos and so should be more consistent accross hardware\n//https://www.shadertoy.com/view/4djSRW\nfloat rnd(float p)\n{\n    p = fract(p * 0.1031);\n    p *= p + 33.33;\n    return fract(2.*p*p);\n}\n\nvec3 rnd23(vec2 p)\n{\n\tvec3 p3 = fract(p.xyx * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nfloat rnd31(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 rnd33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\n\n// Lower that value if it's too slow\n#define SAMPLE_COUNT 30.\n\n#define res iResolution\n\n//////////////////////\n// PATHTRACING PASS //\n//////////////////////\n\n// we use globals for most parameters, it save space\n// s is starting position, r is ray direction\n// n is normal at intersection point and d is distance to the intersection\nvec3 s=vec3(0),r=vec3(0),n=vec3(0);\nfloat d=10000.;\nvec3 boxid=vec3(0);\n\nmat2 rot(float a) {return mat2(cos(a),sin(a),-sin(a),cos(a));}\n\n// Compute octahedron distance from center, os is the size of each of the 4 'axis'\nfloat octaedge(vec3 p, vec4 os) {\n    \n    vec4 vv=vec4(1.4142,-1.4142,1,-1); // 1.4142 = cos(45)/cos(60)\n    vec4 popo = p.xxyy*vv.xyww + p.yyzz*vv.zzxy;\n    popo=abs(popo)-os;\n          \n    float d = max(max(popo.x,popo.y),max(popo.z,popo.w));\n\n    return d;\n}\n\nvec4 osize1 = vec4(10);\nvec4 osize2 = vec4(2);\nvec3 boxrepeat = vec3(1,8,8);\nvec3 centerrepeat = vec3(.4,2,2);\nfloat boxanim = 0.;\nfloat centeranim = 0.;\nfloat boxtime = 0.;\nfloat insidedist(vec3 p) {\n\treturn max(octaedge(p, osize1), -octaedge(p, osize2));\n}\n\n// analytical box intersection\nvoid box(vec3 basepos, int side) {\n\t\n    // are we on the outside octahedron or the center one\n\tbool iscenter = octaedge(basepos,osize2)<.1;\n\tvec3 rep = iscenter ? centerrepeat : boxrepeat;\n\t\n    // main repetition is based on the x axis\n\tvec3 id2 = floor(basepos.x/rep.x)+vec3(1.7,3,7);\n\t\n    // then we can have integer multiplier subdivision without breaking the illusion\n\trep = (rep/(floor(rnd33(id2)*vec3(6))+1.));\n\t\n\tvec3 pos=vec3(0);\t\n    \n    // offset on yz axis, box animation\n\tvec2 ooo = fract(rnd(floor(basepos.x/rep.x)+.7)*vec2(1,3.7))*8.*7.;\n    ooo*=boxtime*vec2(1,1.3)*(iscenter?centeranim:boxanim)*rep.yz*0.03;\n    basepos.yz += ooo;\n\tpos.yz += ooo;\n  \n    // here we are applying the box repetition\n\tboxid = (floor(basepos/rep)+0.5)*rep;\n\n\tvec3 size = rep*0.4;\n  \n\tvec3 vr = r;\n\tpos=s+pos-boxid;\n  \n\tvec3 box=max((size-pos)/vr,(-size-pos)/vr);\n\tfloat bd = min(min(box.x,box.y),box.z);\n\tif(bd>0. && bd>d*float(side)) {\n\t\tvec3 cur = step(abs(pos+vr*d),size);\n\t\tif(side>0 ? (min(cur.x,min(cur.y,cur.z))>0.) : insidedist(s+r*bd)>0.) {\n\t\t\td=bd;\n\t\t\tn=-step(box-bd,vec3(0))*sign(pos+vr*d);\n\t\t}\n\t}\n}\n\n\n// analytical octrahedron intersection, with customisable size for each of the 4 'axis'\nvoid frontocta(vec4 size, int side) {\n    \n  \tvec4 vv=vec4(1.4142,-1.4142,1,-1); // 1.4142 = cos(45)/cos(60)\n    vec4 invd = 1. / (r.xxyy*vv.xyww + r.yyzz*vv.zzxy);\n  \tvec4 popo = -s.xxyy*vv.xyww - s.yyzz*vv.zzxy;\n    \n    vec4 t0 = (popo - size) * invd;\n    vec4 t1 = (popo + size) * invd;\n    vec4 mi = min(t0, t1);\n    vec4 ma = max(t0, t1);\n\n    float front = min(min(ma.x,ma.y),min(ma.z,ma.w));\n    float back = max(max(mi.x,mi.y),max(mi.z,mi.w));\n    if(back>front) return;\n\n    if(side==0) {\n        back=front;\n    }\n\n    if(back<d && back > 0.) {\n        d = back;\n        vec4 vo = sign(t0-t1) * (side==0 ? step(-back,-ma) : step(back,mi));\n\n        n = vo.xxz - vo.yzw;\n        n.y += vo.y-vo.w;\n        n*=-sign(float(side)-.5)*vec3(0.817,0.5777,0.817); // = vec3(1,0.5 * 1.4142,1)/1.224 = 1.224 = cos(45) * tan(60)\n    }\n}\n\n// Main way to control the intro (camera, DOF focus, shape)\n// Each vec3 is a section of the intro\n// first value is the seed of the camera motionpath/speed/FOV, fractionnal part is a time offset, negative values subdivide the section in two parts\n// second value is the focus distance for the DOF, negative value makes the DOF bigger\n// third value is the shape seed, integer value is the background shape, fractionnal part is the center shape\nvec3 mot[16];\n\nvoid init_mot() {\n\tmot[0] = vec3(12,2,14.19);\n\tmot[1] = vec3(-4.7,11,29);\n\tmot[2] = vec3(7,10,7.2);\n\tmot[3] = vec3(11,-5,5.63);\n\t// --------------\n\tmot[4] = vec3(16.45,5,17.4);\n\tmot[5] = vec3(-12,5,12.2);\n\tmot[6] = vec3(2,5,12.2);\n\tmot[7] = vec3(0.4,9,10);\n\t// --------------\n\tmot[8] = vec3(17.8,7,11.1);\n\tmot[9] = vec3(-7.6,-20,15);\n\tmot[10] = vec3(-13,-30,2.2);\n\tmot[11] = vec3(7,40,3);\n\t// --------------\n\tmot[12] = vec3(17,20,6);\n\tmot[13] = vec3(-5.4,50,15.4);\n\tmot[14] = vec3(16,30,13);\n\tmot[15] = vec3(12,10,7);\n}\n\nvec3 get_mot(int idx) {\n\tfor (int i=0; i<16; ++i) {\n\t\tif (i == idx)\n\t\t\treturn mot[i];\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 frag = fragCoord.xy;\n\tvec2 uv = (frag-res.xy*0.5)/res.y;\n\t\t\n\tvec3 col = vec3(0);\n\t\t\n\tfloat time =iTime-.9;\n\tboxtime = time;\n\n\tinit_mot();\n\n\tfloat light = 0.;\n\tint section = int(min(16.,time/8.));\n\tfloat rest = mod(time,8.);\n\n\tvec3 mval = get_mot(section);\n\tif(section>5 && section<9) mval.z+=floor(rest)*2.2;\n\n\tvec3 pcam = rnd23(vec2(round(abs(mval.x)),0));\n\t\t\n\t//////// SIZES ////////\n\tif(section==0) osize2 = vec4(6);\n\t\n    // extruding the shapes\n\tfloat push2 = max(0.,time-48.)*1.5;\n\tif(section>7) push2 = 10000.;\n\tfloat push = 2.+max(0.,time-40.)*.5+push2;\n\tfloat decol=max(0.,time-70.);\n\tif(section>14) {\n\t\tdecol=0.;\n\t\tpush=0.;\n\t\tpush2=0.;\n\t}\n\n\tif(section>4)osize2 = vec4(2,push,push,2);\n\tif(section>6)osize1 = vec4(10,10.+push2,10.+push2,10);\n\t\n\t//////// REPEATS ////////\n\tboxrepeat = rnd23(vec2(floor(mval.z),0))*50.;\n\tcenterrepeat = pow(rnd23(vec2(0,fract(mval.z)*31.5+28.)),vec3(2))*10.+.2;\n\n\tif(section==3) osize1=vec4(20);\n\t\t\n\t//////// NIGHT ////////\n\tfloat skydist = 1.;\n\tfloat bright=0.;\n\tif(section>8 && section<15) {\n\t\tboxanim = .3;\n\t\tboxrepeat *= 2.;\n\t\tcenterrepeat *= 10.;\n\t\tif(section>11) {\n            // transition to night section, with light appearing\n\t\t\tlight = sat((time/8.-12.));\n\t\t\tskydist = section>12?200.:20.*light;\n\t\t\tosize1 = vec4(20,push2,push2,20);\n\t\t\tboxanim=0.;\n\t\t\tif(section==14) {\n                // center brightening and vanishing\n\t\t\t\tcenterrepeat.xy*=1.1;\n\t\t\t\tbright=pow(sat(time/8.-14.07),2.);\n\t\t\t\tosize2.xw = vec2(2.-sqrt(bright+.01-uv.y*.02+uv.x*.001)*2.3,17.*bright+2.);\n\t\t\t}\n\t\t}\n\t}\n\tcenteranim = section>2?(section>7?0.3:0.3):0.;\n\n\t//////// CAMERA ANIMATION ////////\n    // array value is a seed to an offset on lissajous curves, with various speed factor\n\tfloat avance = pcam.x*200. + (rest+(fract(mval.x+.5)-.5)*8.) * (pcam.y-0.2);\n\tif(mval.x<0.) avance += floor(rest/4.)*3.;\n\t\n\tfloat focusdist = abs(mval.y);\n\tfloat dofamount = mval.y>0. ? .05 : .15;\n    // extrapush is used to put the camera outside the room without colliding, so we can zoom more\n\tfloat extrapush = max(fract(pcam.z*17.23)-.5,0.)*15.;\n\tfloat fov = pcam.z*1.5+.5 + extrapush/2.;\n\tvec3 bs=vec3(0,-1.5 + sin(avance*.2)*1.,0);\n\tvec3 t = vec3(0,-1.5 + sin(avance*.3)*3.,0);\n\n    // lissajous curve to makes interesting camera motion\n\tbs.x += 5.*sin(avance*.4 + 0.7);\n\tbs.z += 5.*sin(avance*.9);\n\n    // camera target is following the same curve in front of the camera but with a random factor to focus more on the center\n\tfloat dt=max(0.,fract(pcam.z*24.81)-.2)*6.;\n\tt.x += dt*sin(avance*.4 + 0.7 + 1.);\n\tt.z += dt*sin(avance*.9 + 1.);\n\t\n\t//////// SKYDIVING ////////\n\tvec3 govec = vec3(-1,1.41,-1);\n\tvec3 poff = govec*decol*min(2.,decol)*2.5;\n\tt -= poff + govec*10.*(step(2.,decol)-bright);\n\tbs -= poff;\n    \n\t//////// CAMERA COMPUTE ////////\n\tvec3 cz=normalize(t-bs);\n\tvec3 cx=normalize(cross(cz,vec3(0,1,0)));\n\tvec3 cy=cross(cz,cx);\n\n\t// Main path tracing loop, do many samples to reduce the noise\n\tfor(float i=0.; i<SAMPLE_COUNT; ++i) {\n    \t\t\n\t\ts=bs;\t\n\t\tvec2 h = rnd23(frag-13.6-i*184.7).xy;\n\t\t// DOF\n\t\tvec3 voff = sqrt(h.x)*(cx*sin(h.y*6.283)+cy*cos(h.y*6.283))*dofamount;\n\t\ts-=voff;\n\t\tr=normalize(uv.x*cx+uv.y*cy+fov*cz + voff*fov/(focusdist+extrapush));\n\n\t\ts += (r-cz) * extrapush;\n\t\t\n        // number of bounces is 3\n\t\tfor(float j=0.; j<3.; ++j) {\n\t\t\t////////// TRACE //////////\n\t\t\td=100000.;\n  \n            // find instersection with geometry\n            \n            // first test if we started inside a repeating box\n\t\t\tbox(s,-1);\n  \n            // then intersect with the background octahedron\n\t\t\tfrontocta(osize1, 0);\n  \n            // save that intersection for latter\n\t\t\tfloat d2=d;\n\t\t\tvec3 s2=s;\n\t\t\tvec3 n2=n;\n\n            // intersect with the center shape\n\t\t\tfrontocta(osize2, 1);\n  \n            // now use that position to carve the repeating box\n\t\t\tbox(s+r*d,1);\n\n            // if intersection position is outside the center octahedron, it means that we went trough the shape\n            // so we back to the background intersection\n\t\t\tif(octaedge(s+r*d,osize2)>0.01) {\n\t\t\t\td=d2;\n\t\t\t\tn=n2;\n                // last possible repeating box intersection on the background octahedron\n\t\t\t\tbox(s+r*d,1);\n\t\t\t}\n    \n            // and finally the ground plane intersection\n\t\t\tfloat curplane=(1.1-s.y)/r.y;\n\t\t\tif(curplane>0. && curplane<d) {\n\t\t\t\td=curplane;\n\t\t\t\tn=sign(s.y)*vec3(0,1,0);\n\t\t\t}\n    \t\t\t\n\t\t\tif(d>10000.) break;\n\t\t\t\n\t\t\t// go to the intersection point\n\t\t\ts = s + r * d;\n\t\t\n            // test if we are outside the 'sky distance'\n\t\t\tfloat edge1 = octaedge(s,osize1);\t\t\t\t\t\t\n\t\t\tif(edge1>skydist) {\n                // if so, we just push the sky color and early out\n\t\t\t\tcol += mix(vec3(0.6,0.8,1)*0.8, vec3(1,0.7,0.5) * 2., max(r.x+r.z*.3-r.y*.7,0.)*.7);\n\t\t\t\tbreak;\n\t\t\t}\n\n            // if we are in the light section\n\t\t\tif(light>0.) {\n\t\t\t\tfloat middle = step(7.,edge1);\n\n                // center burning\n\t\t\t\tcol += bright * step(1.,-edge1) * vec3(.5,.7,1)*3.;\n\t\t\t\t\n                // side lights in two colors\n\t\t\t\tcol += middle * vec3(0.4,0.5,0.8) * 1.2 * step(0.7,rnd(dot(boxid,vec3(1,4,7))+floor(time)*0.1));\n\t\t\t\tcol += middle * vec3(0.2,0.5,0.9) * 1.2 * step(0.1,fract(.2+boxid.z*0.01 + floor(time)*13.2)*3.-1.5);\t\t\t\n\t\t\t}\n\n            // slight increase in perf, get out before computing rebound direction in the last rebound\n\t\t\tif(j==2.) break;\n\n            // roughness computing, depending on if we are on the center shape or not\n\t\t\tvec3 grid = step(fract(s*4.-.1),vec3(.8));\n\t\t\tfloat rough = octaedge(s,osize2)<.1 ? .5 : mix(1.,0.45*rnd31(floor(s*4.-.1)*27.33),min(grid.x,min(grid.y,grid.z)));\n            // slight offset so we get out of the surface before rebound\n\t\t\ts-=r*0.01;\n            // random rebound direction according to roughness parameter\n\t\t\tr=normalize(reflect(r,n) + normalize(rnd23(frag+vec2(i*277.,j*375.)+fract(time))-.5)*rough);\n\t\t}\n\t}\n\tcol *= 1./SAMPLE_COUNT;\n\t\n\tfragColor = vec4(col, 1);\n}\n// --------[ Original ShaderToy ends here ]---------- //\n\nvoid main(void)\n{\n    mainImage(gl_FragColor, gl_FragCoord.xy);\n}";
        ShaderList2.Roetem = "/*\n * Original shader from: https://www.shadertoy.com/view/4dGyRh\n */\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n// glslsandbox uniforms\nuniform float time;\nuniform vec2 resolution;\n\n// shadertoy emulation\n#define iTime time\n#define iResolution resolution\nconst vec4 iMouse = vec4(0.);\n\n// --------[ Original ShaderToy begins here ]---------- //\n// Re-entry by nimitz (twitter: @stormoid)\n// https://www.shadertoy.com/view/4dGyRh\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n// Contact the author for other licensing options\n\n#define ITR 35\n#define FAR 15.\n#define time iTime\n\nmat2 mm2(in float a){float c = cos(a), s = sin(a);return mat2(c,s,-s,c);}\n\nvec3 objmov(vec3 p)\n{\n    p.xz *= mm2(-time*3.4 + sin(time*1.11));\n    p.yz *= mm2(time*2.7 + cos(time*2.5));\n    return p;\n}\n\nfloat tri(in float x){return abs(fract(x)-0.5)-.25;}\nfloat trids(in vec3 p){return max(tri(p.z),min(tri(p.x),tri(p.y)));}\nfloat tri2(in float x){return abs(fract(x)-.5);}\nvec3 tri3(in vec3 p){return vec3( tri(p.z+tri(p.y*1.0)), tri(p.z+tri(p.x*1.05)), tri(p.y+tri(p.x*1.1)));}                           \n\nmat2 m2 = mat2( 0.970,  0.242, -0.242,  0.970 );\nfloat triNoise3d(in vec3 p, in float spd)\n{\n    float z = 1.45;\n\tfloat rz = 0.;\n    vec3 bp = p;\n\tfor (float i=0.; i<4.; i++ )\n\t{\n        vec3 dg = tri3(bp);\n        p += (dg+time*spd+10.1);\n        bp *= 1.65;\n\t\tz *= 1.5;\n\t\tp *= .9;\n        p.xz*= m2;\n        \n        rz+= (tri2(p.z+tri2(p.x+tri2(p.y))))/z;\n        bp += 0.9;\n\t}\n\treturn rz;\n}\n\nfloat map(vec3 p)\n{\n    p*= 1.5;\n\tp = objmov(p);\n    float d = length(p)-1.;\n    d -= trids(p*1.2)*.7;\n    return d/1.5;\n}\n\nfloat map2(vec3 p)\n{\n    p = objmov(p);\n    return length(p)-1.3;\n}\n\nfloat march(in vec3 ro, in vec3 rd)\n{\n\tfloat precis = 0.001;\n    float h=precis*2.0;\n    float d = 0.;\n    for( int i=0; i<ITR; i++ )\n    {\n        if( abs(h)<precis || d>FAR ) break;\n        d += h;\n\t    float res = map(ro+rd*d);\n        h = res;\n    }   \n\treturn d;\n}\n\nvec3 normal(const in vec3 p)\n{  \n    vec2 e = vec2(-1., 1.)*0.04;   \n\treturn normalize(e.yxx*map(p + e.yxx) + e.xxy*map(p + e.xxy) + \n\t\t\t\t\t e.xyx*map(p + e.xyx) + e.yyy*map(p + e.yyy) );   \n}\n\nfloat gradm(in vec3 p)\n{\n    float e = .06;\n    float d = map2(vec3(p.x,p.y-e,p.z))-map2(vec3(p.x,p.y+e,p.z));\n    d += map2(vec3(p.x-e,p.y,p.z))-map2(vec3(p.x+e,p.y,p.z));\n    d += map2(vec3(p.x,p.y,p.z-e))-map2(vec3(p.x,p.y,p.z+e));\n\treturn d;\n}\n\n//Main fireball\nfloat mapVol(vec3 p, in float spd)\n{\n    float f = smoothstep(0.0, 1.25, 1.7-(p.y + dot(p.xz,p.xz)*.62));   \n    float g = p.y;\n    p.y *= .27;\n    p.z += gradm(p*0.73)*3.5;\n    p.y += time*6.;\n    float d = triNoise3d(p*vec3(0.3,0.27,0.3) - vec3(0,time*.0,0),spd*0.7)*1.4 + 0.01;\n    d += max((g-0.)*0.3,0.);    \n   \td *= f;\n    \n    return clamp(d,0.,1.);\n}\n\nvec3 marchVol( in vec3 ro, in vec3 rd, in float t, in float mt )\n{\n\tvec4 rz = vec4(0);\n    #if 1\n    t -= (dot(rd, vec3(0,1,0))+1.);\n    #endif\n\tfloat tmt = t +15.;\n\tfor(int i=0; i<25; i++)\n\t{\n\t\tif(rz.a > 0.99)break;\n\n\t\tvec3 pos = ro + t*rd;\n        float r = mapVol( pos,.1 );\n        float gr =  clamp((r - mapVol(pos+ vec3(.0,.7,0.0),.1))/.3, 0., 1. );\n        vec3 lg = vec3(0.72,0.28,.0)*1.2 + 1.3*vec3(0.55, .77, .9)*gr;\n        vec4 col = vec4(lg,r*r*r*2.5); //Could increase this to simulate entry\n        col *= smoothstep(t-0.0,t+0.2,mt);\n        \n        pos.y *= .7;\n        pos.zx *= ((pos.y-5.)*0.15 - 0.4);\n        float z2 = length(vec3(pos.x,pos.y*.75 - .5,pos.z))-.75;\n        col.a *= smoothstep(.4,1.2,.7-map2(vec3(pos.x,pos.y*.17,pos.z)));\n\t\tcol.rgb *= col.a;\n\t\trz = rz + col*(1. - rz.a);\n\t\t\n        t += abs(z2)*.1 + 0.12;\n        if (t>mt || t > tmt)break;\n\t}\n\t\n    rz.g *= rz.w*0.9+0.12;\n    rz.r *= rz.w*0.5+0.48;\n\treturn clamp(rz.rgb, 0.0, 1.0);\n}\n\n// \"Particles\"\nfloat mapVol2(vec3 p, in float spd)\n{\n    p *= 1.3;\n    float f = smoothstep(0.2, 1.0, 1.3-(p.y+length(p.xz)*0.4));\n    p.y *= .05;\n    p.y += time*1.7;\n    float d = triNoise3d(p*1.1,spd);\n    d = clamp(d-0.15, 0.0, 0.75);\n    d *= d*d*d*d*47.;\n   \td *= f;\n    \n    return d;\n}\n\nvec3 marchVol2( in vec3 ro, in vec3 rd, in float t, in float mt )\n{\n    \n    vec3 bpos = ro +rd*t;\n    t += length(vec3(bpos.x,bpos.y,bpos.z))-1.;\n    t -= dot(rd, vec3(0,1,0));\n\tvec4 rz = vec4(0);\n\tfloat tmt = t +1.5;\n\tfor(int i=0; i<25; i++)\n\t{\n\t\tif(rz.a > 0.99)break;\n\n\t\tvec3 pos = ro + t*rd;\n        float r = mapVol2( pos,.01 );\n        vec3 lg = vec3(0.7,0.3,.2)*1.5 + 2.*vec3(1,1,1)*0.75;\n        vec4 col = vec4(lg,r*r*r*3.);\n        col *= smoothstep(t-0.25,t+0.2,mt);\n        \n        float z2 = length(vec3(pos.x,pos.y*.9,pos.z))-.9;\n        col.a *= smoothstep(.7,1.7, 1.-map2(vec3(pos.x*1.1,pos.y*.4,pos.z*1.1)));\n\t\tcol.rgb *= col.a;\n\t\trz = rz + col*(1. - rz.a);\n\t\t\n        t += z2*.015 + abs(.35-r)*0.09;\n        if (t>mt || t > tmt)break;\n        \n\t}\n\t\n\treturn clamp(rz.rgb, 0.0, 1.0);\n}\n\n// MIT Licensed hash From Dave_Hoskins (https://www.shadertoy.com/view/4djSRW)\nvec3 hash33(vec3 p)\n{\n    p = fract(p * vec3(443.8975,397.2973, 491.1871));\n    p += dot(p.zxy, p.yxz+19.27);\n    return fract(vec3(p.x * p.y, p.z*p.x, p.y*p.z));\n}\n\nvec3 stars(in vec3 p)\n{\n    vec3 c = vec3(0.);\n    float res = iResolution.x*0.8;\n    \n\tfor (float i=0.;i<4.;i++)\n    {\n        vec3 q = fract(p*(.15*res))-0.5;\n        vec3 id = floor(p*(.15*res));\n        vec2 rn = hash33(id).xy;\n        float c2 = 1.-smoothstep(0.,.6,length(q));\n        c2 *= step(rn.x,.0005+i*i*0.001);\n        c += c2*(mix(vec3(1.0,0.49,0.1),vec3(0.75,0.9,1.),rn.y)*0.25+0.75);\n        p *= 1.4;\n    }\n    return c*c*.65;\n}\n\nfloat curv(in vec3 p, in float w)\n{\n    vec2 e = vec2(-1., 1.)*w;   \n    float t1 = map(p + e.yxx), t2 = map(p + e.xxy);\n    float t3 = map(p + e.xyx), t4 = map(p + e.yyy);\n    return 1.0/e.y *(t1 + t2 + t3 + t4 - 4. * map(p));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\tvec2 p = fragCoord.xy/iResolution.xy-0.5;\n\tp.x*=iResolution.x/iResolution.y;\n\tvec2 mo = iMouse.xy / iResolution.xy-.5;\n    mo = vec2(-0.27,0.31);\n\tmo.x *= iResolution.x/iResolution.y;\n    const float roz = 7.3;\n\tvec3 ro = vec3(-1.5,0.5,roz);\n    vec3 rd = normalize(vec3(p,-1.5));\n    mo.x += sin(time*0.3 + sin(time*0.05))*0.03+0.03;\n    mo.y += sin(time*0.4 + sin(time*0.06))*0.03;\n    mat2 mx = mm2(mo.x*6.);\n    mat2 my = mm2(mo.y*6.); \n    ro.xz *= mx;rd.xz *= mx;\n    ro.xy *= my;rd.xy *= my;\n    \n\tfloat rz = march(ro,rd); //march geometry\n    vec3 col = stars(rd);   \n    float maxT = rz;\n    if (rz > FAR)\n        maxT = 25.;\n    vec3 mv = marchVol(ro,rd, roz-1.5,maxT);\n    \n    if ( rz < FAR )\n    {\n        vec3 pos = ro+rz*rd;\n        vec3 nor= normal( pos );\n        float crv = clamp(curv(pos, 0.3)*0.35,0.,1.3);\n        \n        vec3 col2 = vec3(1,0.1,0.02)*(crv*0.8+0.2)*0.5;\n        float frict = dot(pos, normalize(vec3(0.,1.,0.)));\n        col = col2*(frict*0.3+0.7);\n        \n        col += vec3(1,0.3,0.1)*(crv*0.7+0.3)*max((frict*0.5+0.5),0.)*1.3;\n        col += vec3(.8,0.8,.5)*(crv*0.9+0.1)*pow(max(frict,0.), 1.5)*1.9;\n        pos = objmov(pos);\n        \n        col *= 1.2-mv;\n        col *= triNoise3d(pos*2.8,0.)*0.25+0.45;\n        col = pow(col, vec3(1.5,1.2,1.2))*.9;\n    }\n    col += mv;\n    col += marchVol2(ro,rd, roz-5.5,rz);\n\tcol = pow(col,vec3(1.4))*1.1;\n    \n\tfragColor = vec4( col, 1.0 );\n}\n// --------[ Original ShaderToy ends here ]---------- //\n\nvoid main(void)\n{\n    mainImage(gl_FragColor, gl_FragCoord.xy);\n}";
        ShaderList2.Sheep = "/*\n * Original shader from: https://www.shadertoy.com/view/wdjBDK\n */\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n// glslsandbox uniforms\nuniform float time;\nuniform vec2 resolution;\n\n// shadertoy emulation\n#define iTime time\n#define iResolution resolution\n\n// --------[ Original ShaderToy begins here ]---------- //\n#define N 40.\n#define R iResolution.xy\n#define t iTime\n#define T (0.5 + 0.5 * sin(t))\n#define D(p) ((p - 0.5 * R.xy) / R.y)\n#define inf (1e38)\n#define pi (radians(180.))\n#define craziness 0.1\n\nvec2 rot(vec2 p, float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, -s, s, c) * p;\n}\n\nfloat uEllipse(vec2 p, vec2 ab, float q) {\n    p /= ab;\n    float a = (.5 + .5 * atan(p.y, p.x) / pi);\n    if (a < q) {\n    \treturn inf;\n    }\n\treturn abs(length(p) - 1.);\n}\n\nfloat distToV(vec2 p, vec2 o, vec2 v) {\n    vec2 op = p - o;\n    vec2 ep = op - v;\n    float d = length(ep - dot(ep, v) / dot(v, v) * v);\n    if (dot(op, v) < 0.) {\n        d = length(op);\n    }    \n    if (dot(ep, -v) < 0.) {\n        d = length(ep);\n    }\n    return d;\n}\n\nvec2 QB(vec2 a, vec2 b, vec2 c, float q) {\n    vec2 qab = a + q * (b - a);\n    vec2 qbc = b + q * (c - b);    \n    return qab + q * (qbc - qab);\n}\n\nfloat QBSdf(vec2 p, vec2 a, vec2 b, vec2 c) {\n    float s = inf;\n    for (float i = 1.; i <= N; i++) {\n        vec2 qb0 = QB(a, b, c, (i - 1.) / N);\n        vec2 qb1 = QB(a, b, c, i / N);\n        float d = distToV(p, qb0, qb1 - qb0);\n        s = min(s, d);\n    }\n    return s;\n}\n\nvec2 CB(vec2 a, vec2 b, vec2 c, vec2 d, float q) {\n    vec2 qab = mix(a, b, q);\n    vec2 qbc = mix(b, c, q);\n    vec2 qcd = mix(c, d, q);\n    vec2 qabc = mix(qab, qbc, q);\n    vec2 qbcd = mix(qbc, qcd, q);\n    return mix(qabc, qbcd, q);\n}\n\nfloat CBSdf(vec2 p, vec2 a, vec2 b, vec2 c, vec2 d) {\n    float s = inf;\n    for (float i = 1.; i <= N; i++) {\n        vec2 qb0 = CB(a, b, c, d, (i - 1.) / N);\n        vec2 qb1 = CB(a, b, c, d, i / N);\n        float d = distToV(p, qb0, qb1 - qb0);\n        s = min(s, d);\n    }\n    return s;\n}\n\nfloat Tail(vec2 p) {\n\tfloat d = inf;\n\tvec2 pt = rot(p - vec2(0.7, 0.03), -1.7);\n    float dt = QBSdf(pt, vec2(-0.08, -0.33), vec2(-0.05, -0.21), vec2(0.05, -0.3));\t\n    d = min(d, dt);\n    return d;\n}\n\nfloat Feet(vec2 p, float move) {\n\tfloat d = inf;\n    float f0x = -0.3\t;\n    float f0y0 = -0.19;\n    float f0y1 = -0.55 + move;\n    float f0y01 = (f0y0 + f0y1) / 2.;\n    float f0 = QBSdf(p, vec2(f0x, f0y0), vec2(f0x - 0.04 - move, f0y01), vec2(f0x, f0y1));\t\n    d = min(d, f0);\n    \n    float f1x = -0.12;\n    float f1y0 = -0.18;\n    float f1y1 = -0.6 + move;\n    float f1y01 = (f1y0 + f1y1) / 2.;\n    float f1 = QBSdf(p, vec2(f1x, f1y0), vec2(f1x - 0.04 - move, f1y01), vec2(f1x, f1y1));\t\n    d = min(d, f1);\n    \n    float f2x = 0.09;\n    float f2y0 = -0.22;\n    float f2y1 = -0.55 + move;\n    float f2y01 = (f2y0 + f2y1) / 2.;\n    float f2 = QBSdf(p, vec2(f2x, f2y0), vec2(f2x - 0.02 - move, f2y01), vec2(f2x, f2y1));\t\n    d = min(d, f2);\n\n    float f3x = 0.24;\n    float f3y0 = -0.24;\n    float f3y1 = -0.6 + move;\n    float f3y01 = (f3y0 + f3y1) / 2.;\n    float f3 = QBSdf(p, vec2(f3x, f3y0), vec2(f3x - 0.02 - move, f3y01), vec2(f3x, f3y1));\t\n    d = min(d, f3);    \n    \n    return d;\n}\n\nfloat Body(vec2 p) {\n    float d = inf;    \n    p.y -= 0.07;\n    vec2 p0 = rot(p - vec2(-0.43, 0.49), 0.4);\n    float d0 = QBSdf(p0, vec2(-0.18, -0.3), vec2(-0.02, -0.16), vec2(0.1, -0.3));\t\n    d = min(d, d0);\n    vec2 p1 = rot(p - vec2(-0.13, 0.58), 0.2);\n    float d1 = QBSdf(p1, vec2(-0.15, -0.3), vec2(0.03, -0.13), vec2(0.15, -0.3));\t\n    d = min(d, d1);\n    vec2 p2 = rot(p - vec2(0.31, 0.53), -0.5);\n    float d2 = QBSdf(p2, vec2(-0.1, -0.3), vec2(0.06, -0.15), vec2(0.14, -0.3));\t\n    d = min(d, d2);\n    vec2 p3 = rot(p - vec2(0.61, 0.18), -1.3);\n    float d3 = QBSdf(p3, vec2(-0.1, -0.3), vec2(0.02, -0.2), vec2(0.1, -0.3));\t\n    d = min(d, d3);\n\tvec2 p4 = rot(p - vec2(0.63, -0.14), -1.7);\n    float d4 = QBSdf(p4, vec2(-0.1, -0.3), vec2(0., -0.16), vec2(0.1, -0.3));\t\n    d = min(d, d4);\n\tvec2 p5 = rot(p - vec2(0.31, -.52), -2.8);\n    float d5 = QBSdf(p5, vec2(-0.11, -0.3), vec2(0., -0.16), vec2(0.11, -0.3));\t\n    d = min(d, d5);\n\tvec2 p6 = rot(p - vec2(-0.04, -.56), -3.25);\n    float d6 = QBSdf(p6, vec2(-0.11, -0.3), vec2(0., -0.16), vec2(0.11, -0.3));\t\n    d = min(d, d6);\n\tvec2 p7 = rot(p - vec2(-0.31, -.51), -3.4);\n    float d7 = QBSdf(p7, vec2(-0.11, -0.3), vec2(0., -0.16), vec2(0.11, -0.3));\t\n    d = min(d, d7);    \n\tvec2 p8 = rot(p - vec2(-0.6, -.39), -3.7);\n    float d8 = QBSdf(p8, vec2(-0.11, -0.3), vec2(-0.03, -0.19), vec2(0.05, -0.3));\t\n    d = min(d, d8);  \n    return d;\n}\n\nfloat Mouse(vec2 p, int state) {\n    float d = inf;\n    if (state == 0) {    \t\n        d = distToV(p, vec2(-0.16, -0.01), vec2(0.22, 0.));\n    }\n    return d;\n}\n\nfloat Head(vec2 p) {\n    float d = inf;\n    p = rot(p, 0.12);\n    p -= vec2(-0.46, 0.11);\n    float m = Mouse(p, 0);\n    d = min(d, m);\n    float rEye = smoothstep(0., 0.3, length(p - vec2(0.07, 0.07)));\n    d = min(d, rEye);\n    float lEye = smoothstep(0., 0.3, length(p - vec2(-0.11, 0.09)));\n    d = min(d, lEye);\n    vec2 pLEar = rot(p - vec2(-0.07, 0.13), 1.);\n    vec2 aLEar = vec2(-0.01, 0.);\n    vec2 bLEar = vec2(-0.1, 0.25);\n    vec2 cLEar = vec2(0.1, 0.25);\n    vec2 dLEar = vec2(0.01, 0.);\n    float lEar = CBSdf(pLEar, aLEar, bLEar, cLEar, dLEar);\n    d = min(d, lEar);\n    vec2 pREar = rot(p - vec2(0.09, 0.13), 5.);\n    vec2 aREar = vec2(-0.01, 0.);\n    vec2 bREar = vec2(-0.1, 0.25);\n    vec2 cREar = vec2(0.1, 0.25);\n    vec2 dREar = vec2(0.01, 0.);\n    float rEar = CBSdf(pREar, aREar, bREar, cREar, dREar);\n    d = min(d, rEar); \n    vec2 pFore = rot(p - vec2(0.01, 0.05), 0.);\n    float fore = smoothstep(0., 1., uEllipse(pFore, vec2(0.1, 0.1), 0.5));\n    d = min(d, fore);\n    vec2 pChin0 = rot(p - vec2(-0.08, -0.01), 1.55);\n    float chin0 = smoothstep(0., 1., uEllipse(pChin0, vec2(0.07, 0.135), 0.5));\n    d = min(d, chin0);\n    vec2 pChin1 = p - vec2(0.11, 0.05);\n    vec2 aChin1 = vec2(0., 0.);\n    vec2 bChin1 = vec2(0.013, -0.1);\n    vec2 cChin1 = vec2(0.014, -0.13);\n    vec2 dChin1 = vec2(-.2, -0.13);\n    float chin1 = CBSdf(pChin1, aChin1, bChin1, cChin1, dChin1);\n    d = min(d, chin1); \n            \n    return d;\n}\n\nfloat Scene(vec2 p) {\n    vec2 origp = p;\n    float d = inf;\n    // 13.19 rad/s which is 126 bpm per audio\n    float move = mix(0., craziness, max(0., sin(13.19 * (t + 1.1))));\n    p -= vec2(0., 0.1 - move);\n    p = 1.3 * p;\n    float body = Body(p);\n    d = min(d, body);\n    float head = Head(p);\n    d = min(d, head);\n    float tail = Tail(p);\n    d = min(d, tail);\n    float feet = Feet(p, move);\n    d = min(d, feet);\n    float field = QBSdf(origp - vec2(-0.5, -0.4), vec2(-0.7, 0.), vec2(0.5, 0.3), vec2(1.7, 0.));\n    d = min(d, field);\n    return 0.002 / d;\n}\n\nvoid mainImage(out vec4 o, in vec2 p)\n{    \n    o = vec4(1. - Scene(D(p)));\n}\n// --------[ Original ShaderToy ends here ]---------- //\n\nvoid main(void)\n{\n    mainImage(gl_FragColor, gl_FragCoord.xy);\n}";
        ShaderList2.Rakete = "/*\n * Original shader from: https://www.shadertoy.com/view/3dSBRG\n */\n\n#ifdef GL_ES\nprecision highp float;\n#endif\n\n// glslsandbox uniforms\nuniform float time;\nuniform vec2 resolution;\n\n// shadertoy emulation\n#define iTime time\n#define iResolution resolution\nconst vec4 iMouse = vec4(0.);\n\n// --------[ Original ShaderToy begins here ]---------- //\n// SylvainLC 2020 \n// Use mouse to move camera and rotate the rocket.\n// This is created essentially from the rendering code of IQ with referencies below.\n// Modeled the rocket using Vesica revolution and adding rounding to give it a balloon shape\n// Arches joining the Rocket and motors are made of 2D truncated arcs of cirles with Extrussion.\n// Used a symetry to replicate 3 times the motors around the rocket. \n// NOTE : You may add more motors modifing line 81 in common !!!\n// The rocket is carved and you can see inside thru the portholes.\n// Had a lot of fun painting the rocket with gray parts, the IQ rendering code is great.\n// I will not be able to make a such great rendering myself !\n// Added later the alien and the crater, unfortunately slowing the rendering on mobile.\n// 2020-06-02 Made some try to adapt the rythme of the animation to the music (slow)\n//            Changed colors of craters and sky\n//\n//\n// Below where the rendering code is coming from : \n// Step #2 of the LIVE Shade Deconstruction tutorial for \"Happy Jumping\"\n// Created by inigo quilez - iq/2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// https://www.youtube.com/watch?v=Cfe5UQ-1L9Q\n\n// Step 1: https://www.shadertoy.com/view/Wl2SRw\n// Step 2: https://www.shadertoy.com/view/3ljSzw\n// Step 3: https://www.shadertoy.com/view/ttjXDz\n// Step 4: https://www.shadertoy.com/view/tljSDz\n// Final:  https://www.shadertoy.com/view/3lsSzf\t\n\nmat2 rotationMatrix(float angle)\n{\n    float s=sin(angle), c=cos(angle);\n    return mat2( c, -s, s, c );\n}\n\n// polynomial smooth min (k = 0.1);\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n\n// http://iquilezles.org/www/articles/smin/smin.htm\nfloat smax( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*0.25/k;\n}\n\n//-------------------------------------------------\n\n// https://www.shadertoy.com/view/4lyfzw\nvec2 opRevolution( in vec3 p, float w )\n{\n    return vec2( length(p.xz) - w, p.y );\n}\nfloat opExtrussion( in vec3 p, in float sdf, in float h )\n{\n    vec2 w = vec2( sdf, abs(p.z) - h );\n  \treturn min(max(w.x,w.y),0.0) + length(max(w,0.0));\n}\n\n//-------------------------------------------------\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\n// http://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat sdVesica(vec2 p, float r, float d)\n{\n    p = abs(p);\n\n    float b = sqrt(r*r-d*d); // can delay this sqrt\n    return ((p.y-b)*d > p.x*b) \n            ? length(p-vec2(0.0,b))\n            : length(p-vec2(-d,0.0))-r;\n}\nfloat sdCircle(vec2 p, float r)\n{\n    return length(p)-r; \n}\n\nvec2 sdRocket( vec3 pos )\n{\n    float m = 2.; // material 2 = red, 3 = gray , 4 = portholes\n    // try to box in a sphere for optimization\n    if ( length(pos) > 1.4 ) { return vec2(length(pos)-1.3,2.); }\n\tfloat d = 1e10;\n    // body\n\tvec3 q;\n    q = pos - vec3(0.,0.,0.);\n\td = min( d, -0.01+abs(-0.1 + sdVesica(opRevolution(q,0.0), 1.4, 1.1 )));  // try with ABS to make empty space into the shape\n    if ( pos.y > 0.74 ) { m = 3.; } // painting\n    { \n        float dist = sdVesica(opRevolution(q,0.0), 1.4, 1.17 );\n\t\tif ( d > dist ) { d=dist ; m = 3.; }   \n    }\n    if ( pos.y < -0.90 ) { m = 3.; } // painting bottom \n    // strips \n    float vangle = atan(pos.z,pos.x); // angle from left to front\n    if ( sin(vangle*3.) <.5 ) {\n    if ( pos.y < -0.3  && pos.y > -0.5 && cos(vangle*6.)>.0 )  { m = 3. ; }\n    if ( pos.y < -0.5  && pos.y > -0.65 && cos(vangle*6.)<.0 ) { m = 3. ; }\n    if ( pos.y < -0.65 && pos.y > -0.80 && cos(vangle*6.)>.0 ) { m = 3. ; }\n    }\n    // 3 sectors for engines\n    const float an = 6.283185/3.0;\n\tq = pos;\n    q.xz = rotationMatrix(an*0.25)*q.xz; // rotation to position first piece\n    float fa = (atan(q.z,q.x)+an*0.5)/an; // thanks to IQ\n    float sym = an*floor(fa);\n    q.xz = rotationMatrix(sym)*q.xz;\n\t// d = min( d, );\n    float ln = -0.05 + sdVesica(opRevolution(vec3(q.x-.6,q.y+.8,q.z),0.0), 0.65, 0.5 ) ;\n    if ( ln < d ) { m = 2. ; d = ln ; }\n    // cut the bottom\n\td = smax( d, -pos.y-1.1, 0.05 );\n    if ( pos.y < -0.96 ) { m = 3.; } // painting bottom \n    // link between engines and rocket's body\n\tq = vec3(q.x+0.1,q.y+1.13,q.z+0.0);\n    float lnd = sdCircle(q.xy, 1.00 );\n        lnd = max(lnd,-sdCircle(q.xy+vec2(-0.3,0.3),0.6));\n        lnd = max(lnd,-q.x+0.1);\n        lnd = max(lnd,q.x-0.8);\n        lnd = max(lnd,-q.y+0.2);\n\tln = opExtrussion (q,lnd,0.02)-0.01;\n\t// d = min( d, ln );\n    if ( ln < d ) { m = 3. ; d = ln ; }\n    // 3 porthole\n    q = pos;\n    ln = sdSphere(q-vec3(0.0,0.37,0.37), 0.1 ); if ( ln < -d ) { m = 3. ; d = -ln ; }\n    ln = sdSphere(q-vec3(0.0,0.37-0.38,0.37), 0.1 ); if ( ln < -d ) { m = 3. ; d = -ln ; }  \n    vec3 r = q ; r.xz*=rotationMatrix(an) ;\n    ln = sdSphere(r-vec3(0.0,0.37-0.38,0.37), 0.1 ); if ( ln < -d ) { m = 3. ; d = -ln ; }  \n    r.xz*=rotationMatrix(an) ;\n    ln = sdSphere(r-vec3(0.0,0.37-0.38,0.37), 0.1 ); if ( ln < -d ) { m = 3. ; d = -ln ; }  \n    ln = sdSphere(q-vec3(0.0,0.37-0.38*2.,0.37), 0.1 ); if ( ln < -d ) { m = 3. ; d = -ln ; }    \n    return vec2(d,m);\n\n}\n\nfloat sdCone( vec3 p, vec2 c )\n{\n    // c is the sin/cos of the angle\n    vec2 q = vec2( length(p.xz), -p.y );\n    float d = length(q-c*max(dot(q,c), 0.0));\n    return d * ((q.x*c.y-q.y*c.x<0.0)?-1.0:1.0);\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nvec2 sdStick(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n    vec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn vec2( length( pa - ba*h ) - mix(r1,r2,h*h*(3.0-2.0*h)), h );\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nvec3 animateAlien(vec3 pos,float atime) {\n    float sequence = 10.*fract(atime/20.);\n    vec3 q = pos;\n    if (sequence < 5. ) {\n        q.y+=2.+2.*cos(3.14*sequence/5.);\n    } else if (sequence >7.) {\n        q.y-=10.*(-1.+1.*cos(3.14*(7.-sequence)/3.));\n    }\n    return q;\n}\n\nvec3 animateCamera(vec3 pos,float atime) {\n    float sequence = 10.*fract(atime/20.);\n    vec3 q = pos;\n    return q;\n    if (sequence < 3. ) { // not finished\n        q.x+=-2.*(1.+cos(3.14*sequence/3.));\n    } else if (sequence >7.) {\n        q.x+=-2.*(1.+sin(3.14*(sequence-7.)/3.));\n    }\n    return q;\n}\n\nvec3 animateRocket(vec3 pos,float atime,float spin) {\n    float sequence = 10.*fract(atime/20.);\n    vec3 q = pos;\n        q -= vec3(0,0.9,-1.6);\n        q.xz*=rotationMatrix(-atime*3.14/3.0);\n        q -= vec3(3.,0.,0.);\n        q -= vec3(0.,1.2+0.2*sin(atime*5.0),0.);\n        q.yz*=rotationMatrix(cos(atime*5.0)/5.-3.14/2.0);\n        q.xz*=rotationMatrix(1.2*3.14/2.0);\n//        q.xz*=rotationMatrix(1.*3.14/2.0);\n    q.xz*=rotationMatrix(spin+atime);  // spin\n    return q;\n}\n\nvec2 sdCrater( vec3 pos )\n{\n    float d=1e10;\n    if ( length(pos) > 1.95 ) { \n        d=length(pos)-1.8; \n    } else {\n // float d = sdCappedCone(pos-vec3(0.0,1.1,-1.0),0.7,1.0,0.5);\n    vec3 q = pos;\n    q.z-=q.y*q.y/6.;\n    q.xz=q.xz*rotationMatrix(1.9);\n    q.zy=q.zy*rotationMatrix(2.*sin(iTime*2.7)*q.y/20.); // bend\n    d = sdCone(q-vec3(0.,2.5,0.),vec2(sin(3.14/6.),cos(3.14/6.)));\n   // q = pos;\n    d = smax(d,-length(q.xz)+0.52,0.3 );\n    // small craters\n\tq = pos; \n    q.xz=q.xz*rotationMatrix(0.9);\n    q.zy=q.zy*rotationMatrix(2.*cos(iTime*2.7)*q.y/20.); // bend\n    d=smin(d,smax(sdCone(q-vec3(0.0,1.2,1.3),vec2(sin(3.14/8.),cos(3.14/8.))),-sdSphere(q-vec3(0.,1.0,1.3),0.3),0.1),0.1);\n    // small craters\n\tq = pos; \n    q.xz=q.xz*rotationMatrix(-0.9);\n    q.zy=q.zy*rotationMatrix(2.*sin(iTime*2.7)*q.y/20.); // bend\n    d=smin(d,smax(sdCone(q-vec3(0.0,0.7,1.3),vec2(sin(3.14/6.),cos(3.14/6.))),-sdSphere(q-vec3(0.,0.5,1.3),0.15),0.1),0.1);\n    }    \n    // cut the bottom\n//    d = smax(d,-q.y,0.2 );\n    // ground\n    d = smin(d,(pos.y + 0.1*sin(pos.z)+0.1*sin(pos.x)),0.05 );\n//    d = pos.y + 0.1*sin(pos.z)+0.1*sin(pos.z);\n    // to improve with a real noise function\n    d+= 0.01*sin(pos.z*10.)+0.01*sin(pos.x*10.);\n    vec2 res = vec2 ( d, 4. );\n    return res;\n}    \n\nvec2 sdAlien ( vec3 pos ) {\n    if ( length(pos) > 1.4 || pos.y < -2.0 ) { return vec2(length(pos)-1.3,2.); }\n    vec3 q = pos;\n    q.y-=abs(0.15*sin(iTime*2.*0.7));\n    q.yz*=rotationMatrix(-0.10+0.10*sin(iTime*1.4));\n    q.xz*=rotationMatrix(0.20*sin(iTime*0.7));\n    float d = sdEllipsoid(q,vec3(0.45,0.20,0.45)) ;\n    q.z-=.1;\n    vec3 top = vec3(0.15,0.5,0.2);\n    vec2 sti = sdStick(q,vec3(0.1,0.,0.),top,0.15,0.08);\n    d = smin(d,sti.x,0.05);\n    d = smin(d,sdSphere(q-top,.12),0.03);\n    top=vec3(-0.15,0.5,0.2);\n    sti = sdStick(q,vec3(-0.1,0.,0.),top,0.15,0.08);\n    d = smin(d,sti.x,0.05);\n    d = smin(d,sdSphere(q-top,.12),0.03);\n    top=vec3(0.0,0.70,0.25);\n    sti = sdStick(q,vec3(0.,0.,0.),top,0.15,0.08);\n    d = smin(d,sti.x,0.05);\n    d = smin(d,sdSphere(q-top,.14),0.03);\n    vec2 res = vec2 ( d, 5. );\n    // neck\n    sti = sdStick(q,vec3(0.,0.,-0.2),vec3(0.,-1.,-0.2),0.25,0.30);\n    d = smin(d,sti.x,0.05);\n    // mouth\n    top=vec3(0.0,0.02,0.04);\n    d = smin(d,sdTorus(q-top,vec2(.35,.03)),0.01);\n    res = vec2 ( d, 5. );\n    top=vec3(0.0,-0.02,0.04);\n    d = smin(d,sdTorus(q-top,vec2(.35,.03)),0.01);\n    res = vec2 ( d, 5. );\n    // eyes\n    // 1\n    top = vec3(0.15,0.5,0.26);\n    float s = sdSphere(q-top,.08);\n    if ( s < res.x ) { res.x=s ; res.y=6.; }\n    top = vec3(0.14,0.5,0.30);\n    s = sdSphere(q-top,.05);\n    if ( s < res.x ) { res.x=s ; res.y=7.; }\n    // 2\n    top = vec3(-0.15,0.5,0.26);\n    s = sdSphere(q-top,.08);\n    if ( s < res.x ) { res.x=s ; res.y=6.; }\n    top = vec3(-0.14,0.5,0.30);\n    s = sdSphere(q-top,.05);\n    if ( s < res.x ) { res.x=s ; res.y=7.; }\n    // 3\n    top=vec3(0.0,0.70,0.32);\n    s = sdSphere(q-top,.09);\n    if ( s < res.x ) { res.x=s ; res.y=6.; }\n    top=vec3(0.0,0.69,0.38);\n    s = sdSphere(q-top,.05);\n    if ( s < res.x ) { res.x=s ; res.y=7.; }\n    \n    return res;\n}\n\nvec2 map( in vec3 pos, float atime )\n{\n\t\tvec3 q = pos;\n    // rocket\n    vec2 dm = sdRocket(animateRocket(q,atime*0.7,10.*iMouse.y/iResolution.y)); \n    float d = dm.x;\n    vec2 res = vec2(d,dm.y);\n    // crater\n    q = pos;\n    dm = sdCrater(q-vec3(0.0,0.,-1.0)); \n    if ( dm.x < d ) { d = dm.x; res = vec2(d,dm.y); }\n    // Alien\n    dm = sdAlien(animateAlien(q,atime*0.7)-vec3(0.0,1.5,-1.0)); \n    if ( dm.x < d ) { d = dm.x; res = vec2(d,dm.y); }\n    return res;\n}\n\n\nvec2 castRay( in vec3 ro, in vec3 rd, float time )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 0.5;\n    float tmax = 20.0;\n    \n    float t = tmin;\n    for( int i=0; i<512 ; i++ )\n    {\n        vec2 h = map( ro+rd*t, time );\n        if( h.x<0.001 )\n        { \n            res = vec2(t,h.y); \n            break;\n        }\n        t += h.x;\n        if (t>=tmax) break;\n    }\n    \n    return res;\n}\n\n/* vec3 calcNormal( in vec3 pos, float time )\n{\n    vec3 n = vec3(0.0);\n    for( int i=min(iFrame,0); i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.0005*e,time).x;\n    }\n    return normalize(n);    \n} */\n\nvec3 calcNormal( in vec3 pos, float time )\n{\n    vec2 e = vec2(0.0005,0.0);\n    return normalize( vec3( \n        map( pos + e.xyy, time ).x - map( pos - e.xyy, time ).x,\n\t\tmap( pos + e.yxy, time ).x - map( pos - e.yxy, time ).x,\n\t\tmap( pos + e.yyx, time ).x - map( pos - e.yyx, time ).x ) );\n}\n\n\nfloat calcOcclusion( in vec3 pos, in vec3 nor, float time )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float h = 0.01 + 0.11*float(i)/4.0;\n        vec3 opos = pos + h*nor;\n        float d = map( opos, time ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 2.0*occ, 0.0, 1.0 );\n}\n\nvec3 render( in vec3 ro, in vec3 rd, float time )\n{ \n    // sky dome\n//     vec3 col = vec3(0.5, 0.8, 0.9) - max(rd.y,0.0)*0.5;\n//    vec3 col = vec3(0.2, 0.2, 0.2) - max(rd.y+0.60,0.00)*0.2;\n//      vec3 col = vec3(0.1, 0.1, 0.1) - max(rd.y+0.00,0.00)*0.5;\n    // sky dome here I wanted to add some stars\n    vec3 col = vec3(0.5, 0.5, 0.7) - max(rd.y,0.0)*0.5;\n    // sky clouds\n    vec2 uv = 1.5*rd.xz/rd.y;\n    float cl  = 1.0*(sin(uv.x)+sin(uv.y-iTime*0.7*0.5)); uv *= mat2(0.8,0.6,-0.6,0.8)*2.1;\n          cl += 0.5*(sin(uv.x)+sin(uv.y-iTime*0.7*0.5));\n    col += 0.1*(-1.0+2.0*smoothstep(-0.1,0.1,cl-0.4));\n    // sky horizon\n\tcol = mix( col, vec3(0.5, 0.5, .7), exp(-10.0*max(rd.y,0.0)) );    \n    \n    vec2 res = castRay(ro,rd, time);\n    if( res.y>-0.5 )\n    {\n        float t = res.x;\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos, time );\n        vec3 ref = reflect( rd, nor );\n        \n\t\tcol = vec3(0.2);\n        float ks = 1.0;\n\n\t\tif( res.y>6.5 ) // black\n        { \n            col = vec3(0.00,0.00,0.00);\n        }\n\t\telse if( res.y>5.5 ) // white\n        { \n            col = vec3(0.5,0.5,0.5);\n        }\n\t\telse if( res.y>4.5 ) // alien\n        { \n            col = vec3(0.05,0.20,0.05);\n        }\n\t\telse if( res.y>3.5 ) // crater\n        { \n            col = vec3(0.12,0.10,0.10);\n        }\n\t\telse if( res.y>2.5 ) // rocket gray part\n        { \n            col = vec3(0.1,0.1,0.1);\n        }\n\t\telse if( res.y>1.5 ) // rocket red part\n        { \n            col = vec3(0.5,0.00,0.00);\n        }\n\t\telse // terrain\n        {\n            col = vec3(0.02,0.02,0.02);\n        }\n        \n        // lighting\n        vec3  sun_lig = normalize( vec3(0.6, 0.35, 0.5) );\n        float sun_dif = clamp(dot( nor, sun_lig ), 0.0, 1.0 );\n        vec3  sun_hal = normalize( sun_lig-rd );\n        float sun_sha = step(castRay( pos+0.001*nor, sun_lig,time ).y,0.0);\n\t\tfloat sun_spe = ks*pow(clamp(dot(nor,sun_hal),0.0,1.0),8.0)*sun_dif*(0.04+0.96*pow(clamp(1.0+dot(sun_hal,rd),0.0,1.0),5.0));\n\t\tfloat sky_dif = sqrt(clamp( 0.5+0.5*nor.y, 0.0, 1.0 ));\n        float bou_dif = sqrt(clamp( 0.1-0.9*nor.y, 0.0, 1.0 ))*clamp(1.0-0.1*pos.y,0.0,1.0);\n\n\t\tvec3 lin = vec3(0.0);\n        lin += sun_dif*vec3(8.10,6.00,4.20)*sun_sha;\n        lin += sky_dif*vec3(0.50,0.70,1.00);\n        lin += bou_dif*vec3(0.40,1.00,0.40);\n\t\tcol = col*lin;\n\t\tcol += sun_spe*vec3(8.10,6.00,4.20)*sun_sha;\n        \n        col = mix( col, vec3(0.5,0.7,0.9), 1.0-exp( -0.0001*t*t*t ) );\n    }\n\n\tres.x = min(res.x, 20.);\n\tvec3 fog = vec3(0.5, 0.5, 0.7) - max(rd.y+0.60,0.00)*0.2;\n\tcol = mix(col, fog, smoothstep(0., .99, res.x*res.x/400.));\n    \n    return col;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n    float time = iTime;\n\n    time *= 0.9;\n\n    // camera\t\n    float an = iMouse.x == 0. ? 0. : 10.*(-0.5+iMouse.x/iResolution.x);\n//    an = 0.5*sin(iTime);\n    vec3  ta = vec3( 0.0, 1.5, -1.5);\n    vec3  ro =  vec3 (0.,2.65,3.8);\n    ro = animateCamera(ro,time);\n    ro.xz = ro.xz * rotationMatrix(an);\n\n    mat3 ca = setCamera( ro, ta, 0.0 );\n\n    vec3 rd = ca * normalize( vec3(p,1.8) );\n\n    vec3 col = render( ro, rd, time );\n\n    col = pow( col, vec3(0.4545) );\n\n    fragColor = vec4( col, 1.0 );\n}\n\n// --------[ Original ShaderToy ends here ]---------- //\n\nvoid main(void)\n{\n    mainImage(gl_FragColor, gl_FragCoord.xy);\n}";
        ShaderList2.Leuchtring = "precision mediump float;\nuniform float time;\nuniform vec2  resolution;\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main(void){\n    vec3 destColor = hsv2rgb(vec3(time*3. / 15.0, 1.0, 0.3));\n    vec2 p = (gl_FragCoord.xy * 2.0 - resolution) / min(resolution.x, resolution.y);\n    float l = 0.05 / abs(length(p) - 0.5);\n    gl_FragColor = vec4(l*destColor, 1.0);\n}";
        ShaderList2.Ecasty = "// 180820N\n\nprecision highp float;\n\nuniform vec2 resolution;\nuniform float time;\nuniform vec2 mouse;\n\nfloat random (in vec2 point) {\n  return fract(100.0 * sin(point.x + fract(100.0 * sin(point.y)))); // http://www.matteo-basei.it/noise\n}\n\nfloat noise (in vec2 st) {\n  vec2 i = floor(st);\n  vec2 f = fract(st);\n\n  float a = random(i);\n  float b = random(i + vec2(1., 0.));\n  float c = random(i + vec2(0., 1.));\n  float d = random(i + vec2(1., 1.));\n\n  vec2 u = f * f * (3. - 2. * f);\n\n  return mix(a, b, u.x) + (c - a)* u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\n#define octaves 7\n\nfloat fbm (in vec2 p) {\n  float value = 0.;\n  float freq = 1.;\n  float amp = .5;\n\n  for (int i = 0; i < octaves; i++) {\n    value += amp * (noise((p - vec2(1.)) * freq));\n    freq *= 1.9;\n    amp *= .6;\n  }\n\n  return value;\n}\n\nfloat pattern(in vec2 p) {\n  vec2 offset = vec2(-.5);\n\n  vec2 aPos = vec2(sin(time * .05), sin(time * .1)) * 6.;\n  vec2 aScale = vec2(3.);\n  float a = fbm(p * aScale + aPos);\n\n  vec2 bPos = vec2(sin(time * .1), sin(time * .1)) * 1.;\n  vec2 bScale = vec2(.5);\n  float b = fbm((p + a) * bScale + bPos);\n\n  vec2 cPos = vec2(-.6, -.5) + vec2(sin(-time * .01), sin(time * .1)) * 2.;\n  vec2 cScale = vec2(2.);\n  float c = fbm((p + b) * cScale + cPos);\n\n  return c;\n}\n\nvec3 palette(in float t) {\n  vec3 a = vec3(.5, .5, .5);\n  vec3 b = vec3(.45, .25, .14);\n  vec3 c = vec3(1. ,1., 1.);\n  vec3 d = vec3(0., .1, .2);\n\n  return a + b * cos(6.28318 * (c * t + d));\n}\n\nvoid main() {\n  vec2 p = gl_FragCoord.xy / resolution.xy;\n  p.x *= resolution.x / resolution.y;\n\n  float value = pow(pattern(p), 2.);\n  vec3 color  = palette(value);\n\n\t\n\t// effect 2\n\tvec2 uv = (gl_FragCoord.xy - resolution * 0.5) / max(resolution.x, resolution.y) * 4.0;\t\n\tuv.x += 4.0;\n\tuv *= 80.0;\n\tvec2 z=uv;\n\tuv.x = 1./z.y*sin(4.*uv.y);\n\tuv.y = 1./z.x*sin(4.*uv.y);\n\t\n\tcolor.x = uv.x * cos(time) - uv.y *sin(time);\n\tcolor.x = smoothstep(0.0, 0.1, color.x);\n\t\n\t\n  gl_FragColor = vec4(color, 1.);\n}";
    }
}
